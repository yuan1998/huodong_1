/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);
  config.method = config.method ? config.method.toLowerCase() : 'get';

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
var isAbsoluteURL = __webpack_require__(/*! ./../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ./../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  utils.forEach(['url', 'method', 'params', 'data'], function valueFromConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    }
  });

  utils.forEach(['headers', 'auth', 'proxy'], function mergeDeepProperties(prop) {
    if (utils.isObject(config2[prop])) {
      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (utils.isObject(config1[prop])) {
      config[prop] = utils.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  utils.forEach([
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength',
    'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken',
    'socketPath'
  ], function defaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  // Only Node.JS has a process variable that is of [[Class]] process
  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/axios/node_modules/is-buffer/index.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function deepMerge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = deepMerge(result[key], val);
    } else if (typeof val === 'object') {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
};


/***/ }),

/***/ "./node_modules/axios/node_modules/is-buffer/index.js":
/*!************************************************************!*\
  !*** ./node_modules/axios/node_modules/is-buffer/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

module.exports = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}


/***/ }),

/***/ "./node_modules/html2canvas/dist/html2canvas.js":
/*!******************************************************!*\
  !*** ./node_modules/html2canvas/dist/html2canvas.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * html2canvas 1.0.0-rc.3 <https://html2canvas.hertzen.com>
 * Copyright (c) 2019 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
(function (global, factory) {
     true ? module.exports = factory() :
    undefined;
}(this, function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var Bounds = /** @class */ (function () {
        function Bounds(x, y, w, h) {
            this.left = x;
            this.top = y;
            this.width = w;
            this.height = h;
        }
        Bounds.prototype.add = function (x, y, w, h) {
            return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);
        };
        Bounds.fromClientRect = function (clientRect) {
            return new Bounds(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
        };
        return Bounds;
    }());
    var parseBounds = function (node) {
        return Bounds.fromClientRect(node.getBoundingClientRect());
    };
    var parseDocumentSize = function (document) {
        var body = document.body;
        var documentElement = document.documentElement;
        if (!body || !documentElement) {
            throw new Error("Unable to get document size");
        }
        var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
        var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
        return new Bounds(0, 0, width, height);
    };

    /*
     * css-line-break 1.1.1 <https://github.com/niklasvh/css-line-break#readme>
     * Copyright (c) 2019 Niklas von Hertzen <https://hertzen.com>
     * Released under MIT License
     */
    var toCodePoints = function (str) {
        var codePoints = [];
        var i = 0;
        var length = str.length;
        while (i < length) {
            var value = str.charCodeAt(i++);
            if (value >= 0xd800 && value <= 0xdbff && i < length) {
                var extra = str.charCodeAt(i++);
                if ((extra & 0xfc00) === 0xdc00) {
                    codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
                }
                else {
                    codePoints.push(value);
                    i--;
                }
            }
            else {
                codePoints.push(value);
            }
        }
        return codePoints;
    };
    var fromCodePoint = function () {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            codePoints[_i] = arguments[_i];
        }
        if (String.fromCodePoint) {
            return String.fromCodePoint.apply(String, codePoints);
        }
        var length = codePoints.length;
        if (!length) {
            return '';
        }
        var codeUnits = [];
        var index = -1;
        var result = '';
        while (++index < length) {
            var codePoint = codePoints[index];
            if (codePoint <= 0xffff) {
                codeUnits.push(codePoint);
            }
            else {
                codePoint -= 0x10000;
                codeUnits.push((codePoint >> 10) + 0xd800, codePoint % 0x400 + 0xdc00);
            }
            if (index + 1 === length || codeUnits.length > 0x4000) {
                result += String.fromCharCode.apply(String, codeUnits);
                codeUnits.length = 0;
            }
        }
        return result;
    };
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    // Use a lookup table to find the index.
    var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
    for (var i = 0; i < chars.length; i++) {
        lookup[chars.charCodeAt(i)] = i;
    }
    var decode = function (base64) {
        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
        if (base64[base64.length - 1] === '=') {
            bufferLength--;
            if (base64[base64.length - 2] === '=') {
                bufferLength--;
            }
        }
        var buffer = typeof ArrayBuffer !== 'undefined' &&
            typeof Uint8Array !== 'undefined' &&
            typeof Uint8Array.prototype.slice !== 'undefined'
            ? new ArrayBuffer(bufferLength)
            : new Array(bufferLength);
        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
        for (i = 0; i < len; i += 4) {
            encoded1 = lookup[base64.charCodeAt(i)];
            encoded2 = lookup[base64.charCodeAt(i + 1)];
            encoded3 = lookup[base64.charCodeAt(i + 2)];
            encoded4 = lookup[base64.charCodeAt(i + 3)];
            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
        }
        return buffer;
    };
    var polyUint16Array = function (buffer) {
        var length = buffer.length;
        var bytes = [];
        for (var i = 0; i < length; i += 2) {
            bytes.push((buffer[i + 1] << 8) | buffer[i]);
        }
        return bytes;
    };
    var polyUint32Array = function (buffer) {
        var length = buffer.length;
        var bytes = [];
        for (var i = 0; i < length; i += 4) {
            bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
        }
        return bytes;
    };

    /** Shift size for getting the index-2 table offset. */
    var UTRIE2_SHIFT_2 = 5;
    /** Shift size for getting the index-1 table offset. */
    var UTRIE2_SHIFT_1 = 6 + 5;
    /**
     * Shift size for shifting left the index array values.
     * Increases possible data size with 16-bit index values at the cost
     * of compactability.
     * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
     */
    var UTRIE2_INDEX_SHIFT = 2;
    /**
     * Difference between the two shift sizes,
     * for getting an index-1 offset from an index-2 offset. 6=11-5
     */
    var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
    /**
     * The part of the index-2 table for U+D800..U+DBFF stores values for
     * lead surrogate code _units_ not code _points_.
     * Values for lead surrogate code _points_ are indexed with this portion of the table.
     * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
     */
    var UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;
    /** Number of entries in a data block. 32=0x20 */
    var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
    /** Mask for getting the lower bits for the in-data-block offset. */
    var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
    var UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;
    /** Count the lengths of both BMP pieces. 2080=0x820 */
    var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
    /**
     * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
     * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
     */
    var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
    var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
    /**
     * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
     * Variable length, for code points up to highStart, where the last single-value range starts.
     * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
     * (For 0x100000 supplementary code points U+10000..U+10ffff.)
     *
     * The part of the index-2 table for supplementary code points starts
     * after this index-1 table.
     *
     * Both the index-1 table and the following part of the index-2 table
     * are omitted completely if there is only BMP data.
     */
    var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
    /**
     * Number of index-1 entries for the BMP. 32=0x20
     * This part of the index-1 table is omitted from the serialized form.
     */
    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;
    /** Number of entries in an index-2 block. 64=0x40 */
    var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
    /** Mask for getting the lower bits for the in-index-2-block offset. */
    var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
    var slice16 = function (view, start, end) {
        if (view.slice) {
            return view.slice(start, end);
        }
        return new Uint16Array(Array.prototype.slice.call(view, start, end));
    };
    var slice32 = function (view, start, end) {
        if (view.slice) {
            return view.slice(start, end);
        }
        return new Uint32Array(Array.prototype.slice.call(view, start, end));
    };
    var createTrieFromBase64 = function (base64) {
        var buffer = decode(base64);
        var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
        var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
        var headerLength = 24;
        var index = slice16(view16, headerLength / 2, view32[4] / 2);
        var data = view32[5] === 2
            ? slice16(view16, (headerLength + view32[4]) / 2)
            : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
        return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
    };
    var Trie = /** @class */ (function () {
        function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
            this.initialValue = initialValue;
            this.errorValue = errorValue;
            this.highStart = highStart;
            this.highValueIndex = highValueIndex;
            this.index = index;
            this.data = data;
        }
        /**
         * Get the value for a code point as stored in the Trie.
         *
         * @param codePoint the code point
         * @return the value
         */
        Trie.prototype.get = function (codePoint) {
            var ix;
            if (codePoint >= 0) {
                if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
                    // Ordinary BMP code point, excluding leading surrogates.
                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
                    // 16 bit data is stored in the index array itself.
                    ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                    return this.data[ix];
                }
                if (codePoint <= 0xffff) {
                    // Lead Surrogate Code Point.  A Separate index section is stored for
                    // lead surrogate code units and code points.
                    //   The main index has the code unit data.
                    //   For this function, we need the code point data.
                    // Note: this expression could be refactored for slightly improved efficiency, but
                    //       surrogate code points will be so rare in practice that it's not worth it.
                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2)];
                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                    return this.data[ix];
                }
                if (codePoint < this.highStart) {
                    // Supplemental code point, use two-level lookup.
                    ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                    ix = this.index[ix];
                    ix += (codePoint >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;
                    ix = this.index[ix];
                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                    return this.data[ix];
                }
                if (codePoint <= 0x10ffff) {
                    return this.data[this.highValueIndex];
                }
            }
            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
            return this.errorValue;
        };
        return Trie;
    }());

    var base64 = 'KwAAAAAAAAAACA4AIDoAAPAfAAACAAAAAAAIABAAGABAAEgAUABYAF4AZgBeAGYAYABoAHAAeABeAGYAfACEAIAAiACQAJgAoACoAK0AtQC9AMUAXgBmAF4AZgBeAGYAzQDVAF4AZgDRANkA3gDmAOwA9AD8AAQBDAEUARoBIgGAAIgAJwEvATcBPwFFAU0BTAFUAVwBZAFsAXMBewGDATAAiwGTAZsBogGkAawBtAG8AcIBygHSAdoB4AHoAfAB+AH+AQYCDgIWAv4BHgImAi4CNgI+AkUCTQJTAlsCYwJrAnECeQKBAk0CiQKRApkCoQKoArACuALAAsQCzAIwANQC3ALkAjAA7AL0AvwCAQMJAxADGAMwACADJgMuAzYDPgOAAEYDSgNSA1IDUgNaA1oDYANiA2IDgACAAGoDgAByA3YDfgOAAIQDgACKA5IDmgOAAIAAogOqA4AAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAK8DtwOAAIAAvwPHA88D1wPfAyAD5wPsA/QD/AOAAIAABAQMBBIEgAAWBB4EJgQuBDMEIAM7BEEEXgBJBCADUQRZBGEEaQQwADAAcQQ+AXkEgQSJBJEEgACYBIAAoASoBK8EtwQwAL8ExQSAAIAAgACAAIAAgACgAM0EXgBeAF4AXgBeAF4AXgBeANUEXgDZBOEEXgDpBPEE+QQBBQkFEQUZBSEFKQUxBTUFPQVFBUwFVAVcBV4AYwVeAGsFcwV7BYMFiwWSBV4AmgWgBacFXgBeAF4AXgBeAKsFXgCyBbEFugW7BcIFwgXIBcIFwgXQBdQF3AXkBesF8wX7BQMGCwYTBhsGIwYrBjMGOwZeAD8GRwZNBl4AVAZbBl4AXgBeAF4AXgBeAF4AXgBeAF4AXgBeAGMGXgBqBnEGXgBeAF4AXgBeAF4AXgBeAF4AXgB5BoAG4wSGBo4GkwaAAIADHgR5AF4AXgBeAJsGgABGA4AAowarBrMGswagALsGwwbLBjAA0wbaBtoG3QbaBtoG2gbaBtoG2gblBusG8wb7BgMHCwcTBxsHCwcjBysHMAc1BzUHOgdCB9oGSgdSB1oHYAfaBloHaAfaBlIH2gbaBtoG2gbaBtoG2gbaBjUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHbQdeAF4ANQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQd1B30HNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B4MH2gaKB68EgACAAIAAgACAAIAAgACAAI8HlwdeAJ8HpweAAIAArwe3B14AXgC/B8UHygcwANAH2AfgB4AA6AfwBz4B+AcACFwBCAgPCBcIogEYAR8IJwiAAC8INwg/CCADRwhPCFcIXwhnCEoDGgSAAIAAgABvCHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIhAiLCI4IMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAANQc1BzUHNQc1BzUHNQc1BzUHNQc1B54INQc1B6II2gaqCLIIugiAAIAAvgjGCIAAgACAAIAAgACAAIAAgACAAIAAywiHAYAA0wiAANkI3QjlCO0I9Aj8CIAAgACAAAIJCgkSCRoJIgknCTYHLwk3CZYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiAAIAAAAFAAXgBeAGAAcABeAHwAQACQAKAArQC9AJ4AXgBeAE0A3gBRAN4A7AD8AMwBGgEAAKcBNwEFAUwBXAF4QkhCmEKnArcCgAHHAsABz4LAAcABwAHAAd+C6ABoAG+C/4LAAcABwAHAAc+DF4MAAcAB54M3gweDV4Nng3eDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEeDqABVg6WDqABoQ6gAaABoAHXDvcONw/3DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DncPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB7cPPwlGCU4JMACAAIAAgABWCV4JYQmAAGkJcAl4CXwJgAkwADAAMAAwAIgJgACLCZMJgACZCZ8JowmrCYAAswkwAF4AXgB8AIAAuwkABMMJyQmAAM4JgADVCTAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAqwYWBNkIMAAwADAAMADdCeAJ6AnuCR4E9gkwAP4JBQoNCjAAMACAABUK0wiAAB0KJAosCjQKgAAwADwKQwqAAEsKvQmdCVMKWwowADAAgACAALcEMACAAGMKgABrCjAAMAAwADAAMAAwADAAMAAwADAAMAAeBDAAMAAwADAAMAAwADAAMAAwADAAMAAwAIkEPQFzCnoKiQSCCooKkAqJBJgKoAqkCokEGAGsCrQKvArBCjAAMADJCtEKFQHZCuEK/gHpCvEKMAAwADAAMACAAIwE+QowAIAAPwEBCzAAMAAwADAAMACAAAkLEQswAIAAPwEZCyELgAAOCCkLMAAxCzkLMAAwADAAMAAwADAAXgBeAEELMAAwADAAMAAwADAAMAAwAEkLTQtVC4AAXAtkC4AAiQkwADAAMAAwADAAMAAwADAAbAtxC3kLgAuFC4sLMAAwAJMLlwufCzAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAApwswADAAMACAAIAAgACvC4AAgACAAIAAgACAALcLMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAvwuAAMcLgACAAIAAgACAAIAAyguAAIAAgACAAIAA0QswADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAANkLgACAAIAA4AswADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACJCR4E6AswADAAhwHwC4AA+AsADAgMEAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMACAAIAAGAwdDCUMMAAwAC0MNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQw1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHPQwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADUHNQc1BzUHNQc1BzUHNQc2BzAAMAA5DDUHNQc1BzUHNQc1BzUHNQc1BzUHNQdFDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAATQxSDFoMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAF4AXgBeAF4AXgBeAF4AYgxeAGoMXgBxDHkMfwxeAIUMXgBeAI0MMAAwADAAMAAwAF4AXgCVDJ0MMAAwADAAMABeAF4ApQxeAKsMswy7DF4Awgy9DMoMXgBeAF4AXgBeAF4AXgBeAF4AXgDRDNkMeQBqCeAM3Ax8AOYM7Az0DPgMXgBeAF4AXgBeAF4AXgBeAF4AXgBeAF4AXgBeAF4AXgCgAAANoAAHDQ4NFg0wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAeDSYNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAC4NMABeAF4ANg0wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAD4NRg1ODVYNXg1mDTAAbQ0wADAAMAAwADAAMAAwADAA2gbaBtoG2gbaBtoG2gbaBnUNeg3CBYANwgWFDdoGjA3aBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gaUDZwNpA2oDdoG2gawDbcNvw3HDdoG2gbPDdYN3A3fDeYN2gbsDfMN2gbaBvoN/g3aBgYODg7aBl4AXgBeABYOXgBeACUG2gYeDl4AJA5eACwO2w3aBtoGMQ45DtoG2gbaBtoGQQ7aBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gZJDjUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B1EO2gY1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQdZDjUHNQc1BzUHNQc1B2EONQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHaA41BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B3AO2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gY1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B2EO2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gZJDtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBkkOeA6gAKAAoAAwADAAMAAwAKAAoACgAKAAoACgAKAAgA4wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAD//wQABAAEAAQABAAEAAQABAAEAA0AAwABAAEAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAKABMAFwAeABsAGgAeABcAFgASAB4AGwAYAA8AGAAcAEsASwBLAEsASwBLAEsASwBLAEsAGAAYAB4AHgAeABMAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAFgAbABIAHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYADQARAB4ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkAFgAaABsAGwAbAB4AHQAdAB4ATwAXAB4ADQAeAB4AGgAbAE8ATwAOAFAAHQAdAB0ATwBPABcATwBPAE8AFgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwArAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAAQABAANAA0ASwBLAEsASwBLAEsASwBLAEsASwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUAArACsABABQAAQABAAEAAQABAAEAAQAKwArAAQABAArACsABAAEAAQAUAArACsAKwArACsAKwArACsABAArACsAKwArAFAAUAArAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAGgAaAFAAUABQAFAAUABMAB4AGwBQAB4AKwArACsABAAEAAQAKwBQAFAAUABQAFAAUAArACsAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUAArAFAAUAArACsABAArAAQABAAEAAQABAArACsAKwArAAQABAArACsABAAEAAQAKwArACsABAArACsAKwArACsAKwArAFAAUABQAFAAKwBQACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwAEAAQAUABQAFAABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUAArACsABABQAAQABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQAKwArAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwAeABsAKwArACsAKwArACsAKwBQAAQABAAEAAQABAAEACsABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwArAAQABAArACsABAAEAAQAKwArACsAKwArACsAKwArAAQABAArACsAKwArAFAAUAArAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwAeAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwAEAFAAKwBQAFAAUABQAFAAUAArACsAKwBQAFAAUAArAFAAUABQAFAAKwArACsAUABQACsAUAArAFAAUAArACsAKwBQAFAAKwArACsAUABQAFAAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQAKwArACsABAAEAAQAKwAEAAQABAAEACsAKwBQACsAKwArACsAKwArAAQAKwArACsAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAB4AHgAeAB4AHgAeABsAHgArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABAArACsAKwArACsAKwArAAQABAArAFAAUABQACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAB4AUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABAArACsAKwArACsAKwArAAQABAArACsAKwArACsAKwArAFAAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwArAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAKwBcAFwAKwBcACsAKwBcACsAKwArACsAKwArAFwAXABcAFwAKwBcAFwAXABcAFwAXABcACsAXABcAFwAKwBcACsAXAArACsAXABcACsAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgArACoAKgBcACsAKwBcAFwAXABcAFwAKwBcACsAKgAqACoAKgAqACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAFwAXABcAFwAUAAOAA4ADgAOAB4ADgAOAAkADgAOAA0ACQATABMAEwATABMACQAeABMAHgAeAB4ABAAEAB4AHgAeAB4AHgAeAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUAANAAQAHgAEAB4ABAAWABEAFgARAAQABABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAAQABAAEAAQABAANAAQABABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsADQANAB4AHgAeAB4AHgAeAAQAHgAeAB4AHgAeAB4AKwAeAB4ADgAOAA0ADgAeAB4AHgAeAB4ACQAJACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgAeAB4AHgBcAFwAXABcAFwAXAAqACoAKgAqAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAKgAqACoAKgAqACoAKgBcAFwAXAAqACoAKgAqAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAXAAqAEsASwBLAEsASwBLAEsASwBLAEsAKgAqACoAKgAqACoAUABQAFAAUABQAFAAKwBQACsAKwArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQACsAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwAEAAQABAAeAA0AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAEQArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAADQANAA0AUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAA0ADQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoADQANABUAXAANAB4ADQAbAFwAKgArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAB4AHgATABMADQANAA4AHgATABMAHgAEAAQABAAJACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAUABQAFAAUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwAeACsAKwArABMAEwBLAEsASwBLAEsASwBLAEsASwBLAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwBcAFwAXABcAFwAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcACsAKwArACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwAeAB4AXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgArACsABABLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKgAqACoAKgAqACoAKgBcACoAKgAqACoAKgAqACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAUABQAFAAUABQAFAAUAArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4ADQANAA0ADQAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAHgAeAB4AHgBQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwANAA0ADQANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwBQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsABAAEAAQAHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAABABQAFAAUABQAAQABAAEAFAAUAAEAAQABAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAKwBQACsAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAKwArAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAKwAeAB4AHgAeAB4AHgAeAA4AHgArAA0ADQANAA0ADQANAA0ACQANAA0ADQAIAAQACwAEAAQADQAJAA0ADQAMAB0AHQAeABcAFwAWABcAFwAXABYAFwAdAB0AHgAeABQAFAAUAA0AAQABAAQABAAEAAQABAAJABoAGgAaABoAGgAaABoAGgAeABcAFwAdABUAFQAeAB4AHgAeAB4AHgAYABYAEQAVABUAFQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgANAB4ADQANAA0ADQAeAA0ADQANAAcAHgAeAB4AHgArAAQABAAEAAQABAAEAAQABAAEAAQAUABQACsAKwBPAFAAUABQAFAAUAAeAB4AHgAWABEATwBQAE8ATwBPAE8AUABQAFAAUABQAB4AHgAeABYAEQArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAGwAbABsAGwAbABsAGwAaABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAaABsAGwAbABsAGgAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgBQABoAHgAdAB4AUAAeABoAHgAeAB4AHgAeAB4AHgAeAB4ATwAeAFAAGwAeAB4AUABQAFAAUABQAB4AHgAeAB0AHQAeAFAAHgBQAB4AUAAeAFAATwBQAFAAHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AUABQAFAAUABPAE8AUABQAFAAUABQAE8AUABQAE8AUABPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAE8ATwBPAE8ATwBPAE8ATwBPAE8AUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAATwAeAB4AKwArACsAKwAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB0AHQAeAB4AHgAdAB0AHgAeAB0AHgAeAB4AHQAeAB0AGwAbAB4AHQAeAB4AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB0AHgAdAB4AHQAdAB0AHQAdAB0AHgAdAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAdAB0AHQAdAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAlACUAHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBQAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB0AHQAeAB4AHgAeAB0AHQAdAB4AHgAdAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB0AHQAeAB4AHQAeAB4AHgAeAB0AHQAeAB4AHgAeACUAJQAdAB0AJQAeACUAJQAlACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAHgAeAB4AHgAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHQAdAB0AHgAdACUAHQAdAB4AHQAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHQAdAB0AHQAlAB4AJQAlACUAHQAlACUAHQAdAB0AJQAlAB0AHQAlAB0AHQAlACUAJQAeAB0AHgAeAB4AHgAdAB0AJQAdAB0AHQAdAB0AHQAlACUAJQAlACUAHQAlACUAIAAlAB0AHQAlACUAJQAlACUAJQAlACUAHgAeAB4AJQAlACAAIAAgACAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeABcAFwAXABcAFwAXAB4AEwATACUAHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwArACUAJQBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAKwArACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAE8ATwBPAE8ATwBPAE8ATwAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeACsAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUAArACsAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQBQAFAAUABQACsAKwArACsAUABQAFAAUABQAFAAUABQAA0AUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQACsAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgBQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAABAAEAAQAKwAEAAQAKwArACsAKwArAAQABAAEAAQAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsABAAEAAQAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsADQANAA0ADQANAA0ADQANAB4AKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AUABQAFAAUABQAFAAUABQAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAUABQAFAAUABQAA0ADQANAA0ADQANABQAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwANAA0ADQANAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAeAAQABAAEAB4AKwArAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLACsADQArAB4AKwArAAQABAAEAAQAUABQAB4AUAArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwAEAAQABAAEAAQABAAEAAQABAAOAA0ADQATABMAHgAeAB4ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0AUABQAFAAUAAEAAQAKwArAAQADQANAB4AUAArACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXABcAA0ADQANACoASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUAArACsAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANACsADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEcARwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQACsAKwAeAAQABAANAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAEAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUAArACsAUAArACsAUABQACsAKwBQAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AKwArAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAeAB4ADQANAA0ADQAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAArAAQABAArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAEAAQABAAEAAQABAAEACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAFgAWAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAKwBQACsAKwArACsAKwArAFAAKwArACsAKwBQACsAUAArAFAAKwBQAFAAUAArAFAAUAArAFAAKwArAFAAKwBQACsAUAArAFAAKwBQACsAUABQACsAUAArACsAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAUABQAFAAUAArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUAArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAlACUAJQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeACUAJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeACUAJQAlACUAJQAeACUAJQAlACUAJQAgACAAIAAlACUAIAAlACUAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIQAhACEAIQAhACUAJQAgACAAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACAAIAAlACUAJQAlACAAJQAgACAAIAAgACAAIAAgACAAIAAlACUAJQAgACUAJQAlACUAIAAgACAAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeACUAHgAlAB4AJQAlACUAJQAlACAAJQAlACUAJQAeACUAHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAIAAgACAAJQAlACUAIAAgACAAIAAgAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFwAXABcAFQAVABUAHgAeAB4AHgAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACAAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAlACAAIAAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsA';

    /* @flow */
    var LETTER_NUMBER_MODIFIER = 50;
    // Non-tailorable Line Breaking Classes
    var BK = 1; //  Cause a line break (after)
    var CR = 2; //  Cause a line break (after), except between CR and LF
    var LF = 3; //  Cause a line break (after)
    var CM = 4; //  Prohibit a line break between the character and the preceding character
    var NL = 5; //  Cause a line break (after)
    var WJ = 7; //  Prohibit line breaks before and after
    var ZW = 8; //  Provide a break opportunity
    var GL = 9; //  Prohibit line breaks before and after
    var SP = 10; // Enable indirect line breaks
    var ZWJ = 11; // Prohibit line breaks within joiner sequences
    // Break Opportunities
    var B2 = 12; //  Provide a line break opportunity before and after the character
    var BA = 13; //  Generally provide a line break opportunity after the character
    var BB = 14; //  Generally provide a line break opportunity before the character
    var HY = 15; //  Provide a line break opportunity after the character, except in numeric context
    var CB = 16; //   Provide a line break opportunity contingent on additional information
    // Characters Prohibiting Certain Breaks
    var CL = 17; //  Prohibit line breaks before
    var CP = 18; //  Prohibit line breaks before
    var EX = 19; //  Prohibit line breaks before
    var IN = 20; //  Allow only indirect line breaks between pairs
    var NS = 21; //  Allow only indirect line breaks before
    var OP = 22; //  Prohibit line breaks after
    var QU = 23; //  Act like they are both opening and closing
    // Numeric Context
    var IS = 24; //  Prevent breaks after any and before numeric
    var NU = 25; //  Form numeric expressions for line breaking purposes
    var PO = 26; //  Do not break following a numeric expression
    var PR = 27; //  Do not break in front of a numeric expression
    var SY = 28; //  Prevent a break before; and allow a break after
    // Other Characters
    var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID
    var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters
    var CJ = 31; //  Treat as NS or ID for strict or normal breaking.
    var EB = 32; //  Do not break from following Emoji Modifier
    var EM = 33; //  Do not break from preceding Emoji Base
    var H2 = 34; //  Form Korean syllable blocks
    var H3 = 35; //  Form Korean syllable blocks
    var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic
    var ID = 37; //  Break before or after; except in some numeric context
    var JL = 38; //  Form Korean syllable blocks
    var JV = 39; //  Form Korean syllable blocks
    var JT = 40; //  Form Korean syllable blocks
    var RI = 41; //  Keep pairs together. For pairs; break before and after other classes
    var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis
    var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions
    var BREAK_MANDATORY = '!';
    var BREAK_NOT_ALLOWED = '';
    var BREAK_ALLOWED = '';
    var UnicodeTrie = createTrieFromBase64(base64);
    var ALPHABETICS = [AL, HL];
    var HARD_LINE_BREAKS = [BK, CR, LF, NL];
    var SPACE = [SP, ZW];
    var PREFIX_POSTFIX = [PR, PO];
    var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE);
    var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
    var HYPHEN = [HY, BA];
    var codePointsToCharacterClasses = function (codePoints, lineBreak) {
        if (lineBreak === void 0) { lineBreak = 'strict'; }
        var types = [];
        var indicies = [];
        var categories = [];
        codePoints.forEach(function (codePoint, index) {
            var classType = UnicodeTrie.get(codePoint);
            if (classType > LETTER_NUMBER_MODIFIER) {
                categories.push(true);
                classType -= LETTER_NUMBER_MODIFIER;
            }
            else {
                categories.push(false);
            }
            if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {
                // U+2010,  U+2013,  U+301C,  U+30A0
                if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {
                    indicies.push(index);
                    return types.push(CB);
                }
            }
            if (classType === CM || classType === ZWJ) {
                // LB10 Treat any remaining combining mark or ZWJ as AL.
                if (index === 0) {
                    indicies.push(index);
                    return types.push(AL);
                }
                // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
                // the base character in all of the following rules. Treat ZWJ as if it were CM.
                var prev = types[index - 1];
                if (LINE_BREAKS.indexOf(prev) === -1) {
                    indicies.push(indicies[index - 1]);
                    return types.push(prev);
                }
                indicies.push(index);
                return types.push(AL);
            }
            indicies.push(index);
            if (classType === CJ) {
                return types.push(lineBreak === 'strict' ? NS : ID);
            }
            if (classType === SA) {
                return types.push(AL);
            }
            if (classType === AI) {
                return types.push(AL);
            }
            // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
            // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
            // to take into account the actual line breaking properties for these characters.
            if (classType === XX) {
                if ((codePoint >= 0x20000 && codePoint <= 0x2fffd) || (codePoint >= 0x30000 && codePoint <= 0x3fffd)) {
                    return types.push(ID);
                }
                else {
                    return types.push(AL);
                }
            }
            types.push(classType);
        });
        return [indicies, types, categories];
    };
    var isAdjacentWithSpaceIgnored = function (a, b, currentIndex, classTypes) {
        var current = classTypes[currentIndex];
        if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {
            var i = currentIndex;
            while (i <= classTypes.length) {
                i++;
                var next = classTypes[i];
                if (next === b) {
                    return true;
                }
                if (next !== SP) {
                    break;
                }
            }
        }
        if (current === SP) {
            var i = currentIndex;
            while (i > 0) {
                i--;
                var prev = classTypes[i];
                if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {
                    var n = currentIndex;
                    while (n <= classTypes.length) {
                        n++;
                        var next = classTypes[n];
                        if (next === b) {
                            return true;
                        }
                        if (next !== SP) {
                            break;
                        }
                    }
                }
                if (prev !== SP) {
                    break;
                }
            }
        }
        return false;
    };
    var previousNonSpaceClassType = function (currentIndex, classTypes) {
        var i = currentIndex;
        while (i >= 0) {
            var type = classTypes[i];
            if (type === SP) {
                i--;
            }
            else {
                return type;
            }
        }
        return 0;
    };
    var _lineBreakAtIndex = function (codePoints, classTypes, indicies, index, forbiddenBreaks) {
        if (indicies[index] === 0) {
            return BREAK_NOT_ALLOWED;
        }
        var currentIndex = index - 1;
        if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
            return BREAK_NOT_ALLOWED;
        }
        var beforeIndex = currentIndex - 1;
        var afterIndex = currentIndex + 1;
        var current = classTypes[currentIndex];
        // LB4 Always break after hard line breaks.
        // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
        var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
        var next = classTypes[afterIndex];
        if (current === CR && next === LF) {
            return BREAK_NOT_ALLOWED;
        }
        if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
            return BREAK_MANDATORY;
        }
        // LB6 Do not break before hard line breaks.
        if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED;
        }
        // LB7 Do not break before spaces or zero width space.
        if (SPACE.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED;
        }
        // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
        if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
            return BREAK_ALLOWED;
        }
        // LB8a Do not break between a zero width joiner and an ideograph, emoji base or emoji modifier.
        if (UnicodeTrie.get(codePoints[currentIndex]) === ZWJ && (next === ID || next === EB || next === EM)) {
            return BREAK_NOT_ALLOWED;
        }
        // LB11 Do not break before or after Word joiner and related characters.
        if (current === WJ || next === WJ) {
            return BREAK_NOT_ALLOWED;
        }
        // LB12 Do not break after NBSP and related characters.
        if (current === GL) {
            return BREAK_NOT_ALLOWED;
        }
        // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
        if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
            return BREAK_NOT_ALLOWED;
        }
        // LB13 Do not break before ] or ! or ; or /, even after spaces.
        if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED;
        }
        // LB14 Do not break after [, even after spaces.
        if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
            return BREAK_NOT_ALLOWED;
        }
        // LB15 Do not break within [, even with intervening spaces.
        if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED;
        }
        // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
        if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED;
        }
        // LB17 Do not break within , even with intervening spaces.
        if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
            return BREAK_NOT_ALLOWED;
        }
        // LB18 Break after spaces.
        if (current === SP) {
            return BREAK_ALLOWED;
        }
        // LB19 Do not break before or after quotation marks, such as   .
        if (current === QU || next === QU) {
            return BREAK_NOT_ALLOWED;
        }
        // LB20 Break before and after unresolved CB.
        if (next === CB || current === CB) {
            return BREAK_ALLOWED;
        }
        // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
        if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
            return BREAK_NOT_ALLOWED;
        }
        // LB21a Don't break after Hebrew + Hyphen.
        if (before === HL && HYPHEN.indexOf(current) !== -1) {
            return BREAK_NOT_ALLOWED;
        }
        // LB21b Dont break between Solidus and Hebrew letters.
        if (current === SY && next === HL) {
            return BREAK_NOT_ALLOWED;
        }
        // LB22 Do not break between two ellipses, or between letters, numbers or exclamations and ellipsis.
        if (next === IN && ALPHABETICS.concat(IN, EX, NU, ID, EB, EM).indexOf(current) !== -1) {
            return BREAK_NOT_ALLOWED;
        }
        // LB23 Do not break between digits and letters.
        if ((ALPHABETICS.indexOf(next) !== -1 && current === NU) || (ALPHABETICS.indexOf(current) !== -1 && next === NU)) {
            return BREAK_NOT_ALLOWED;
        }
        // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
        if ((current === PR && [ID, EB, EM].indexOf(next) !== -1) ||
            ([ID, EB, EM].indexOf(current) !== -1 && next === PO)) {
            return BREAK_NOT_ALLOWED;
        }
        // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
        if ((ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1) ||
            (PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1)) {
            return BREAK_NOT_ALLOWED;
        }
        // LB25 Do not break between the following pairs of classes relevant to numbers:
        if (
        // (PR | PO)  ( OP | HY )? NU
        ([PR, PO].indexOf(current) !== -1 &&
            (next === NU || ([OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU))) ||
            // ( OP | HY )  NU
            ([OP, HY].indexOf(current) !== -1 && next === NU) ||
            // NU 	(NU | SY | IS)
            (current === NU && [NU, SY, IS].indexOf(next) !== -1)) {
            return BREAK_NOT_ALLOWED;
        }
        // NU (NU | SY | IS)*  (NU | SY | IS | CL | CP)
        if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
            var prevIndex = currentIndex;
            while (prevIndex >= 0) {
                var type = classTypes[prevIndex];
                if (type === NU) {
                    return BREAK_NOT_ALLOWED;
                }
                else if ([SY, IS].indexOf(type) !== -1) {
                    prevIndex--;
                }
                else {
                    break;
                }
            }
        }
        // NU (NU | SY | IS)* (CL | CP)?  (PO | PR))
        if ([PR, PO].indexOf(next) !== -1) {
            var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
            while (prevIndex >= 0) {
                var type = classTypes[prevIndex];
                if (type === NU) {
                    return BREAK_NOT_ALLOWED;
                }
                else if ([SY, IS].indexOf(type) !== -1) {
                    prevIndex--;
                }
                else {
                    break;
                }
            }
        }
        // LB26 Do not break a Korean syllable.
        if ((JL === current && [JL, JV, H2, H3].indexOf(next) !== -1) ||
            ([JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1) ||
            ([JT, H3].indexOf(current) !== -1 && next === JT)) {
            return BREAK_NOT_ALLOWED;
        }
        // LB27 Treat a Korean Syllable Block the same as ID.
        if ((KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1) ||
            (KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR)) {
            return BREAK_NOT_ALLOWED;
        }
        // LB28 Do not break between alphabetics (at).
        if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED;
        }
        // LB29 Do not break between numeric punctuation and alphabetics (e.g.).
        if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
            return BREAK_NOT_ALLOWED;
        }
        // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
        if ((ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP) ||
            (ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP)) {
            return BREAK_NOT_ALLOWED;
        }
        // LB30a Break between two regional indicator symbols if and only if there are an even number of regional
        // indicators preceding the position of the break.
        if (current === RI && next === RI) {
            var i = indicies[currentIndex];
            var count = 1;
            while (i > 0) {
                i--;
                if (classTypes[i] === RI) {
                    count++;
                }
                else {
                    break;
                }
            }
            if (count % 2 !== 0) {
                return BREAK_NOT_ALLOWED;
            }
        }
        // LB30b Do not break between an emoji base and an emoji modifier.
        if (current === EB && next === EM) {
            return BREAK_NOT_ALLOWED;
        }
        return BREAK_ALLOWED;
    };
    var cssFormattedClasses = function (codePoints, options) {
        if (!options) {
            options = { lineBreak: 'normal', wordBreak: 'normal' };
        }
        var _a = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a[0], classTypes = _a[1], isLetterNumber = _a[2];
        if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {
            classTypes = classTypes.map(function (type) { return ([NU, AL, SA].indexOf(type) !== -1 ? ID : type); });
        }
        var forbiddenBreakpoints = options.wordBreak === 'keep-all'
            ? isLetterNumber.map(function (letterNumber, i) {
                return letterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;
            })
            : undefined;
        return [indicies, classTypes, forbiddenBreakpoints];
    };
    var Break = /** @class */ (function () {
        function Break(codePoints, lineBreak, start, end) {
            this.codePoints = codePoints;
            this.required = lineBreak === BREAK_MANDATORY;
            this.start = start;
            this.end = end;
        }
        Break.prototype.slice = function () {
            return fromCodePoint.apply(void 0, this.codePoints.slice(this.start, this.end));
        };
        return Break;
    }());
    var LineBreaker = function (str, options) {
        var codePoints = toCodePoints(str);
        var _a = cssFormattedClasses(codePoints, options), indicies = _a[0], classTypes = _a[1], forbiddenBreakpoints = _a[2];
        var length = codePoints.length;
        var lastEnd = 0;
        var nextIndex = 0;
        return {
            next: function () {
                if (nextIndex >= length) {
                    return { done: true, value: null };
                }
                var lineBreak = BREAK_NOT_ALLOWED;
                while (nextIndex < length &&
                    (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) ===
                        BREAK_NOT_ALLOWED) { }
                if (lineBreak !== BREAK_NOT_ALLOWED || nextIndex === length) {
                    var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);
                    lastEnd = nextIndex;
                    return { value: value, done: false };
                }
                return { done: true, value: null };
            },
        };
    };

    // https://www.w3.org/TR/css-syntax-3
    var TokenType;
    (function (TokenType) {
        TokenType[TokenType["STRING_TOKEN"] = 0] = "STRING_TOKEN";
        TokenType[TokenType["BAD_STRING_TOKEN"] = 1] = "BAD_STRING_TOKEN";
        TokenType[TokenType["LEFT_PARENTHESIS_TOKEN"] = 2] = "LEFT_PARENTHESIS_TOKEN";
        TokenType[TokenType["RIGHT_PARENTHESIS_TOKEN"] = 3] = "RIGHT_PARENTHESIS_TOKEN";
        TokenType[TokenType["COMMA_TOKEN"] = 4] = "COMMA_TOKEN";
        TokenType[TokenType["HASH_TOKEN"] = 5] = "HASH_TOKEN";
        TokenType[TokenType["DELIM_TOKEN"] = 6] = "DELIM_TOKEN";
        TokenType[TokenType["AT_KEYWORD_TOKEN"] = 7] = "AT_KEYWORD_TOKEN";
        TokenType[TokenType["PREFIX_MATCH_TOKEN"] = 8] = "PREFIX_MATCH_TOKEN";
        TokenType[TokenType["DASH_MATCH_TOKEN"] = 9] = "DASH_MATCH_TOKEN";
        TokenType[TokenType["INCLUDE_MATCH_TOKEN"] = 10] = "INCLUDE_MATCH_TOKEN";
        TokenType[TokenType["LEFT_CURLY_BRACKET_TOKEN"] = 11] = "LEFT_CURLY_BRACKET_TOKEN";
        TokenType[TokenType["RIGHT_CURLY_BRACKET_TOKEN"] = 12] = "RIGHT_CURLY_BRACKET_TOKEN";
        TokenType[TokenType["SUFFIX_MATCH_TOKEN"] = 13] = "SUFFIX_MATCH_TOKEN";
        TokenType[TokenType["SUBSTRING_MATCH_TOKEN"] = 14] = "SUBSTRING_MATCH_TOKEN";
        TokenType[TokenType["DIMENSION_TOKEN"] = 15] = "DIMENSION_TOKEN";
        TokenType[TokenType["PERCENTAGE_TOKEN"] = 16] = "PERCENTAGE_TOKEN";
        TokenType[TokenType["NUMBER_TOKEN"] = 17] = "NUMBER_TOKEN";
        TokenType[TokenType["FUNCTION"] = 18] = "FUNCTION";
        TokenType[TokenType["FUNCTION_TOKEN"] = 19] = "FUNCTION_TOKEN";
        TokenType[TokenType["IDENT_TOKEN"] = 20] = "IDENT_TOKEN";
        TokenType[TokenType["COLUMN_TOKEN"] = 21] = "COLUMN_TOKEN";
        TokenType[TokenType["URL_TOKEN"] = 22] = "URL_TOKEN";
        TokenType[TokenType["BAD_URL_TOKEN"] = 23] = "BAD_URL_TOKEN";
        TokenType[TokenType["CDC_TOKEN"] = 24] = "CDC_TOKEN";
        TokenType[TokenType["CDO_TOKEN"] = 25] = "CDO_TOKEN";
        TokenType[TokenType["COLON_TOKEN"] = 26] = "COLON_TOKEN";
        TokenType[TokenType["SEMICOLON_TOKEN"] = 27] = "SEMICOLON_TOKEN";
        TokenType[TokenType["LEFT_SQUARE_BRACKET_TOKEN"] = 28] = "LEFT_SQUARE_BRACKET_TOKEN";
        TokenType[TokenType["RIGHT_SQUARE_BRACKET_TOKEN"] = 29] = "RIGHT_SQUARE_BRACKET_TOKEN";
        TokenType[TokenType["UNICODE_RANGE_TOKEN"] = 30] = "UNICODE_RANGE_TOKEN";
        TokenType[TokenType["WHITESPACE_TOKEN"] = 31] = "WHITESPACE_TOKEN";
        TokenType[TokenType["EOF_TOKEN"] = 32] = "EOF_TOKEN";
    })(TokenType || (TokenType = {}));
    var FLAG_UNRESTRICTED = 1 << 0;
    var FLAG_ID = 1 << 1;
    var FLAG_INTEGER = 1 << 2;
    var FLAG_NUMBER = 1 << 3;
    var LINE_FEED = 0x000a;
    var SOLIDUS = 0x002f;
    var REVERSE_SOLIDUS = 0x005c;
    var CHARACTER_TABULATION = 0x0009;
    var SPACE$1 = 0x0020;
    var QUOTATION_MARK = 0x0022;
    var EQUALS_SIGN = 0x003d;
    var NUMBER_SIGN = 0x0023;
    var DOLLAR_SIGN = 0x0024;
    var PERCENTAGE_SIGN = 0x0025;
    var APOSTROPHE = 0x0027;
    var LEFT_PARENTHESIS = 0x0028;
    var RIGHT_PARENTHESIS = 0x0029;
    var LOW_LINE = 0x005f;
    var HYPHEN_MINUS = 0x002d;
    var EXCLAMATION_MARK = 0x0021;
    var LESS_THAN_SIGN = 0x003c;
    var GREATER_THAN_SIGN = 0x003e;
    var COMMERCIAL_AT = 0x0040;
    var LEFT_SQUARE_BRACKET = 0x005b;
    var RIGHT_SQUARE_BRACKET = 0x005d;
    var CIRCUMFLEX_ACCENT = 0x003d;
    var LEFT_CURLY_BRACKET = 0x007b;
    var QUESTION_MARK = 0x003f;
    var RIGHT_CURLY_BRACKET = 0x007d;
    var VERTICAL_LINE = 0x007c;
    var TILDE = 0x007e;
    var CONTROL = 0x0080;
    var REPLACEMENT_CHARACTER = 0xfffd;
    var ASTERISK = 0x002a;
    var PLUS_SIGN = 0x002b;
    var COMMA = 0x002c;
    var COLON = 0x003a;
    var SEMICOLON = 0x003b;
    var FULL_STOP = 0x002e;
    var NULL = 0x0000;
    var BACKSPACE = 0x0008;
    var LINE_TABULATION = 0x000b;
    var SHIFT_OUT = 0x000e;
    var INFORMATION_SEPARATOR_ONE = 0x001f;
    var DELETE = 0x007f;
    var EOF = -1;
    var ZERO = 0x0030;
    var a = 0x0061;
    var e = 0x0065;
    var f = 0x0066;
    var u = 0x0075;
    var z = 0x007a;
    var A = 0x0041;
    var E = 0x0045;
    var F = 0x0046;
    var U = 0x0055;
    var Z = 0x005a;
    var isDigit = function (codePoint) { return codePoint >= ZERO && codePoint <= 0x0039; };
    var isSurrogateCodePoint = function (codePoint) { return codePoint >= 0xd800 && codePoint <= 0xdfff; };
    var isHex = function (codePoint) {
        return isDigit(codePoint) || (codePoint >= A && codePoint <= F) || (codePoint >= a && codePoint <= f);
    };
    var isLowerCaseLetter = function (codePoint) { return codePoint >= a && codePoint <= z; };
    var isUpperCaseLetter = function (codePoint) { return codePoint >= A && codePoint <= Z; };
    var isLetter = function (codePoint) { return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint); };
    var isNonASCIICodePoint = function (codePoint) { return codePoint >= CONTROL; };
    var isWhiteSpace = function (codePoint) {
        return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE$1;
    };
    var isNameStartCodePoint = function (codePoint) {
        return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
    };
    var isNameCodePoint = function (codePoint) {
        return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
    };
    var isNonPrintableCodePoint = function (codePoint) {
        return ((codePoint >= NULL && codePoint <= BACKSPACE) ||
            codePoint === LINE_TABULATION ||
            (codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE) ||
            codePoint === DELETE);
    };
    var isValidEscape = function (c1, c2) {
        if (c1 !== REVERSE_SOLIDUS) {
            return false;
        }
        return c2 !== LINE_FEED;
    };
    var isIdentifierStart = function (c1, c2, c3) {
        if (c1 === HYPHEN_MINUS) {
            return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
        }
        else if (isNameStartCodePoint(c1)) {
            return true;
        }
        else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
            return true;
        }
        return false;
    };
    var isNumberStart = function (c1, c2, c3) {
        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
            if (isDigit(c2)) {
                return true;
            }
            return c2 === FULL_STOP && isDigit(c3);
        }
        if (c1 === FULL_STOP) {
            return isDigit(c2);
        }
        return isDigit(c1);
    };
    var stringToNumber = function (codePoints) {
        var c = 0;
        var sign = 1;
        if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
            if (codePoints[c] === HYPHEN_MINUS) {
                sign = -1;
            }
            c++;
        }
        var integers = [];
        while (isDigit(codePoints[c])) {
            integers.push(codePoints[c++]);
        }
        var int = integers.length ? parseInt(fromCodePoint.apply(void 0, integers), 10) : 0;
        if (codePoints[c] === FULL_STOP) {
            c++;
        }
        var fraction = [];
        while (isDigit(codePoints[c])) {
            fraction.push(codePoints[c++]);
        }
        var fracd = fraction.length;
        var frac = fracd ? parseInt(fromCodePoint.apply(void 0, fraction), 10) : 0;
        if (codePoints[c] === E || codePoints[c] === e) {
            c++;
        }
        var expsign = 1;
        if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
            if (codePoints[c] === HYPHEN_MINUS) {
                expsign = -1;
            }
            c++;
        }
        var exponent = [];
        while (isDigit(codePoints[c])) {
            exponent.push(codePoints[c++]);
        }
        var exp = exponent.length ? parseInt(fromCodePoint.apply(void 0, exponent), 10) : 0;
        return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
    };
    var LEFT_PARENTHESIS_TOKEN = {
        type: TokenType.LEFT_PARENTHESIS_TOKEN
    };
    var RIGHT_PARENTHESIS_TOKEN = {
        type: TokenType.RIGHT_PARENTHESIS_TOKEN
    };
    var COMMA_TOKEN = { type: TokenType.COMMA_TOKEN };
    var SUFFIX_MATCH_TOKEN = { type: TokenType.SUFFIX_MATCH_TOKEN };
    var PREFIX_MATCH_TOKEN = { type: TokenType.PREFIX_MATCH_TOKEN };
    var COLUMN_TOKEN = { type: TokenType.COLUMN_TOKEN };
    var DASH_MATCH_TOKEN = { type: TokenType.DASH_MATCH_TOKEN };
    var INCLUDE_MATCH_TOKEN = { type: TokenType.INCLUDE_MATCH_TOKEN };
    var LEFT_CURLY_BRACKET_TOKEN = {
        type: TokenType.LEFT_CURLY_BRACKET_TOKEN
    };
    var RIGHT_CURLY_BRACKET_TOKEN = {
        type: TokenType.RIGHT_CURLY_BRACKET_TOKEN
    };
    var SUBSTRING_MATCH_TOKEN = { type: TokenType.SUBSTRING_MATCH_TOKEN };
    var BAD_URL_TOKEN = { type: TokenType.BAD_URL_TOKEN };
    var BAD_STRING_TOKEN = { type: TokenType.BAD_STRING_TOKEN };
    var CDO_TOKEN = { type: TokenType.CDO_TOKEN };
    var CDC_TOKEN = { type: TokenType.CDC_TOKEN };
    var COLON_TOKEN = { type: TokenType.COLON_TOKEN };
    var SEMICOLON_TOKEN = { type: TokenType.SEMICOLON_TOKEN };
    var LEFT_SQUARE_BRACKET_TOKEN = {
        type: TokenType.LEFT_SQUARE_BRACKET_TOKEN
    };
    var RIGHT_SQUARE_BRACKET_TOKEN = {
        type: TokenType.RIGHT_SQUARE_BRACKET_TOKEN
    };
    var WHITESPACE_TOKEN = { type: TokenType.WHITESPACE_TOKEN };
    var EOF_TOKEN = { type: TokenType.EOF_TOKEN };
    var Tokenizer = /** @class */ (function () {
        function Tokenizer() {
            this._value = [];
        }
        Tokenizer.prototype.write = function (chunk) {
            this._value = this._value.concat(toCodePoints(chunk));
        };
        Tokenizer.prototype.read = function () {
            var tokens = [];
            var token = this.consumeToken();
            while (token !== EOF_TOKEN) {
                tokens.push(token);
                token = this.consumeToken();
            }
            return tokens;
        };
        Tokenizer.prototype.consumeToken = function () {
            var codePoint = this.consumeCodePoint();
            switch (codePoint) {
                case QUOTATION_MARK:
                    return this.consumeStringToken(QUOTATION_MARK);
                case NUMBER_SIGN:
                    var c1 = this.peekCodePoint(0);
                    var c2 = this.peekCodePoint(1);
                    var c3 = this.peekCodePoint(2);
                    if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
                        var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
                        var value = this.consumeName();
                        return { type: TokenType.HASH_TOKEN, value: value, flags: flags };
                    }
                    break;
                case DOLLAR_SIGN:
                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
                        this.consumeCodePoint();
                        return SUFFIX_MATCH_TOKEN;
                    }
                    break;
                case APOSTROPHE:
                    return this.consumeStringToken(APOSTROPHE);
                case LEFT_PARENTHESIS:
                    return LEFT_PARENTHESIS_TOKEN;
                case RIGHT_PARENTHESIS:
                    return RIGHT_PARENTHESIS_TOKEN;
                case ASTERISK:
                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
                        this.consumeCodePoint();
                        return SUBSTRING_MATCH_TOKEN;
                    }
                    break;
                case PLUS_SIGN:
                    if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                        this.reconsumeCodePoint(codePoint);
                        return this.consumeNumericToken();
                    }
                    break;
                case COMMA:
                    return COMMA_TOKEN;
                case HYPHEN_MINUS:
                    var e1 = codePoint;
                    var e2 = this.peekCodePoint(0);
                    var e3 = this.peekCodePoint(1);
                    if (isNumberStart(e1, e2, e3)) {
                        this.reconsumeCodePoint(codePoint);
                        return this.consumeNumericToken();
                    }
                    if (isIdentifierStart(e1, e2, e3)) {
                        this.reconsumeCodePoint(codePoint);
                        return this.consumeIdentLikeToken();
                    }
                    if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
                        this.consumeCodePoint();
                        this.consumeCodePoint();
                        return CDC_TOKEN;
                    }
                    break;
                case FULL_STOP:
                    if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
                        this.reconsumeCodePoint(codePoint);
                        return this.consumeNumericToken();
                    }
                    break;
                case SOLIDUS:
                    if (this.peekCodePoint(0) === ASTERISK) {
                        this.consumeCodePoint();
                        while (true) {
                            var c = this.consumeCodePoint();
                            if (c === ASTERISK) {
                                c = this.consumeCodePoint();
                                if (c === SOLIDUS) {
                                    return this.consumeToken();
                                }
                            }
                            if (c === EOF) {
                                return this.consumeToken();
                            }
                        }
                    }
                    break;
                case COLON:
                    return COLON_TOKEN;
                case SEMICOLON:
                    return SEMICOLON_TOKEN;
                case LESS_THAN_SIGN:
                    if (this.peekCodePoint(0) === EXCLAMATION_MARK &&
                        this.peekCodePoint(1) === HYPHEN_MINUS &&
                        this.peekCodePoint(2) === HYPHEN_MINUS) {
                        this.consumeCodePoint();
                        this.consumeCodePoint();
                        return CDO_TOKEN;
                    }
                    break;
                case COMMERCIAL_AT:
                    var a1 = this.peekCodePoint(0);
                    var a2 = this.peekCodePoint(1);
                    var a3 = this.peekCodePoint(2);
                    if (isIdentifierStart(a1, a2, a3)) {
                        var value = this.consumeName();
                        return { type: TokenType.AT_KEYWORD_TOKEN, value: value };
                    }
                    break;
                case LEFT_SQUARE_BRACKET:
                    return LEFT_SQUARE_BRACKET_TOKEN;
                case REVERSE_SOLIDUS:
                    if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                        this.reconsumeCodePoint(codePoint);
                        return this.consumeIdentLikeToken();
                    }
                    break;
                case RIGHT_SQUARE_BRACKET:
                    return RIGHT_SQUARE_BRACKET_TOKEN;
                case CIRCUMFLEX_ACCENT:
                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
                        this.consumeCodePoint();
                        return PREFIX_MATCH_TOKEN;
                    }
                    break;
                case LEFT_CURLY_BRACKET:
                    return LEFT_CURLY_BRACKET_TOKEN;
                case RIGHT_CURLY_BRACKET:
                    return RIGHT_CURLY_BRACKET_TOKEN;
                case u:
                case U:
                    var u1 = this.peekCodePoint(0);
                    var u2 = this.peekCodePoint(1);
                    if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
                        this.consumeCodePoint();
                        this.consumeUnicodeRangeToken();
                    }
                    this.reconsumeCodePoint(codePoint);
                    return this.consumeIdentLikeToken();
                case VERTICAL_LINE:
                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
                        this.consumeCodePoint();
                        return DASH_MATCH_TOKEN;
                    }
                    if (this.peekCodePoint(0) === VERTICAL_LINE) {
                        this.consumeCodePoint();
                        return COLUMN_TOKEN;
                    }
                    break;
                case TILDE:
                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
                        this.consumeCodePoint();
                        return INCLUDE_MATCH_TOKEN;
                    }
                    break;
                case EOF:
                    return EOF_TOKEN;
            }
            if (isWhiteSpace(codePoint)) {
                this.consumeWhiteSpace();
                return WHITESPACE_TOKEN;
            }
            if (isDigit(codePoint)) {
                this.reconsumeCodePoint(codePoint);
                return this.consumeNumericToken();
            }
            if (isNameStartCodePoint(codePoint)) {
                this.reconsumeCodePoint(codePoint);
                return this.consumeIdentLikeToken();
            }
            return { type: TokenType.DELIM_TOKEN, value: fromCodePoint(codePoint) };
        };
        Tokenizer.prototype.consumeCodePoint = function () {
            var value = this._value.shift();
            return typeof value === 'undefined' ? -1 : value;
        };
        Tokenizer.prototype.reconsumeCodePoint = function (codePoint) {
            this._value.unshift(codePoint);
        };
        Tokenizer.prototype.peekCodePoint = function (delta) {
            if (delta >= this._value.length) {
                return -1;
            }
            return this._value[delta];
        };
        Tokenizer.prototype.consumeUnicodeRangeToken = function () {
            var digits = [];
            var codePoint = this.consumeCodePoint();
            while (isHex(codePoint) && digits.length < 6) {
                digits.push(codePoint);
                codePoint = this.consumeCodePoint();
            }
            var questionMarks = false;
            while (codePoint === QUESTION_MARK && digits.length < 6) {
                digits.push(codePoint);
                codePoint = this.consumeCodePoint();
                questionMarks = true;
            }
            if (questionMarks) {
                var start_1 = parseInt(fromCodePoint.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? ZERO : digit); })), 16);
                var end = parseInt(fromCodePoint.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? F : digit); })), 16);
                return { type: TokenType.UNICODE_RANGE_TOKEN, start: start_1, end: end };
            }
            var start = parseInt(fromCodePoint.apply(void 0, digits), 16);
            if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
                this.consumeCodePoint();
                codePoint = this.consumeCodePoint();
                var endDigits = [];
                while (isHex(codePoint) && endDigits.length < 6) {
                    endDigits.push(codePoint);
                    codePoint = this.consumeCodePoint();
                }
                var end = parseInt(fromCodePoint.apply(void 0, endDigits), 16);
                return { type: TokenType.UNICODE_RANGE_TOKEN, start: start, end: end };
            }
            else {
                return { type: TokenType.UNICODE_RANGE_TOKEN, start: start, end: start };
            }
        };
        Tokenizer.prototype.consumeIdentLikeToken = function () {
            var value = this.consumeName();
            if (value.toLowerCase() === 'url' && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
                this.consumeCodePoint();
                return this.consumeUrlToken();
            }
            else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
                this.consumeCodePoint();
                return { type: TokenType.FUNCTION_TOKEN, value: value };
            }
            return { type: TokenType.IDENT_TOKEN, value: value };
        };
        Tokenizer.prototype.consumeUrlToken = function () {
            var value = [];
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF) {
                return { type: TokenType.URL_TOKEN, value: '' };
            }
            var next = this.peekCodePoint(0);
            if (next === APOSTROPHE || next === QUOTATION_MARK) {
                var stringToken = this.consumeStringToken(this.consumeCodePoint());
                if (stringToken.type === TokenType.STRING_TOKEN) {
                    this.consumeWhiteSpace();
                    if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                        this.consumeCodePoint();
                        return { type: TokenType.URL_TOKEN, value: stringToken.value };
                    }
                }
                this.consumeBadUrlRemnants();
                return BAD_URL_TOKEN;
            }
            while (true) {
                var codePoint = this.consumeCodePoint();
                if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
                    return { type: TokenType.URL_TOKEN, value: fromCodePoint.apply(void 0, value) };
                }
                else if (isWhiteSpace(codePoint)) {
                    this.consumeWhiteSpace();
                    if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
                        this.consumeCodePoint();
                        return { type: TokenType.URL_TOKEN, value: fromCodePoint.apply(void 0, value) };
                    }
                    this.consumeBadUrlRemnants();
                    return BAD_URL_TOKEN;
                }
                else if (codePoint === QUOTATION_MARK ||
                    codePoint === APOSTROPHE ||
                    codePoint === LEFT_PARENTHESIS ||
                    isNonPrintableCodePoint(codePoint)) {
                    this.consumeBadUrlRemnants();
                    return BAD_URL_TOKEN;
                }
                else if (codePoint === REVERSE_SOLIDUS) {
                    if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                        value.push(this.consumeEscapedCodePoint());
                    }
                    else {
                        this.consumeBadUrlRemnants();
                        return BAD_URL_TOKEN;
                    }
                }
                else {
                    value.push(codePoint);
                }
            }
        };
        Tokenizer.prototype.consumeWhiteSpace = function () {
            while (isWhiteSpace(this.peekCodePoint(0))) {
                this.consumeCodePoint();
            }
        };
        Tokenizer.prototype.consumeBadUrlRemnants = function () {
            while (true) {
                var codePoint = this.consumeCodePoint();
                if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
                    return;
                }
                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                    this.consumeEscapedCodePoint();
                }
            }
        };
        Tokenizer.prototype.consumeStringSlice = function (count) {
            var SLICE_STACK_SIZE = 60000;
            var value = '';
            while (count > 0) {
                var amount = Math.min(SLICE_STACK_SIZE, count);
                value += fromCodePoint.apply(void 0, this._value.splice(0, amount));
                count -= amount;
            }
            this._value.shift();
            return value;
        };
        Tokenizer.prototype.consumeStringToken = function (endingCodePoint) {
            var value = '';
            var i = 0;
            do {
                var codePoint = this._value[i];
                if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {
                    value += this.consumeStringSlice(i);
                    return { type: TokenType.STRING_TOKEN, value: value };
                }
                if (codePoint === LINE_FEED) {
                    this._value.splice(0, i);
                    return BAD_STRING_TOKEN;
                }
                if (codePoint === REVERSE_SOLIDUS) {
                    var next = this._value[i + 1];
                    if (next !== EOF && next !== undefined) {
                        if (next === LINE_FEED) {
                            value += this.consumeStringSlice(i);
                            i = -1;
                            this._value.shift();
                        }
                        else if (isValidEscape(codePoint, next)) {
                            value += this.consumeStringSlice(i);
                            value += fromCodePoint(this.consumeEscapedCodePoint());
                            i = -1;
                        }
                    }
                }
                i++;
            } while (true);
        };
        Tokenizer.prototype.consumeNumber = function () {
            var repr = [];
            var type = FLAG_INTEGER;
            var c1 = this.peekCodePoint(0);
            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
                repr.push(this.consumeCodePoint());
            }
            while (isDigit(this.peekCodePoint(0))) {
                repr.push(this.consumeCodePoint());
            }
            c1 = this.peekCodePoint(0);
            var c2 = this.peekCodePoint(1);
            if (c1 === FULL_STOP && isDigit(c2)) {
                repr.push(this.consumeCodePoint(), this.consumeCodePoint());
                type = FLAG_NUMBER;
                while (isDigit(this.peekCodePoint(0))) {
                    repr.push(this.consumeCodePoint());
                }
            }
            c1 = this.peekCodePoint(0);
            c2 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if ((c1 === E || c1 === e) && (((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3)) || isDigit(c2))) {
                repr.push(this.consumeCodePoint(), this.consumeCodePoint());
                type = FLAG_NUMBER;
                while (isDigit(this.peekCodePoint(0))) {
                    repr.push(this.consumeCodePoint());
                }
            }
            return [stringToNumber(repr), type];
        };
        Tokenizer.prototype.consumeNumericToken = function () {
            var _a = this.consumeNumber(), number = _a[0], flags = _a[1];
            var c1 = this.peekCodePoint(0);
            var c2 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if (isIdentifierStart(c1, c2, c3)) {
                var unit = this.consumeName();
                return { type: TokenType.DIMENSION_TOKEN, number: number, flags: flags, unit: unit };
            }
            if (c1 === PERCENTAGE_SIGN) {
                this.consumeCodePoint();
                return { type: TokenType.PERCENTAGE_TOKEN, number: number, flags: flags };
            }
            return { type: TokenType.NUMBER_TOKEN, number: number, flags: flags };
        };
        Tokenizer.prototype.consumeEscapedCodePoint = function () {
            var codePoint = this.consumeCodePoint();
            if (isHex(codePoint)) {
                var hex = fromCodePoint(codePoint);
                while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
                    hex += fromCodePoint(this.consumeCodePoint());
                }
                if (isWhiteSpace(this.peekCodePoint(0))) {
                    this.consumeCodePoint();
                }
                var hexCodePoint = parseInt(hex, 16);
                if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 0x10ffff) {
                    return REPLACEMENT_CHARACTER;
                }
                return hexCodePoint;
            }
            if (codePoint === EOF) {
                return REPLACEMENT_CHARACTER;
            }
            return codePoint;
        };
        Tokenizer.prototype.consumeName = function () {
            var result = '';
            while (true) {
                var codePoint = this.consumeCodePoint();
                if (isNameCodePoint(codePoint)) {
                    result += fromCodePoint(codePoint);
                }
                else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
                    result += fromCodePoint(this.consumeEscapedCodePoint());
                }
                else {
                    this.reconsumeCodePoint(codePoint);
                    return result;
                }
            }
        };
        return Tokenizer;
    }());

    var Parser = /** @class */ (function () {
        function Parser(tokens) {
            this._tokens = tokens;
        }
        Parser.create = function (value) {
            var tokenizer = new Tokenizer();
            tokenizer.write(value);
            return new Parser(tokenizer.read());
        };
        Parser.parseValue = function (value) {
            return Parser.create(value).parseComponentValue();
        };
        Parser.parseValues = function (value) {
            return Parser.create(value).parseComponentValues();
        };
        Parser.prototype.parseComponentValue = function () {
            var token = this.consumeToken();
            while (token.type === TokenType.WHITESPACE_TOKEN) {
                token = this.consumeToken();
            }
            if (token.type === TokenType.EOF_TOKEN) {
                throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
            }
            this.reconsumeToken(token);
            var value = this.consumeComponentValue();
            do {
                token = this.consumeToken();
            } while (token.type === TokenType.WHITESPACE_TOKEN);
            if (token.type === TokenType.EOF_TOKEN) {
                return value;
            }
            throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
        };
        Parser.prototype.parseComponentValues = function () {
            var values = [];
            while (true) {
                var value = this.consumeComponentValue();
                if (value.type === TokenType.EOF_TOKEN) {
                    return values;
                }
                values.push(value);
                values.push();
            }
        };
        Parser.prototype.consumeComponentValue = function () {
            var token = this.consumeToken();
            switch (token.type) {
                case TokenType.LEFT_CURLY_BRACKET_TOKEN:
                case TokenType.LEFT_SQUARE_BRACKET_TOKEN:
                case TokenType.LEFT_PARENTHESIS_TOKEN:
                    return this.consumeSimpleBlock(token.type);
                case TokenType.FUNCTION_TOKEN:
                    return this.consumeFunction(token);
            }
            return token;
        };
        Parser.prototype.consumeSimpleBlock = function (type) {
            var block = { type: type, values: [] };
            var token = this.consumeToken();
            while (true) {
                if (token.type === TokenType.EOF_TOKEN || isEndingTokenFor(token, type)) {
                    return block;
                }
                this.reconsumeToken(token);
                block.values.push(this.consumeComponentValue());
                token = this.consumeToken();
            }
        };
        Parser.prototype.consumeFunction = function (functionToken) {
            var cssFunction = {
                name: functionToken.value,
                values: [],
                type: TokenType.FUNCTION
            };
            while (true) {
                var token = this.consumeToken();
                if (token.type === TokenType.EOF_TOKEN || token.type === TokenType.RIGHT_PARENTHESIS_TOKEN) {
                    return cssFunction;
                }
                this.reconsumeToken(token);
                cssFunction.values.push(this.consumeComponentValue());
            }
        };
        Parser.prototype.consumeToken = function () {
            var token = this._tokens.shift();
            return typeof token === 'undefined' ? EOF_TOKEN : token;
        };
        Parser.prototype.reconsumeToken = function (token) {
            this._tokens.unshift(token);
        };
        return Parser;
    }());
    var isDimensionToken = function (token) { return token.type === TokenType.DIMENSION_TOKEN; };
    var isNumberToken = function (token) { return token.type === TokenType.NUMBER_TOKEN; };
    var isIdentToken = function (token) { return token.type === TokenType.IDENT_TOKEN; };
    var isStringToken = function (token) { return token.type === TokenType.STRING_TOKEN; };
    var isIdentWithValue = function (token, value) {
        return isIdentToken(token) && token.value === value;
    };
    var nonWhiteSpace = function (token) { return token.type !== TokenType.WHITESPACE_TOKEN; };
    var nonFunctionArgSeperator = function (token) {
        return token.type !== TokenType.WHITESPACE_TOKEN && token.type !== TokenType.COMMA_TOKEN;
    };
    var parseFunctionArgs = function (tokens) {
        var args = [];
        var arg = [];
        tokens.forEach(function (token) {
            if (token.type === TokenType.COMMA_TOKEN) {
                if (arg.length === 0) {
                    throw new Error("Error parsing function args, zero tokens for arg");
                }
                args.push(arg);
                arg = [];
                return;
            }
            if (token.type !== TokenType.WHITESPACE_TOKEN) {
                arg.push(token);
            }
        });
        if (arg.length) {
            args.push(arg);
        }
        return args;
    };
    var isEndingTokenFor = function (token, type) {
        if (type === TokenType.LEFT_CURLY_BRACKET_TOKEN && token.type === TokenType.RIGHT_CURLY_BRACKET_TOKEN) {
            return true;
        }
        if (type === TokenType.LEFT_SQUARE_BRACKET_TOKEN && token.type === TokenType.RIGHT_SQUARE_BRACKET_TOKEN) {
            return true;
        }
        return type === TokenType.LEFT_PARENTHESIS_TOKEN && token.type === TokenType.RIGHT_PARENTHESIS_TOKEN;
    };

    var isLength = function (token) {
        return token.type === TokenType.NUMBER_TOKEN || token.type === TokenType.DIMENSION_TOKEN;
    };

    var isLengthPercentage = function (token) {
        return token.type === TokenType.PERCENTAGE_TOKEN || isLength(token);
    };
    var parseLengthPercentageTuple = function (tokens) {
        return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
    };
    var ZERO_LENGTH = {
        type: TokenType.NUMBER_TOKEN,
        number: 0,
        flags: FLAG_INTEGER
    };
    var FIFTY_PERCENT = {
        type: TokenType.PERCENTAGE_TOKEN,
        number: 50,
        flags: FLAG_INTEGER
    };
    var HUNDRED_PERCENT = {
        type: TokenType.PERCENTAGE_TOKEN,
        number: 100,
        flags: FLAG_INTEGER
    };
    var getAbsoluteValueForTuple = function (tuple, width, height) {
        var x = tuple[0], y = tuple[1];
        return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== 'undefined' ? y : x, height)];
    };
    var getAbsoluteValue = function (token, parent) {
        if (token.type === TokenType.PERCENTAGE_TOKEN) {
            return (token.number / 100) * parent;
        }
        if (isDimensionToken(token)) {
            switch (token.unit) {
                case 'rem':
                case 'em':
                    return 16 * token.number; // TODO use correct font-size
                case 'px':
                default:
                    return token.number;
            }
        }
        return token.number;
    };

    var DEG = 'deg';
    var GRAD = 'grad';
    var RAD = 'rad';
    var TURN = 'turn';
    var angle = {
        name: 'angle',
        parse: function (value) {
            if (value.type === TokenType.DIMENSION_TOKEN) {
                switch (value.unit) {
                    case DEG:
                        return (Math.PI * value.number) / 180;
                    case GRAD:
                        return (Math.PI / 200) * value.number;
                    case RAD:
                        return value.number;
                    case TURN:
                        return Math.PI * 2 * value.number;
                }
            }
            throw new Error("Unsupported angle type");
        }
    };
    var isAngle = function (value) {
        if (value.type === TokenType.DIMENSION_TOKEN) {
            if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
                return true;
            }
        }
        return false;
    };
    var parseNamedSide = function (tokens) {
        var sideOrCorner = tokens
            .filter(isIdentToken)
            .map(function (ident) { return ident.value; })
            .join(' ');
        switch (sideOrCorner) {
            case 'to bottom right':
            case 'to right bottom':
            case 'left top':
            case 'top left':
                return [ZERO_LENGTH, ZERO_LENGTH];
            case 'to top':
            case 'bottom':
                return deg(0);
            case 'to bottom left':
            case 'to left bottom':
            case 'right top':
            case 'top right':
                return [ZERO_LENGTH, HUNDRED_PERCENT];
            case 'to right':
            case 'left':
                return deg(90);
            case 'to top left':
            case 'to left top':
            case 'right bottom':
            case 'bottom right':
                return [HUNDRED_PERCENT, HUNDRED_PERCENT];
            case 'to bottom':
            case 'top':
                return deg(180);
            case 'to top right':
            case 'to right top':
            case 'left bottom':
            case 'bottom left':
                return [HUNDRED_PERCENT, ZERO_LENGTH];
            case 'to left':
            case 'right':
                return deg(270);
        }
        return 0;
    };
    var deg = function (deg) { return (Math.PI * deg) / 180; };

    var color = {
        name: 'color',
        parse: function (value) {
            if (value.type === TokenType.FUNCTION) {
                var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
                if (typeof colorFunction === 'undefined') {
                    throw new Error("Attempting to parse an unsupported color function \"" + value.name + "\"");
                }
                return colorFunction(value.values);
            }
            if (value.type === TokenType.HASH_TOKEN) {
                if (value.value.length === 3) {
                    var r = value.value.substring(0, 1);
                    var g = value.value.substring(1, 2);
                    var b = value.value.substring(2, 3);
                    return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
                }
                if (value.value.length === 4) {
                    var r = value.value.substring(0, 1);
                    var g = value.value.substring(1, 2);
                    var b = value.value.substring(2, 3);
                    var a = value.value.substring(3, 4);
                    return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a + a, 16) / 255);
                }
                if (value.value.length === 6) {
                    var r = value.value.substring(0, 2);
                    var g = value.value.substring(2, 4);
                    var b = value.value.substring(4, 6);
                    return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
                }
                if (value.value.length === 8) {
                    var r = value.value.substring(0, 2);
                    var g = value.value.substring(2, 4);
                    var b = value.value.substring(4, 6);
                    var a = value.value.substring(6, 8);
                    return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a, 16) / 255);
                }
            }
            if (value.type === TokenType.IDENT_TOKEN) {
                var namedColor = COLORS[value.value.toUpperCase()];
                if (typeof namedColor !== 'undefined') {
                    return namedColor;
                }
            }
            return COLORS.TRANSPARENT;
        }
    };
    var isTransparent = function (color) { return (0xff & color) === 0; };
    var asString = function (color) {
        var alpha = 0xff & color;
        var blue = 0xff & (color >> 8);
        var green = 0xff & (color >> 16);
        var red = 0xff & (color >> 24);
        return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
    };
    var pack = function (r, g, b, a) {
        return ((r << 24) | (g << 16) | (b << 8) | (Math.round(a * 255) << 0)) >>> 0;
    };
    var getTokenColorValue = function (token, i) {
        if (token.type === TokenType.NUMBER_TOKEN) {
            return token.number;
        }
        if (token.type === TokenType.PERCENTAGE_TOKEN) {
            var max = i === 3 ? 1 : 255;
            return i === 3 ? (token.number / 100) * max : Math.round((token.number / 100) * max);
        }
        return 0;
    };
    var rgb = function (args) {
        var tokens = args.filter(nonFunctionArgSeperator);
        if (tokens.length === 3) {
            var _a = tokens.map(getTokenColorValue), r = _a[0], g = _a[1], b = _a[2];
            return pack(r, g, b, 1);
        }
        if (tokens.length === 4) {
            var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a = _b[3];
            return pack(r, g, b, a);
        }
        return 0;
    };
    function hue2rgb(t1, t2, hue) {
        if (hue < 0) {
            hue += 1;
        }
        if (hue >= 1) {
            hue -= 1;
        }
        if (hue < 1 / 6) {
            return (t2 - t1) * hue * 6 + t1;
        }
        else if (hue < 1 / 2) {
            return t2;
        }
        else if (hue < 2 / 3) {
            return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
        }
        else {
            return t1;
        }
    }
    var hsl = function (args) {
        var tokens = args.filter(nonFunctionArgSeperator);
        var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
        var h = (hue.type === TokenType.NUMBER_TOKEN ? deg(hue.number) : angle.parse(hue)) / (Math.PI * 2);
        var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
        var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
        var a = typeof alpha !== 'undefined' && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
        if (s === 0) {
            return pack(l * 255, l * 255, l * 255, 1);
        }
        var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        var t1 = l * 2 - t2;
        var r = hue2rgb(t1, t2, h + 1 / 3);
        var g = hue2rgb(t1, t2, h);
        var b = hue2rgb(t1, t2, h - 1 / 3);
        return pack(r * 255, g * 255, b * 255, a);
    };
    var SUPPORTED_COLOR_FUNCTIONS = {
        hsl: hsl,
        hsla: hsl,
        rgb: rgb,
        rgba: rgb
    };
    var COLORS = {
        ALICEBLUE: 0xf0f8ffff,
        ANTIQUEWHITE: 0xfaebd7ff,
        AQUA: 0x00ffffff,
        AQUAMARINE: 0x7fffd4ff,
        AZURE: 0xf0ffffff,
        BEIGE: 0xf5f5dcff,
        BISQUE: 0xffe4c4ff,
        BLACK: 0x000000ff,
        BLANCHEDALMOND: 0xffebcdff,
        BLUE: 0x0000ffff,
        BLUEVIOLET: 0x8a2be2ff,
        BROWN: 0xa52a2aff,
        BURLYWOOD: 0xdeb887ff,
        CADETBLUE: 0x5f9ea0ff,
        CHARTREUSE: 0x7fff00ff,
        CHOCOLATE: 0xd2691eff,
        CORAL: 0xff7f50ff,
        CORNFLOWERBLUE: 0x6495edff,
        CORNSILK: 0xfff8dcff,
        CRIMSON: 0xdc143cff,
        CYAN: 0x00ffffff,
        DARKBLUE: 0x00008bff,
        DARKCYAN: 0x008b8bff,
        DARKGOLDENROD: 0xb886bbff,
        DARKGRAY: 0xa9a9a9ff,
        DARKGREEN: 0x006400ff,
        DARKGREY: 0xa9a9a9ff,
        DARKKHAKI: 0xbdb76bff,
        DARKMAGENTA: 0x8b008bff,
        DARKOLIVEGREEN: 0x556b2fff,
        DARKORANGE: 0xff8c00ff,
        DARKORCHID: 0x9932ccff,
        DARKRED: 0x8b0000ff,
        DARKSALMON: 0xe9967aff,
        DARKSEAGREEN: 0x8fbc8fff,
        DARKSLATEBLUE: 0x483d8bff,
        DARKSLATEGRAY: 0x2f4f4fff,
        DARKSLATEGREY: 0x2f4f4fff,
        DARKTURQUOISE: 0x00ced1ff,
        DARKVIOLET: 0x9400d3ff,
        DEEPPINK: 0xff1493ff,
        DEEPSKYBLUE: 0x00bfffff,
        DIMGRAY: 0x696969ff,
        DIMGREY: 0x696969ff,
        DODGERBLUE: 0x1e90ffff,
        FIREBRICK: 0xb22222ff,
        FLORALWHITE: 0xfffaf0ff,
        FORESTGREEN: 0x228b22ff,
        FUCHSIA: 0xff00ffff,
        GAINSBORO: 0xdcdcdcff,
        GHOSTWHITE: 0xf8f8ffff,
        GOLD: 0xffd700ff,
        GOLDENROD: 0xdaa520ff,
        GRAY: 0x808080ff,
        GREEN: 0x008000ff,
        GREENYELLOW: 0xadff2fff,
        GREY: 0x808080ff,
        HONEYDEW: 0xf0fff0ff,
        HOTPINK: 0xff69b4ff,
        INDIANRED: 0xcd5c5cff,
        INDIGO: 0x4b0082ff,
        IVORY: 0xfffff0ff,
        KHAKI: 0xf0e68cff,
        LAVENDER: 0xe6e6faff,
        LAVENDERBLUSH: 0xfff0f5ff,
        LAWNGREEN: 0x7cfc00ff,
        LEMONCHIFFON: 0xfffacdff,
        LIGHTBLUE: 0xadd8e6ff,
        LIGHTCORAL: 0xf08080ff,
        LIGHTCYAN: 0xe0ffffff,
        LIGHTGOLDENRODYELLOW: 0xfafad2ff,
        LIGHTGRAY: 0xd3d3d3ff,
        LIGHTGREEN: 0x90ee90ff,
        LIGHTGREY: 0xd3d3d3ff,
        LIGHTPINK: 0xffb6c1ff,
        LIGHTSALMON: 0xffa07aff,
        LIGHTSEAGREEN: 0x20b2aaff,
        LIGHTSKYBLUE: 0x87cefaff,
        LIGHTSLATEGRAY: 0x778899ff,
        LIGHTSLATEGREY: 0x778899ff,
        LIGHTSTEELBLUE: 0xb0c4deff,
        LIGHTYELLOW: 0xffffe0ff,
        LIME: 0x00ff00ff,
        LIMEGREEN: 0x32cd32ff,
        LINEN: 0xfaf0e6ff,
        MAGENTA: 0xff00ffff,
        MAROON: 0x800000ff,
        MEDIUMAQUAMARINE: 0x66cdaaff,
        MEDIUMBLUE: 0x0000cdff,
        MEDIUMORCHID: 0xba55d3ff,
        MEDIUMPURPLE: 0x9370dbff,
        MEDIUMSEAGREEN: 0x3cb371ff,
        MEDIUMSLATEBLUE: 0x7b68eeff,
        MEDIUMSPRINGGREEN: 0x00fa9aff,
        MEDIUMTURQUOISE: 0x48d1ccff,
        MEDIUMVIOLETRED: 0xc71585ff,
        MIDNIGHTBLUE: 0x191970ff,
        MINTCREAM: 0xf5fffaff,
        MISTYROSE: 0xffe4e1ff,
        MOCCASIN: 0xffe4b5ff,
        NAVAJOWHITE: 0xffdeadff,
        NAVY: 0x000080ff,
        OLDLACE: 0xfdf5e6ff,
        OLIVE: 0x808000ff,
        OLIVEDRAB: 0x6b8e23ff,
        ORANGE: 0xffa500ff,
        ORANGERED: 0xff4500ff,
        ORCHID: 0xda70d6ff,
        PALEGOLDENROD: 0xeee8aaff,
        PALEGREEN: 0x98fb98ff,
        PALETURQUOISE: 0xafeeeeff,
        PALEVIOLETRED: 0xdb7093ff,
        PAPAYAWHIP: 0xffefd5ff,
        PEACHPUFF: 0xffdab9ff,
        PERU: 0xcd853fff,
        PINK: 0xffc0cbff,
        PLUM: 0xdda0ddff,
        POWDERBLUE: 0xb0e0e6ff,
        PURPLE: 0x800080ff,
        REBECCAPURPLE: 0x663399ff,
        RED: 0xff0000ff,
        ROSYBROWN: 0xbc8f8fff,
        ROYALBLUE: 0x4169e1ff,
        SADDLEBROWN: 0x8b4513ff,
        SALMON: 0xfa8072ff,
        SANDYBROWN: 0xf4a460ff,
        SEAGREEN: 0x2e8b57ff,
        SEASHELL: 0xfff5eeff,
        SIENNA: 0xa0522dff,
        SILVER: 0xc0c0c0ff,
        SKYBLUE: 0x87ceebff,
        SLATEBLUE: 0x6a5acdff,
        SLATEGRAY: 0x708090ff,
        SLATEGREY: 0x708090ff,
        SNOW: 0xfffafaff,
        SPRINGGREEN: 0x00ff7fff,
        STEELBLUE: 0x4682b4ff,
        TAN: 0xd2b48cff,
        TEAL: 0x008080ff,
        THISTLE: 0xd8bfd8ff,
        TOMATO: 0xff6347ff,
        TRANSPARENT: 0x00000000,
        TURQUOISE: 0x40e0d0ff,
        VIOLET: 0xee82eeff,
        WHEAT: 0xf5deb3ff,
        WHITE: 0xffffffff,
        WHITESMOKE: 0xf5f5f5ff,
        YELLOW: 0xffff00ff,
        YELLOWGREEN: 0x9acd32ff
    };

    var PropertyDescriptorParsingType;
    (function (PropertyDescriptorParsingType) {
        PropertyDescriptorParsingType[PropertyDescriptorParsingType["VALUE"] = 0] = "VALUE";
        PropertyDescriptorParsingType[PropertyDescriptorParsingType["LIST"] = 1] = "LIST";
        PropertyDescriptorParsingType[PropertyDescriptorParsingType["IDENT_VALUE"] = 2] = "IDENT_VALUE";
        PropertyDescriptorParsingType[PropertyDescriptorParsingType["TYPE_VALUE"] = 3] = "TYPE_VALUE";
        PropertyDescriptorParsingType[PropertyDescriptorParsingType["TOKEN_VALUE"] = 4] = "TOKEN_VALUE";
    })(PropertyDescriptorParsingType || (PropertyDescriptorParsingType = {}));

    var BACKGROUND_CLIP;
    (function (BACKGROUND_CLIP) {
        BACKGROUND_CLIP[BACKGROUND_CLIP["BORDER_BOX"] = 0] = "BORDER_BOX";
        BACKGROUND_CLIP[BACKGROUND_CLIP["PADDING_BOX"] = 1] = "PADDING_BOX";
        BACKGROUND_CLIP[BACKGROUND_CLIP["CONTENT_BOX"] = 2] = "CONTENT_BOX";
    })(BACKGROUND_CLIP || (BACKGROUND_CLIP = {}));
    var backgroundClip = {
        name: 'background-clip',
        initialValue: 'border-box',
        prefix: false,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            return tokens.map(function (token) {
                if (isIdentToken(token)) {
                    switch (token.value) {
                        case 'padding-box':
                            return BACKGROUND_CLIP.PADDING_BOX;
                        case 'content-box':
                            return BACKGROUND_CLIP.CONTENT_BOX;
                    }
                }
                return BACKGROUND_CLIP.BORDER_BOX;
            });
        }
    };

    var backgroundColor = {
        name: "background-color",
        initialValue: 'transparent',
        prefix: false,
        type: PropertyDescriptorParsingType.TYPE_VALUE,
        format: 'color'
    };

    var parseColorStop = function (args) {
        var color$1 = color.parse(args[0]);
        var stop = args[1];
        return stop && isLengthPercentage(stop) ? { color: color$1, stop: stop } : { color: color$1, stop: null };
    };
    var processColorStops = function (stops, lineLength) {
        var first = stops[0];
        var last = stops[stops.length - 1];
        if (first.stop === null) {
            first.stop = ZERO_LENGTH;
        }
        if (last.stop === null) {
            last.stop = HUNDRED_PERCENT;
        }
        var processStops = [];
        var previous = 0;
        for (var i = 0; i < stops.length; i++) {
            var stop_1 = stops[i].stop;
            if (stop_1 !== null) {
                var absoluteValue = getAbsoluteValue(stop_1, lineLength);
                if (absoluteValue > previous) {
                    processStops.push(absoluteValue);
                }
                else {
                    processStops.push(previous);
                }
                previous = absoluteValue;
            }
            else {
                processStops.push(null);
            }
        }
        var gapBegin = null;
        for (var i = 0; i < processStops.length; i++) {
            var stop_2 = processStops[i];
            if (stop_2 === null) {
                if (gapBegin === null) {
                    gapBegin = i;
                }
            }
            else if (gapBegin !== null) {
                var gapLength = i - gapBegin;
                var beforeGap = processStops[gapBegin - 1];
                var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
                for (var g = 1; g <= gapLength; g++) {
                    processStops[gapBegin + g - 1] = gapValue * g;
                }
                gapBegin = null;
            }
        }
        return stops.map(function (_a, i) {
            var color = _a.color;
            return { color: color, stop: Math.max(Math.min(1, processStops[i] / lineLength), 0) };
        });
    };
    var getAngleFromCorner = function (corner, width, height) {
        var centerX = width / 2;
        var centerY = height / 2;
        var x = getAbsoluteValue(corner[0], width) - centerX;
        var y = centerY - getAbsoluteValue(corner[1], height);
        return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
    };
    var calculateGradientDirection = function (angle, width, height) {
        var radian = typeof angle === 'number' ? angle : getAngleFromCorner(angle, width, height);
        var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        var halfLineLength = lineLength / 2;
        var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
        var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
        return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
    };
    var distance = function (a, b) { return Math.sqrt(a * a + b * b); };
    var findCorner = function (width, height, x, y, closest) {
        var corners = [[0, 0], [0, height], [width, 0], [width, height]];
        return corners.reduce(function (stat, corner) {
            var cx = corner[0], cy = corner[1];
            var d = distance(x - cx, y - cy);
            if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
                return {
                    optimumCorner: corner,
                    optimumDistance: d
                };
            }
            return stat;
        }, {
            optimumDistance: closest ? Infinity : -Infinity,
            optimumCorner: null
        }).optimumCorner;
    };
    var calculateRadius = function (gradient, x, y, width, height) {
        var rx = 0;
        var ry = 0;
        switch (gradient.size) {
            case CSSRadialExtent.CLOSEST_SIDE:
                // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradients center.
                // If the shape is an ellipse, it exactly meets the closest side in each dimension.
                if (gradient.shape === CSSRadialShape.CIRCLE) {
                    rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
                }
                else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                    rx = Math.min(Math.abs(x), Math.abs(x - width));
                    ry = Math.min(Math.abs(y), Math.abs(y - height));
                }
                break;
            case CSSRadialExtent.CLOSEST_CORNER:
                // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradients center.
                // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
                if (gradient.shape === CSSRadialShape.CIRCLE) {
                    rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
                }
                else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                    // Compute the ratio ry/rx (which is to be the same as for "closest-side")
                    var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
                    var _a = findCorner(width, height, x, y, true), cx = _a[0], cy = _a[1];
                    rx = distance(cx - x, (cy - y) / c);
                    ry = c * rx;
                }
                break;
            case CSSRadialExtent.FARTHEST_SIDE:
                // Same as closest-side, except the ending shape is sized based on the farthest side(s)
                if (gradient.shape === CSSRadialShape.CIRCLE) {
                    rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
                }
                else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                    rx = Math.max(Math.abs(x), Math.abs(x - width));
                    ry = Math.max(Math.abs(y), Math.abs(y - height));
                }
                break;
            case CSSRadialExtent.FARTHEST_CORNER:
                // Same as closest-corner, except the ending shape is sized based on the farthest corner.
                // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
                if (gradient.shape === CSSRadialShape.CIRCLE) {
                    rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
                }
                else if (gradient.shape === CSSRadialShape.ELLIPSE) {
                    // Compute the ratio ry/rx (which is to be the same as for "farthest-side")
                    var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
                    var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];
                    rx = distance(cx - x, (cy - y) / c);
                    ry = c * rx;
                }
                break;
        }
        if (Array.isArray(gradient.size)) {
            rx = getAbsoluteValue(gradient.size[0], width);
            ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
        }
        return [rx, ry];
    };

    var linearGradient = function (tokens) {
        var angle$1 = deg(180);
        var stops = [];
        parseFunctionArgs(tokens).forEach(function (arg, i) {
            if (i === 0) {
                var firstToken = arg[0];
                if (firstToken.type === TokenType.IDENT_TOKEN && firstToken.value === 'to') {
                    angle$1 = parseNamedSide(arg);
                    return;
                }
                else if (isAngle(firstToken)) {
                    angle$1 = angle.parse(firstToken);
                    return;
                }
            }
            var colorStop = parseColorStop(arg);
            stops.push(colorStop);
        });
        return { angle: angle$1, stops: stops, type: CSSImageType.LINEAR_GRADIENT };
    };

    var prefixLinearGradient = function (tokens) {
        var angle$1 = deg(180);
        var stops = [];
        parseFunctionArgs(tokens).forEach(function (arg, i) {
            if (i === 0) {
                var firstToken = arg[0];
                if (firstToken.type === TokenType.IDENT_TOKEN &&
                    ['top', 'left', 'right', 'bottom'].indexOf(firstToken.value) !== -1) {
                    angle$1 = parseNamedSide(arg);
                    return;
                }
                else if (isAngle(firstToken)) {
                    angle$1 = (angle.parse(firstToken) + deg(270)) % deg(360);
                    return;
                }
            }
            var colorStop = parseColorStop(arg);
            stops.push(colorStop);
        });
        return {
            angle: angle$1,
            stops: stops,
            type: CSSImageType.LINEAR_GRADIENT
        };
    };

    var testRangeBounds = function (document) {
        var TEST_HEIGHT = 123;
        if (document.createRange) {
            var range = document.createRange();
            if (range.getBoundingClientRect) {
                var testElement = document.createElement('boundtest');
                testElement.style.height = TEST_HEIGHT + "px";
                testElement.style.display = 'block';
                document.body.appendChild(testElement);
                range.selectNode(testElement);
                var rangeBounds = range.getBoundingClientRect();
                var rangeHeight = Math.round(rangeBounds.height);
                document.body.removeChild(testElement);
                if (rangeHeight === TEST_HEIGHT) {
                    return true;
                }
            }
        }
        return false;
    };
    var testCORS = function () { return typeof new Image().crossOrigin !== 'undefined'; };
    var testResponseType = function () { return typeof new XMLHttpRequest().responseType === 'string'; };
    var testSVG = function (document) {
        var img = new Image();
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        if (!ctx) {
            return false;
        }
        img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
        try {
            ctx.drawImage(img, 0, 0);
            canvas.toDataURL();
        }
        catch (e) {
            return false;
        }
        return true;
    };
    var isGreenPixel = function (data) {
        return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
    };
    var testForeignObject = function (document) {
        var canvas = document.createElement('canvas');
        var size = 100;
        canvas.width = size;
        canvas.height = size;
        var ctx = canvas.getContext('2d');
        if (!ctx) {
            return Promise.reject(false);
        }
        ctx.fillStyle = 'rgb(0, 255, 0)';
        ctx.fillRect(0, 0, size, size);
        var img = new Image();
        var greenImageSrc = canvas.toDataURL();
        img.src = greenImageSrc;
        var svg = createForeignObjectSVG(size, size, 0, 0, img);
        ctx.fillStyle = 'red';
        ctx.fillRect(0, 0, size, size);
        return loadSerializedSVG(svg)
            .then(function (img) {
            ctx.drawImage(img, 0, 0);
            var data = ctx.getImageData(0, 0, size, size).data;
            ctx.fillStyle = 'red';
            ctx.fillRect(0, 0, size, size);
            var node = document.createElement('div');
            node.style.backgroundImage = "url(" + greenImageSrc + ")";
            node.style.height = size + "px";
            // Firefox 55 does not render inline <img /> tags
            return isGreenPixel(data)
                ? loadSerializedSVG(createForeignObjectSVG(size, size, 0, 0, node))
                : Promise.reject(false);
        })
            .then(function (img) {
            ctx.drawImage(img, 0, 0);
            // Edge does not render background-images
            return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
        })
            .catch(function () { return false; });
    };
    var createForeignObjectSVG = function (width, height, x, y, node) {
        var xmlns = 'http://www.w3.org/2000/svg';
        var svg = document.createElementNS(xmlns, 'svg');
        var foreignObject = document.createElementNS(xmlns, 'foreignObject');
        svg.setAttributeNS(null, 'width', width.toString());
        svg.setAttributeNS(null, 'height', height.toString());
        foreignObject.setAttributeNS(null, 'width', '100%');
        foreignObject.setAttributeNS(null, 'height', '100%');
        foreignObject.setAttributeNS(null, 'x', x.toString());
        foreignObject.setAttributeNS(null, 'y', y.toString());
        foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');
        svg.appendChild(foreignObject);
        foreignObject.appendChild(node);
        return svg;
    };
    var loadSerializedSVG = function (svg) {
        return new Promise(function (resolve, reject) {
            var img = new Image();
            img.onload = function () { return resolve(img); };
            img.onerror = reject;
            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
        });
    };
    var FEATURES = {
        get SUPPORT_RANGE_BOUNDS() {
            var value = testRangeBounds(document);
            Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', { value: value });
            return value;
        },
        get SUPPORT_SVG_DRAWING() {
            var value = testSVG(document);
            Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', { value: value });
            return value;
        },
        get SUPPORT_FOREIGNOBJECT_DRAWING() {
            var value = typeof Array.from === 'function' && typeof window.fetch === 'function'
                ? testForeignObject(document)
                : Promise.resolve(false);
            Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', { value: value });
            return value;
        },
        get SUPPORT_CORS_IMAGES() {
            var value = testCORS();
            Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', { value: value });
            return value;
        },
        get SUPPORT_RESPONSE_TYPE() {
            var value = testResponseType();
            Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', { value: value });
            return value;
        },
        get SUPPORT_CORS_XHR() {
            var value = 'withCredentials' in new XMLHttpRequest();
            Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', { value: value });
            return value;
        }
    };

    var Logger = /** @class */ (function () {
        function Logger(id) {
            this.id = id;
            this.start = Date.now();
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Logger.prototype.debug = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // eslint-disable-next-line no-console
            if (typeof window !== 'undefined' && window.console && typeof console.debug === 'function') {
                // eslint-disable-next-line no-console
                console.debug.apply(console, [this.id, this.getTime() + "ms"].concat(args));
            }
            else {
                this.info.apply(this, args);
            }
        };
        Logger.prototype.getTime = function () {
            return Date.now() - this.start;
        };
        Logger.create = function (id) {
            Logger.instances[id] = new Logger(id);
        };
        Logger.destroy = function (id) {
            delete Logger.instances[id];
        };
        Logger.getInstance = function (id) {
            var instance = Logger.instances[id];
            if (typeof instance === 'undefined') {
                throw new Error("No logger instance found with id " + id);
            }
            return instance;
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Logger.prototype.info = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // eslint-disable-next-line no-console
            if (typeof window !== 'undefined' && window.console && typeof console.info === 'function') {
                // eslint-disable-next-line no-console
                console.info.apply(console, [this.id, this.getTime() + "ms"].concat(args));
            }
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Logger.prototype.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // eslint-disable-next-line no-console
            if (typeof window !== 'undefined' && window.console && typeof console.error === 'function') {
                // eslint-disable-next-line no-console
                console.error.apply(console, [this.id, this.getTime() + "ms"].concat(args));
            }
            else {
                this.info.apply(this, args);
            }
        };
        Logger.instances = {};
        return Logger;
    }());

    var CacheStorage = /** @class */ (function () {
        function CacheStorage() {
        }
        CacheStorage.create = function (name, options) {
            return (CacheStorage._caches[name] = new Cache(name, options));
        };
        CacheStorage.destroy = function (name) {
            delete CacheStorage._caches[name];
        };
        CacheStorage.open = function (name) {
            var cache = CacheStorage._caches[name];
            if (typeof cache !== 'undefined') {
                return cache;
            }
            throw new Error("Cache with key \"" + name + "\" not found");
        };
        CacheStorage.getOrigin = function (url) {
            var link = CacheStorage._link;
            if (!link) {
                return 'about:blank';
            }
            link.href = url;
            link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
            return link.protocol + link.hostname + link.port;
        };
        CacheStorage.isSameOrigin = function (src) {
            return CacheStorage.getOrigin(src) === CacheStorage._origin;
        };
        CacheStorage.setContext = function (window) {
            CacheStorage._link = window.document.createElement('a');
            CacheStorage._origin = CacheStorage.getOrigin(window.location.href);
        };
        CacheStorage.getInstance = function () {
            var current = CacheStorage._current;
            if (current === null) {
                throw new Error("No cache instance attached");
            }
            return current;
        };
        CacheStorage.attachInstance = function (cache) {
            CacheStorage._current = cache;
        };
        CacheStorage.detachInstance = function () {
            CacheStorage._current = null;
        };
        CacheStorage._caches = {};
        CacheStorage._origin = 'about:blank';
        CacheStorage._current = null;
        return CacheStorage;
    }());
    var Cache = /** @class */ (function () {
        function Cache(id, options) {
            this.id = id;
            this._options = options;
            this._cache = {};
        }
        Cache.prototype.addImage = function (src) {
            var result = Promise.resolve();
            if (this.has(src)) {
                return result;
            }
            if (isBlobImage(src) || isRenderable(src)) {
                this._cache[src] = this.loadImage(src);
                return result;
            }
            return result;
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Cache.prototype.match = function (src) {
            return this._cache[src];
        };
        Cache.prototype.loadImage = function (key) {
            return __awaiter(this, void 0, void 0, function () {
                var isSameOrigin, useCORS, useProxy, src;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            isSameOrigin = CacheStorage.isSameOrigin(key);
                            useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                            useProxy = !isInlineImage(key) &&
                                !isSameOrigin &&
                                typeof this._options.proxy === 'string' &&
                                FEATURES.SUPPORT_CORS_XHR &&
                                !useCORS;
                            if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !useProxy && !useCORS) {
                                return [2 /*return*/];
                            }
                            src = key;
                            if (!useProxy) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.proxy(src)];
                        case 1:
                            src = _a.sent();
                            _a.label = 2;
                        case 2:
                            Logger.getInstance(this.id).debug("Added image " + key.substring(0, 256));
                            return [4 /*yield*/, new Promise(function (resolve, reject) {
                                    var img = new Image();
                                    img.onload = function () { return resolve(img); };
                                    img.onerror = reject;
                                    //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous
                                    if (isInlineBase64Image(src) || useCORS) {
                                        img.crossOrigin = 'anonymous';
                                    }
                                    img.src = src;
                                    if (img.complete === true) {
                                        // Inline XML images may fail to parse, throwing an Error later on
                                        setTimeout(function () { return resolve(img); }, 500);
                                    }
                                    if (_this._options.imageTimeout > 0) {
                                        setTimeout(function () { return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image"); }, _this._options.imageTimeout);
                                    }
                                })];
                        case 3: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Cache.prototype.has = function (key) {
            return typeof this._cache[key] !== 'undefined';
        };
        Cache.prototype.keys = function () {
            return Promise.resolve(Object.keys(this._cache));
        };
        Cache.prototype.proxy = function (src) {
            var _this = this;
            var proxy = this._options.proxy;
            if (!proxy) {
                throw new Error('No proxy defined');
            }
            var key = src.substring(0, 256);
            return new Promise(function (resolve, reject) {
                var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';
                var xhr = new XMLHttpRequest();
                xhr.onload = function () {
                    if (xhr.status === 200) {
                        if (responseType === 'text') {
                            resolve(xhr.response);
                        }
                        else {
                            var reader_1 = new FileReader();
                            reader_1.addEventListener('load', function () { return resolve(reader_1.result); }, false);
                            reader_1.addEventListener('error', function (e) { return reject(e); }, false);
                            reader_1.readAsDataURL(xhr.response);
                        }
                    }
                    else {
                        reject("Failed to proxy resource " + key + " with status code " + xhr.status);
                    }
                };
                xhr.onerror = reject;
                xhr.open('GET', proxy + "?url=" + encodeURIComponent(src) + "&responseType=" + responseType);
                if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {
                    xhr.responseType = responseType;
                }
                if (_this._options.imageTimeout) {
                    var timeout_1 = _this._options.imageTimeout;
                    xhr.timeout = timeout_1;
                    xhr.ontimeout = function () { return reject("Timed out (" + timeout_1 + "ms) proxying " + key); };
                }
                xhr.send();
            });
        };
        return Cache;
    }());
    var INLINE_SVG = /^data:image\/svg\+xml/i;
    var INLINE_BASE64 = /^data:image\/.*;base64,/i;
    var INLINE_IMG = /^data:image\/.*/i;
    var isRenderable = function (src) { return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src); };
    var isInlineImage = function (src) { return INLINE_IMG.test(src); };
    var isInlineBase64Image = function (src) { return INLINE_BASE64.test(src); };
    var isBlobImage = function (src) { return src.substr(0, 4) === 'blob'; };
    var isSVG = function (src) { return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src); };

    var webkitGradient = function (tokens) {
        var angle = deg(180);
        var stops = [];
        var type = CSSImageType.LINEAR_GRADIENT;
        var shape = CSSRadialShape.CIRCLE;
        var size = CSSRadialExtent.FARTHEST_CORNER;
        var position = [];
        parseFunctionArgs(tokens).forEach(function (arg, i) {
            var firstToken = arg[0];
            if (i === 0) {
                if (isIdentToken(firstToken) && firstToken.value === 'linear') {
                    type = CSSImageType.LINEAR_GRADIENT;
                    return;
                }
                else if (isIdentToken(firstToken) && firstToken.value === 'radial') {
                    type = CSSImageType.RADIAL_GRADIENT;
                    return;
                }
            }
            if (firstToken.type === TokenType.FUNCTION) {
                if (firstToken.name === 'from') {
                    var color$1 = color.parse(firstToken.values[0]);
                    stops.push({ stop: ZERO_LENGTH, color: color$1 });
                }
                else if (firstToken.name === 'to') {
                    var color$1 = color.parse(firstToken.values[0]);
                    stops.push({ stop: HUNDRED_PERCENT, color: color$1 });
                }
                else if (firstToken.name === 'color-stop') {
                    var values = firstToken.values.filter(nonFunctionArgSeperator);
                    if (values.length === 2) {
                        var color$1 = color.parse(values[1]);
                        var stop_1 = values[0];
                        if (isNumberToken(stop_1)) {
                            stops.push({
                                stop: { type: TokenType.PERCENTAGE_TOKEN, number: stop_1.number * 100, flags: stop_1.flags },
                                color: color$1
                            });
                        }
                    }
                }
            }
        });
        return type === CSSImageType.LINEAR_GRADIENT
            ? {
                angle: (angle + deg(180)) % deg(360),
                stops: stops,
                type: type
            }
            : { size: size, shape: shape, stops: stops, position: position, type: type };
    };

    var CLOSEST_SIDE = 'closest-side';
    var FARTHEST_SIDE = 'farthest-side';
    var CLOSEST_CORNER = 'closest-corner';
    var FARTHEST_CORNER = 'farthest-corner';
    var CIRCLE = 'circle';
    var ELLIPSE = 'ellipse';
    var COVER = 'cover';
    var CONTAIN = 'contain';
    var radialGradient = function (tokens) {
        var shape = CSSRadialShape.CIRCLE;
        var size = CSSRadialExtent.FARTHEST_CORNER;
        var stops = [];
        var position = [];
        parseFunctionArgs(tokens).forEach(function (arg, i) {
            var isColorStop = true;
            if (i === 0) {
                var isAtPosition_1 = false;
                isColorStop = arg.reduce(function (acc, token) {
                    if (isAtPosition_1) {
                        if (isIdentToken(token)) {
                            switch (token.value) {
                                case 'center':
                                    position.push(FIFTY_PERCENT);
                                    return acc;
                                case 'top':
                                case 'left':
                                    position.push(ZERO_LENGTH);
                                    return acc;
                                case 'right':
                                case 'bottom':
                                    position.push(HUNDRED_PERCENT);
                                    return acc;
                            }
                        }
                        else if (isLengthPercentage(token) || isLength(token)) {
                            position.push(token);
                        }
                    }
                    else if (isIdentToken(token)) {
                        switch (token.value) {
                            case CIRCLE:
                                shape = CSSRadialShape.CIRCLE;
                                return false;
                            case ELLIPSE:
                                shape = CSSRadialShape.ELLIPSE;
                                return false;
                            case 'at':
                                isAtPosition_1 = true;
                                return false;
                            case CLOSEST_SIDE:
                                size = CSSRadialExtent.CLOSEST_SIDE;
                                return false;
                            case COVER:
                            case FARTHEST_SIDE:
                                size = CSSRadialExtent.FARTHEST_SIDE;
                                return false;
                            case CONTAIN:
                            case CLOSEST_CORNER:
                                size = CSSRadialExtent.CLOSEST_CORNER;
                                return false;
                            case FARTHEST_CORNER:
                                size = CSSRadialExtent.FARTHEST_CORNER;
                                return false;
                        }
                    }
                    else if (isLength(token) || isLengthPercentage(token)) {
                        if (!Array.isArray(size)) {
                            size = [];
                        }
                        size.push(token);
                        return false;
                    }
                    return acc;
                }, isColorStop);
            }
            if (isColorStop) {
                var colorStop = parseColorStop(arg);
                stops.push(colorStop);
            }
        });
        return { size: size, shape: shape, stops: stops, position: position, type: CSSImageType.RADIAL_GRADIENT };
    };

    var prefixRadialGradient = function (tokens) {
        var shape = CSSRadialShape.CIRCLE;
        var size = CSSRadialExtent.FARTHEST_CORNER;
        var stops = [];
        var position = [];
        parseFunctionArgs(tokens).forEach(function (arg, i) {
            var isColorStop = true;
            if (i === 0) {
                isColorStop = arg.reduce(function (acc, token) {
                    if (isIdentToken(token)) {
                        switch (token.value) {
                            case 'center':
                                position.push(FIFTY_PERCENT);
                                return false;
                            case 'top':
                            case 'left':
                                position.push(ZERO_LENGTH);
                                return false;
                            case 'right':
                            case 'bottom':
                                position.push(HUNDRED_PERCENT);
                                return false;
                        }
                    }
                    else if (isLengthPercentage(token) || isLength(token)) {
                        position.push(token);
                        return false;
                    }
                    return acc;
                }, isColorStop);
            }
            else if (i === 1) {
                isColorStop = arg.reduce(function (acc, token) {
                    if (isIdentToken(token)) {
                        switch (token.value) {
                            case CIRCLE:
                                shape = CSSRadialShape.CIRCLE;
                                return false;
                            case ELLIPSE:
                                shape = CSSRadialShape.ELLIPSE;
                                return false;
                            case CONTAIN:
                            case CLOSEST_SIDE:
                                size = CSSRadialExtent.CLOSEST_SIDE;
                                return false;
                            case FARTHEST_SIDE:
                                size = CSSRadialExtent.FARTHEST_SIDE;
                                return false;
                            case CLOSEST_CORNER:
                                size = CSSRadialExtent.CLOSEST_CORNER;
                                return false;
                            case COVER:
                            case FARTHEST_CORNER:
                                size = CSSRadialExtent.FARTHEST_CORNER;
                                return false;
                        }
                    }
                    else if (isLength(token) || isLengthPercentage(token)) {
                        if (!Array.isArray(size)) {
                            size = [];
                        }
                        size.push(token);
                        return false;
                    }
                    return acc;
                }, isColorStop);
            }
            if (isColorStop) {
                var colorStop = parseColorStop(arg);
                stops.push(colorStop);
            }
        });
        return { size: size, shape: shape, stops: stops, position: position, type: CSSImageType.RADIAL_GRADIENT };
    };

    var CSSImageType;
    (function (CSSImageType) {
        CSSImageType[CSSImageType["URL"] = 0] = "URL";
        CSSImageType[CSSImageType["LINEAR_GRADIENT"] = 1] = "LINEAR_GRADIENT";
        CSSImageType[CSSImageType["RADIAL_GRADIENT"] = 2] = "RADIAL_GRADIENT";
    })(CSSImageType || (CSSImageType = {}));
    var isLinearGradient = function (background) {
        return background.type === CSSImageType.LINEAR_GRADIENT;
    };
    var isRadialGradient = function (background) {
        return background.type === CSSImageType.RADIAL_GRADIENT;
    };
    var CSSRadialShape;
    (function (CSSRadialShape) {
        CSSRadialShape[CSSRadialShape["CIRCLE"] = 0] = "CIRCLE";
        CSSRadialShape[CSSRadialShape["ELLIPSE"] = 1] = "ELLIPSE";
    })(CSSRadialShape || (CSSRadialShape = {}));
    var CSSRadialExtent;
    (function (CSSRadialExtent) {
        CSSRadialExtent[CSSRadialExtent["CLOSEST_SIDE"] = 0] = "CLOSEST_SIDE";
        CSSRadialExtent[CSSRadialExtent["FARTHEST_SIDE"] = 1] = "FARTHEST_SIDE";
        CSSRadialExtent[CSSRadialExtent["CLOSEST_CORNER"] = 2] = "CLOSEST_CORNER";
        CSSRadialExtent[CSSRadialExtent["FARTHEST_CORNER"] = 3] = "FARTHEST_CORNER";
    })(CSSRadialExtent || (CSSRadialExtent = {}));
    var image = {
        name: 'image',
        parse: function (value) {
            if (value.type === TokenType.URL_TOKEN) {
                var image_1 = { url: value.value, type: CSSImageType.URL };
                CacheStorage.getInstance().addImage(value.value);
                return image_1;
            }
            if (value.type === TokenType.FUNCTION) {
                var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
                if (typeof imageFunction === 'undefined') {
                    throw new Error("Attempting to parse an unsupported image function \"" + value.name + "\"");
                }
                return imageFunction(value.values);
            }
            throw new Error("Unsupported image type");
        }
    };
    var SUPPORTED_IMAGE_FUNCTIONS = {
        'linear-gradient': linearGradient,
        '-moz-linear-gradient': prefixLinearGradient,
        '-ms-linear-gradient': prefixLinearGradient,
        '-o-linear-gradient': prefixLinearGradient,
        '-webkit-linear-gradient': prefixLinearGradient,
        'radial-gradient': radialGradient,
        '-moz-radial-gradient': prefixRadialGradient,
        '-ms-radial-gradient': prefixRadialGradient,
        '-o-radial-gradient': prefixRadialGradient,
        '-webkit-radial-gradient': prefixRadialGradient,
        '-webkit-gradient': webkitGradient
    };

    var backgroundImage = {
        name: 'background-image',
        initialValue: 'none',
        type: PropertyDescriptorParsingType.LIST,
        prefix: false,
        parse: function (tokens) {
            if (tokens.length === 0) {
                return [];
            }
            var first = tokens[0];
            if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
                return [];
            }
            return tokens.filter(nonFunctionArgSeperator).map(image.parse);
        }
    };

    var backgroundOrigin = {
        name: 'background-origin',
        initialValue: 'border-box',
        prefix: false,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            return tokens.map(function (token) {
                if (isIdentToken(token)) {
                    switch (token.value) {
                        case 'padding-box':
                            return 1 /* PADDING_BOX */;
                        case 'content-box':
                            return 2 /* CONTENT_BOX */;
                    }
                }
                return 0 /* BORDER_BOX */;
            });
        }
    };

    var backgroundPosition = {
        name: 'background-position',
        initialValue: '0% 0%',
        type: PropertyDescriptorParsingType.LIST,
        prefix: false,
        parse: function (tokens) {
            return parseFunctionArgs(tokens)
                .map(function (values) { return values.filter(isLengthPercentage); })
                .map(parseLengthPercentageTuple);
        }
    };

    var BACKGROUND_REPEAT;
    (function (BACKGROUND_REPEAT) {
        BACKGROUND_REPEAT[BACKGROUND_REPEAT["REPEAT"] = 0] = "REPEAT";
        BACKGROUND_REPEAT[BACKGROUND_REPEAT["NO_REPEAT"] = 1] = "NO_REPEAT";
        BACKGROUND_REPEAT[BACKGROUND_REPEAT["REPEAT_X"] = 2] = "REPEAT_X";
        BACKGROUND_REPEAT[BACKGROUND_REPEAT["REPEAT_Y"] = 3] = "REPEAT_Y";
    })(BACKGROUND_REPEAT || (BACKGROUND_REPEAT = {}));
    var backgroundRepeat = {
        name: 'background-repeat',
        initialValue: 'repeat',
        prefix: false,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            return parseFunctionArgs(tokens)
                .map(function (values) {
                return values
                    .filter(isIdentToken)
                    .map(function (token) { return token.value; })
                    .join(' ');
            })
                .map(parseBackgroundRepeat);
        }
    };
    var parseBackgroundRepeat = function (value) {
        switch (value) {
            case 'no-repeat':
                return BACKGROUND_REPEAT.NO_REPEAT;
            case 'repeat-x':
            case 'repeat no-repeat':
                return BACKGROUND_REPEAT.REPEAT_X;
            case 'repeat-y':
            case 'no-repeat repeat':
                return BACKGROUND_REPEAT.REPEAT_Y;
            case 'repeat':
            default:
                return BACKGROUND_REPEAT.REPEAT;
        }
    };

    var BACKGROUND_SIZE;
    (function (BACKGROUND_SIZE) {
        BACKGROUND_SIZE["AUTO"] = "auto";
        BACKGROUND_SIZE["CONTAIN"] = "contain";
        BACKGROUND_SIZE["COVER"] = "cover";
    })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
    var backgroundSize = {
        name: 'background-size',
        initialValue: '0',
        prefix: false,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            return parseFunctionArgs(tokens).map(function (values) { return values.filter(isBackgroundSizeInfoToken); });
        }
    };
    var isBackgroundSizeInfoToken = function (value) {
        return isIdentToken(value) || isLengthPercentage(value);
    };

    var borderColorForSide = function (side) { return ({
        name: "border-" + side + "-color",
        initialValue: 'transparent',
        prefix: false,
        type: PropertyDescriptorParsingType.TYPE_VALUE,
        format: 'color'
    }); };
    var borderTopColor = borderColorForSide('top');
    var borderRightColor = borderColorForSide('right');
    var borderBottomColor = borderColorForSide('bottom');
    var borderLeftColor = borderColorForSide('left');

    var borderRadiusForSide = function (side) { return ({
        name: "border-radius-" + side,
        initialValue: '0 0',
        prefix: false,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) { return parseLengthPercentageTuple(tokens.filter(isLengthPercentage)); }
    }); };
    var borderTopLeftRadius = borderRadiusForSide('top-left');
    var borderTopRightRadius = borderRadiusForSide('top-right');
    var borderBottomRightRadius = borderRadiusForSide('bottom-right');
    var borderBottomLeftRadius = borderRadiusForSide('bottom-left');

    var BORDER_STYLE;
    (function (BORDER_STYLE) {
        BORDER_STYLE[BORDER_STYLE["NONE"] = 0] = "NONE";
        BORDER_STYLE[BORDER_STYLE["SOLID"] = 1] = "SOLID";
    })(BORDER_STYLE || (BORDER_STYLE = {}));
    var borderStyleForSide = function (side) { return ({
        name: "border-" + side + "-style",
        initialValue: 'solid',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (style) {
            switch (style) {
                case 'none':
                    return BORDER_STYLE.NONE;
            }
            return BORDER_STYLE.SOLID;
        }
    }); };
    var borderTopStyle = borderStyleForSide('top');
    var borderRightStyle = borderStyleForSide('right');
    var borderBottomStyle = borderStyleForSide('bottom');
    var borderLeftStyle = borderStyleForSide('left');

    var borderWidthForSide = function (side) { return ({
        name: "border-" + side + "-width",
        initialValue: '0',
        type: PropertyDescriptorParsingType.VALUE,
        prefix: false,
        parse: function (token) {
            if (isDimensionToken(token)) {
                return token.number;
            }
            return 0;
        }
    }); };
    var borderTopWidth = borderWidthForSide('top');
    var borderRightWidth = borderWidthForSide('right');
    var borderBottomWidth = borderWidthForSide('bottom');
    var borderLeftWidth = borderWidthForSide('left');

    var color$1 = {
        name: "color",
        initialValue: 'transparent',
        prefix: false,
        type: PropertyDescriptorParsingType.TYPE_VALUE,
        format: 'color'
    };

    var display = {
        name: 'display',
        initialValue: 'inline-block',
        prefix: false,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            return tokens.filter(isIdentToken).reduce(function (bit, token) {
                return bit | parseDisplayValue(token.value);
            }, 0 /* NONE */);
        }
    };
    var parseDisplayValue = function (display) {
        switch (display) {
            case 'block':
                return 2 /* BLOCK */;
            case 'inline':
                return 4 /* INLINE */;
            case 'run-in':
                return 8 /* RUN_IN */;
            case 'flow':
                return 16 /* FLOW */;
            case 'flow-root':
                return 32 /* FLOW_ROOT */;
            case 'table':
                return 64 /* TABLE */;
            case 'flex':
            case '-webkit-flex':
                return 128 /* FLEX */;
            case 'grid':
                return 256 /* GRID */;
            case 'ruby':
                return 512 /* RUBY */;
            case 'subgrid':
                return 1024 /* SUBGRID */;
            case 'list-item':
                return 2048 /* LIST_ITEM */;
            case 'table-row-group':
                return 4096 /* TABLE_ROW_GROUP */;
            case 'table-header-group':
                return 8192 /* TABLE_HEADER_GROUP */;
            case 'table-footer-group':
                return 16384 /* TABLE_FOOTER_GROUP */;
            case 'table-row':
                return 32768 /* TABLE_ROW */;
            case 'table-cell':
                return 65536 /* TABLE_CELL */;
            case 'table-column-group':
                return 131072 /* TABLE_COLUMN_GROUP */;
            case 'table-column':
                return 262144 /* TABLE_COLUMN */;
            case 'table-caption':
                return 524288 /* TABLE_CAPTION */;
            case 'ruby-base':
                return 1048576 /* RUBY_BASE */;
            case 'ruby-text':
                return 2097152 /* RUBY_TEXT */;
            case 'ruby-base-container':
                return 4194304 /* RUBY_BASE_CONTAINER */;
            case 'ruby-text-container':
                return 8388608 /* RUBY_TEXT_CONTAINER */;
            case 'contents':
                return 16777216 /* CONTENTS */;
            case 'inline-block':
                return 33554432 /* INLINE_BLOCK */;
            case 'inline-list-item':
                return 67108864 /* INLINE_LIST_ITEM */;
            case 'inline-table':
                return 134217728 /* INLINE_TABLE */;
            case 'inline-flex':
                return 268435456 /* INLINE_FLEX */;
            case 'inline-grid':
                return 536870912 /* INLINE_GRID */;
        }
        return 0 /* NONE */;
    };

    var FLOAT;
    (function (FLOAT) {
        FLOAT[FLOAT["NONE"] = 0] = "NONE";
        FLOAT[FLOAT["LEFT"] = 1] = "LEFT";
        FLOAT[FLOAT["RIGHT"] = 2] = "RIGHT";
        FLOAT[FLOAT["INLINE_START"] = 3] = "INLINE_START";
        FLOAT[FLOAT["INLINE_END"] = 4] = "INLINE_END";
    })(FLOAT || (FLOAT = {}));
    var float = {
        name: 'float',
        initialValue: 'none',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (float) {
            switch (float) {
                case 'left':
                    return FLOAT.LEFT;
                case 'right':
                    return FLOAT.RIGHT;
                case 'inline-start':
                    return FLOAT.INLINE_START;
                case 'inline-end':
                    return FLOAT.INLINE_END;
            }
            return FLOAT.NONE;
        }
    };

    var letterSpacing = {
        name: 'letter-spacing',
        initialValue: '0',
        prefix: false,
        type: PropertyDescriptorParsingType.VALUE,
        parse: function (token) {
            if (token.type === TokenType.IDENT_TOKEN && token.value === 'normal') {
                return 0;
            }
            if (token.type === TokenType.NUMBER_TOKEN) {
                return token.number;
            }
            if (token.type === TokenType.DIMENSION_TOKEN) {
                return token.number;
            }
            return 0;
        }
    };

    var LINE_BREAK;
    (function (LINE_BREAK) {
        LINE_BREAK["NORMAL"] = "normal";
        LINE_BREAK["STRICT"] = "strict";
    })(LINE_BREAK || (LINE_BREAK = {}));
    var lineBreak = {
        name: 'line-break',
        initialValue: 'normal',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (lineBreak) {
            switch (lineBreak) {
                case 'strict':
                    return LINE_BREAK.STRICT;
                case 'normal':
                default:
                    return LINE_BREAK.NORMAL;
            }
        }
    };

    var lineHeight = {
        name: 'line-height',
        initialValue: 'normal',
        prefix: false,
        type: PropertyDescriptorParsingType.TOKEN_VALUE
    };
    var computeLineHeight = function (token, fontSize) {
        if (isIdentToken(token) && token.value === 'normal') {
            return 1.2 * fontSize;
        }
        else if (token.type === TokenType.NUMBER_TOKEN) {
            return fontSize * token.number;
        }
        else if (isLengthPercentage(token)) {
            return getAbsoluteValue(token, fontSize);
        }
        return fontSize;
    };

    var listStyleImage = {
        name: 'list-style-image',
        initialValue: 'none',
        type: PropertyDescriptorParsingType.VALUE,
        prefix: false,
        parse: function (token) {
            if (token.type === TokenType.IDENT_TOKEN && token.value === 'none') {
                return null;
            }
            return image.parse(token);
        }
    };

    var LIST_STYLE_POSITION;
    (function (LIST_STYLE_POSITION) {
        LIST_STYLE_POSITION[LIST_STYLE_POSITION["INSIDE"] = 0] = "INSIDE";
        LIST_STYLE_POSITION[LIST_STYLE_POSITION["OUTSIDE"] = 1] = "OUTSIDE";
    })(LIST_STYLE_POSITION || (LIST_STYLE_POSITION = {}));
    var listStylePosition = {
        name: 'list-style-position',
        initialValue: 'outside',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (position) {
            switch (position) {
                case 'inside':
                    return LIST_STYLE_POSITION.INSIDE;
                case 'outside':
                default:
                    return LIST_STYLE_POSITION.OUTSIDE;
            }
        }
    };

    var LIST_STYLE_TYPE;
    (function (LIST_STYLE_TYPE) {
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["NONE"] = -1] = "NONE";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["DISC"] = 0] = "DISC";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["CIRCLE"] = 1] = "CIRCLE";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["SQUARE"] = 2] = "SQUARE";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["DECIMAL"] = 3] = "DECIMAL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_DECIMAL"] = 4] = "CJK_DECIMAL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["DECIMAL_LEADING_ZERO"] = 5] = "DECIMAL_LEADING_ZERO";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_ROMAN"] = 6] = "LOWER_ROMAN";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["UPPER_ROMAN"] = 7] = "UPPER_ROMAN";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_GREEK"] = 8] = "LOWER_GREEK";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_ALPHA"] = 9] = "LOWER_ALPHA";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["UPPER_ALPHA"] = 10] = "UPPER_ALPHA";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["ARABIC_INDIC"] = 11] = "ARABIC_INDIC";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["ARMENIAN"] = 12] = "ARMENIAN";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["BENGALI"] = 13] = "BENGALI";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["CAMBODIAN"] = 14] = "CAMBODIAN";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_EARTHLY_BRANCH"] = 15] = "CJK_EARTHLY_BRANCH";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_HEAVENLY_STEM"] = 16] = "CJK_HEAVENLY_STEM";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["CJK_IDEOGRAPHIC"] = 17] = "CJK_IDEOGRAPHIC";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["DEVANAGARI"] = 18] = "DEVANAGARI";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["ETHIOPIC_NUMERIC"] = 19] = "ETHIOPIC_NUMERIC";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["GEORGIAN"] = 20] = "GEORGIAN";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["GUJARATI"] = 21] = "GUJARATI";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["GURMUKHI"] = 22] = "GURMUKHI";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["HEBREW"] = 22] = "HEBREW";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["HIRAGANA"] = 23] = "HIRAGANA";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["HIRAGANA_IROHA"] = 24] = "HIRAGANA_IROHA";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["JAPANESE_FORMAL"] = 25] = "JAPANESE_FORMAL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["JAPANESE_INFORMAL"] = 26] = "JAPANESE_INFORMAL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["KANNADA"] = 27] = "KANNADA";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["KATAKANA"] = 28] = "KATAKANA";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["KATAKANA_IROHA"] = 29] = "KATAKANA_IROHA";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["KHMER"] = 30] = "KHMER";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["KOREAN_HANGUL_FORMAL"] = 31] = "KOREAN_HANGUL_FORMAL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["KOREAN_HANJA_FORMAL"] = 32] = "KOREAN_HANJA_FORMAL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["KOREAN_HANJA_INFORMAL"] = 33] = "KOREAN_HANJA_INFORMAL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["LAO"] = 34] = "LAO";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["LOWER_ARMENIAN"] = 35] = "LOWER_ARMENIAN";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["MALAYALAM"] = 36] = "MALAYALAM";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["MONGOLIAN"] = 37] = "MONGOLIAN";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["MYANMAR"] = 38] = "MYANMAR";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["ORIYA"] = 39] = "ORIYA";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["PERSIAN"] = 40] = "PERSIAN";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["SIMP_CHINESE_FORMAL"] = 41] = "SIMP_CHINESE_FORMAL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["SIMP_CHINESE_INFORMAL"] = 42] = "SIMP_CHINESE_INFORMAL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["TAMIL"] = 43] = "TAMIL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["TELUGU"] = 44] = "TELUGU";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["THAI"] = 45] = "THAI";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["TIBETAN"] = 46] = "TIBETAN";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["TRAD_CHINESE_FORMAL"] = 47] = "TRAD_CHINESE_FORMAL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["TRAD_CHINESE_INFORMAL"] = 48] = "TRAD_CHINESE_INFORMAL";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["UPPER_ARMENIAN"] = 49] = "UPPER_ARMENIAN";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["DISCLOSURE_OPEN"] = 50] = "DISCLOSURE_OPEN";
        LIST_STYLE_TYPE[LIST_STYLE_TYPE["DISCLOSURE_CLOSED"] = 51] = "DISCLOSURE_CLOSED";
    })(LIST_STYLE_TYPE || (LIST_STYLE_TYPE = {}));
    var listStyleType = {
        name: 'list-style-type',
        initialValue: 'none',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (type) {
            switch (type) {
                case 'disc':
                    return LIST_STYLE_TYPE.DISC;
                case 'circle':
                    return LIST_STYLE_TYPE.CIRCLE;
                case 'square':
                    return LIST_STYLE_TYPE.SQUARE;
                case 'decimal':
                    return LIST_STYLE_TYPE.DECIMAL;
                case 'cjk-decimal':
                    return LIST_STYLE_TYPE.CJK_DECIMAL;
                case 'decimal-leading-zero':
                    return LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO;
                case 'lower-roman':
                    return LIST_STYLE_TYPE.LOWER_ROMAN;
                case 'upper-roman':
                    return LIST_STYLE_TYPE.UPPER_ROMAN;
                case 'lower-greek':
                    return LIST_STYLE_TYPE.LOWER_GREEK;
                case 'lower-alpha':
                    return LIST_STYLE_TYPE.LOWER_ALPHA;
                case 'upper-alpha':
                    return LIST_STYLE_TYPE.UPPER_ALPHA;
                case 'arabic-indic':
                    return LIST_STYLE_TYPE.ARABIC_INDIC;
                case 'armenian':
                    return LIST_STYLE_TYPE.ARMENIAN;
                case 'bengali':
                    return LIST_STYLE_TYPE.BENGALI;
                case 'cambodian':
                    return LIST_STYLE_TYPE.CAMBODIAN;
                case 'cjk-earthly-branch':
                    return LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH;
                case 'cjk-heavenly-stem':
                    return LIST_STYLE_TYPE.CJK_HEAVENLY_STEM;
                case 'cjk-ideographic':
                    return LIST_STYLE_TYPE.CJK_IDEOGRAPHIC;
                case 'devanagari':
                    return LIST_STYLE_TYPE.DEVANAGARI;
                case 'ethiopic-numeric':
                    return LIST_STYLE_TYPE.ETHIOPIC_NUMERIC;
                case 'georgian':
                    return LIST_STYLE_TYPE.GEORGIAN;
                case 'gujarati':
                    return LIST_STYLE_TYPE.GUJARATI;
                case 'gurmukhi':
                    return LIST_STYLE_TYPE.GURMUKHI;
                case 'hebrew':
                    return LIST_STYLE_TYPE.HEBREW;
                case 'hiragana':
                    return LIST_STYLE_TYPE.HIRAGANA;
                case 'hiragana-iroha':
                    return LIST_STYLE_TYPE.HIRAGANA_IROHA;
                case 'japanese-formal':
                    return LIST_STYLE_TYPE.JAPANESE_FORMAL;
                case 'japanese-informal':
                    return LIST_STYLE_TYPE.JAPANESE_INFORMAL;
                case 'kannada':
                    return LIST_STYLE_TYPE.KANNADA;
                case 'katakana':
                    return LIST_STYLE_TYPE.KATAKANA;
                case 'katakana-iroha':
                    return LIST_STYLE_TYPE.KATAKANA_IROHA;
                case 'khmer':
                    return LIST_STYLE_TYPE.KHMER;
                case 'korean-hangul-formal':
                    return LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL;
                case 'korean-hanja-formal':
                    return LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL;
                case 'korean-hanja-informal':
                    return LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL;
                case 'lao':
                    return LIST_STYLE_TYPE.LAO;
                case 'lower-armenian':
                    return LIST_STYLE_TYPE.LOWER_ARMENIAN;
                case 'malayalam':
                    return LIST_STYLE_TYPE.MALAYALAM;
                case 'mongolian':
                    return LIST_STYLE_TYPE.MONGOLIAN;
                case 'myanmar':
                    return LIST_STYLE_TYPE.MYANMAR;
                case 'oriya':
                    return LIST_STYLE_TYPE.ORIYA;
                case 'persian':
                    return LIST_STYLE_TYPE.PERSIAN;
                case 'simp-chinese-formal':
                    return LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL;
                case 'simp-chinese-informal':
                    return LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL;
                case 'tamil':
                    return LIST_STYLE_TYPE.TAMIL;
                case 'telugu':
                    return LIST_STYLE_TYPE.TELUGU;
                case 'thai':
                    return LIST_STYLE_TYPE.THAI;
                case 'tibetan':
                    return LIST_STYLE_TYPE.TIBETAN;
                case 'trad-chinese-formal':
                    return LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL;
                case 'trad-chinese-informal':
                    return LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL;
                case 'upper-armenian':
                    return LIST_STYLE_TYPE.UPPER_ARMENIAN;
                case 'disclosure-open':
                    return LIST_STYLE_TYPE.DISCLOSURE_OPEN;
                case 'disclosure-closed':
                    return LIST_STYLE_TYPE.DISCLOSURE_CLOSED;
                case 'none':
                default:
                    return LIST_STYLE_TYPE.NONE;
            }
        }
    };

    var marginForSide = function (side) { return ({
        name: "margin-" + side,
        initialValue: '0',
        prefix: false,
        type: PropertyDescriptorParsingType.TOKEN_VALUE
    }); };
    var marginTop = marginForSide('top');
    var marginRight = marginForSide('right');
    var marginBottom = marginForSide('bottom');
    var marginLeft = marginForSide('left');

    var OVERFLOW;
    (function (OVERFLOW) {
        OVERFLOW[OVERFLOW["VISIBLE"] = 0] = "VISIBLE";
        OVERFLOW[OVERFLOW["HIDDEN"] = 1] = "HIDDEN";
        OVERFLOW[OVERFLOW["SCROLL"] = 2] = "SCROLL";
        OVERFLOW[OVERFLOW["AUTO"] = 3] = "AUTO";
    })(OVERFLOW || (OVERFLOW = {}));
    var overflow = {
        name: 'overflow',
        initialValue: 'visible',
        prefix: false,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            return tokens.filter(isIdentToken).map(function (overflow) {
                switch (overflow.value) {
                    case 'hidden':
                        return OVERFLOW.HIDDEN;
                    case 'scroll':
                        return OVERFLOW.SCROLL;
                    case 'auto':
                        return OVERFLOW.AUTO;
                    case 'visible':
                    default:
                        return OVERFLOW.VISIBLE;
                }
            });
        }
    };

    var OVERFLOW_WRAP;
    (function (OVERFLOW_WRAP) {
        OVERFLOW_WRAP["NORMAL"] = "normal";
        OVERFLOW_WRAP["BREAK_WORD"] = "break-word";
    })(OVERFLOW_WRAP || (OVERFLOW_WRAP = {}));
    var overflowWrap = {
        name: 'overflow-wrap',
        initialValue: 'normal',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (overflow) {
            switch (overflow) {
                case 'break-word':
                    return OVERFLOW_WRAP.BREAK_WORD;
                case 'normal':
                default:
                    return OVERFLOW_WRAP.NORMAL;
            }
        }
    };

    var paddingForSide = function (side) { return ({
        name: "padding-" + side,
        initialValue: '0',
        prefix: false,
        type: PropertyDescriptorParsingType.TYPE_VALUE,
        format: 'length-percentage'
    }); };
    var paddingTop = paddingForSide('top');
    var paddingRight = paddingForSide('right');
    var paddingBottom = paddingForSide('bottom');
    var paddingLeft = paddingForSide('left');

    var TEXT_ALIGN;
    (function (TEXT_ALIGN) {
        TEXT_ALIGN[TEXT_ALIGN["LEFT"] = 0] = "LEFT";
        TEXT_ALIGN[TEXT_ALIGN["CENTER"] = 1] = "CENTER";
        TEXT_ALIGN[TEXT_ALIGN["RIGHT"] = 2] = "RIGHT";
    })(TEXT_ALIGN || (TEXT_ALIGN = {}));
    var textAlign = {
        name: 'text-align',
        initialValue: 'left',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (textAlign) {
            switch (textAlign) {
                case 'right':
                    return TEXT_ALIGN.RIGHT;
                case 'center':
                case 'justify':
                    return TEXT_ALIGN.CENTER;
                case 'left':
                default:
                    return TEXT_ALIGN.LEFT;
            }
        }
    };

    var POSITION;
    (function (POSITION) {
        POSITION[POSITION["STATIC"] = 0] = "STATIC";
        POSITION[POSITION["RELATIVE"] = 1] = "RELATIVE";
        POSITION[POSITION["ABSOLUTE"] = 2] = "ABSOLUTE";
        POSITION[POSITION["FIXED"] = 3] = "FIXED";
        POSITION[POSITION["STICKY"] = 4] = "STICKY";
    })(POSITION || (POSITION = {}));
    var position = {
        name: 'position',
        initialValue: 'static',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (position) {
            switch (position) {
                case 'relative':
                    return POSITION.RELATIVE;
                case 'absolute':
                    return POSITION.ABSOLUTE;
                case 'fixed':
                    return POSITION.FIXED;
                case 'sticky':
                    return POSITION.STICKY;
            }
            return POSITION.STATIC;
        }
    };

    var textShadow = {
        name: 'text-shadow',
        initialValue: 'none',
        type: PropertyDescriptorParsingType.LIST,
        prefix: false,
        parse: function (tokens) {
            if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
                return [];
            }
            return parseFunctionArgs(tokens).map(function (values) {
                var shadow = {
                    color: COLORS.TRANSPARENT,
                    offsetX: ZERO_LENGTH,
                    offsetY: ZERO_LENGTH,
                    blur: ZERO_LENGTH
                };
                var c = 0;
                for (var i = 0; i < values.length; i++) {
                    var token = values[i];
                    if (isLength(token)) {
                        if (c === 0) {
                            shadow.offsetX = token;
                        }
                        else if (c === 1) {
                            shadow.offsetY = token;
                        }
                        else {
                            shadow.blur = token;
                        }
                        c++;
                    }
                    else {
                        shadow.color = color.parse(token);
                    }
                }
                return shadow;
            });
        }
    };

    var TEXT_TRANSFORM;
    (function (TEXT_TRANSFORM) {
        TEXT_TRANSFORM[TEXT_TRANSFORM["NONE"] = 0] = "NONE";
        TEXT_TRANSFORM[TEXT_TRANSFORM["LOWERCASE"] = 1] = "LOWERCASE";
        TEXT_TRANSFORM[TEXT_TRANSFORM["UPPERCASE"] = 2] = "UPPERCASE";
        TEXT_TRANSFORM[TEXT_TRANSFORM["CAPITALIZE"] = 3] = "CAPITALIZE";
    })(TEXT_TRANSFORM || (TEXT_TRANSFORM = {}));
    var textTransform = {
        name: 'text-transform',
        initialValue: 'none',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (textTransform) {
            switch (textTransform) {
                case 'uppercase':
                    return TEXT_TRANSFORM.UPPERCASE;
                case 'lowercase':
                    return TEXT_TRANSFORM.LOWERCASE;
                case 'capitalize':
                    return TEXT_TRANSFORM.CAPITALIZE;
            }
            return TEXT_TRANSFORM.NONE;
        }
    };

    var transform = {
        name: 'transform',
        initialValue: 'none',
        prefix: true,
        type: PropertyDescriptorParsingType.VALUE,
        parse: function (token) {
            if (token.type === TokenType.IDENT_TOKEN && token.value === 'none') {
                return null;
            }
            if (token.type === TokenType.FUNCTION) {
                var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
                if (typeof transformFunction === 'undefined') {
                    throw new Error("Attempting to parse an unsupported transform function \"" + token.name + "\"");
                }
                return transformFunction(token.values);
            }
            return null;
        }
    };
    var matrix = function (args) {
        var values = args.filter(function (arg) { return arg.type === TokenType.NUMBER_TOKEN; }).map(function (arg) { return arg.number; });
        return values.length === 6 ? values : null;
    };
    // doesn't support 3D transforms at the moment
    var matrix3d = function (args) {
        var values = args.filter(function (arg) { return arg.type === TokenType.NUMBER_TOKEN; }).map(function (arg) { return arg.number; });
        var a1 = values[0], b1 = values[1], _a = values[2], _b = values[3], a2 = values[4], b2 = values[5], _c = values[6], _d = values[7], _e = values[8], _f = values[9], _g = values[10], _h = values[11], a4 = values[12], b4 = values[13], _j = values[14], _k = values[15];
        return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
    };
    var SUPPORTED_TRANSFORM_FUNCTIONS = {
        matrix: matrix,
        matrix3d: matrix3d
    };

    var DEFAULT_VALUE = {
        type: TokenType.PERCENTAGE_TOKEN,
        number: 50,
        flags: FLAG_INTEGER
    };
    var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
    var transformOrigin = {
        name: 'transform-origin',
        initialValue: '50% 50%',
        prefix: true,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            var origins = tokens.filter(isLengthPercentage);
            if (origins.length !== 2) {
                return DEFAULT;
            }
            return [origins[0], origins[1]];
        }
    };

    var VISIBILITY;
    (function (VISIBILITY) {
        VISIBILITY[VISIBILITY["VISIBLE"] = 0] = "VISIBLE";
        VISIBILITY[VISIBILITY["HIDDEN"] = 1] = "HIDDEN";
        VISIBILITY[VISIBILITY["COLLAPSE"] = 2] = "COLLAPSE";
    })(VISIBILITY || (VISIBILITY = {}));
    var visibility = {
        name: 'visible',
        initialValue: 'none',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (visibility) {
            switch (visibility) {
                case 'hidden':
                    return VISIBILITY.HIDDEN;
                case 'collapse':
                    return VISIBILITY.COLLAPSE;
                case 'visible':
                default:
                    return VISIBILITY.VISIBLE;
            }
        }
    };

    var WORD_BREAK;
    (function (WORD_BREAK) {
        WORD_BREAK["NORMAL"] = "normal";
        WORD_BREAK["BREAK_ALL"] = "break-all";
        WORD_BREAK["KEEP_ALL"] = "keep-all";
    })(WORD_BREAK || (WORD_BREAK = {}));
    var wordBreak = {
        name: 'word-break',
        initialValue: 'normal',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (wordBreak) {
            switch (wordBreak) {
                case 'break-all':
                    return WORD_BREAK.BREAK_ALL;
                case 'keep-all':
                    return WORD_BREAK.KEEP_ALL;
                case 'normal':
                default:
                    return WORD_BREAK.NORMAL;
            }
        }
    };

    var zIndex = {
        name: 'z-index',
        initialValue: 'auto',
        prefix: false,
        type: PropertyDescriptorParsingType.VALUE,
        parse: function (token) {
            if (token.type === TokenType.IDENT_TOKEN) {
                return { auto: true, order: 0 };
            }
            if (isNumberToken(token)) {
                return { auto: false, order: token.number };
            }
            throw new Error("Invalid z-index number parsed");
        }
    };

    var opacity = {
        name: 'opacity',
        initialValue: '1',
        type: PropertyDescriptorParsingType.VALUE,
        prefix: false,
        parse: function (token) {
            if (isNumberToken(token)) {
                return token.number;
            }
            return 1;
        }
    };

    var textDecorationColor = {
        name: "text-decoration-color",
        initialValue: 'transparent',
        prefix: false,
        type: PropertyDescriptorParsingType.TYPE_VALUE,
        format: 'color'
    };

    var textDecorationLine = {
        name: 'text-decoration-line',
        initialValue: 'none',
        prefix: false,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            return tokens
                .filter(isIdentToken)
                .map(function (token) {
                switch (token.value) {
                    case 'underline':
                        return 1 /* UNDERLINE */;
                    case 'overline':
                        return 2 /* OVERLINE */;
                    case 'line-through':
                        return 3 /* LINE_THROUGH */;
                    case 'none':
                        return 4 /* BLINK */;
                }
                return 0 /* NONE */;
            })
                .filter(function (line) { return line !== 0 /* NONE */; });
        }
    };

    var fontFamily = {
        name: "font-family",
        initialValue: '',
        prefix: false,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            return tokens.filter(isStringToken$1).map(function (token) { return token.value; });
        }
    };
    var isStringToken$1 = function (token) {
        return token.type === TokenType.STRING_TOKEN || token.type === TokenType.IDENT_TOKEN;
    };

    var fontSize = {
        name: "font-size",
        initialValue: '0',
        prefix: false,
        type: PropertyDescriptorParsingType.TYPE_VALUE,
        format: 'length'
    };

    var fontWeight = {
        name: 'font-weight',
        initialValue: 'normal',
        type: PropertyDescriptorParsingType.VALUE,
        prefix: false,
        parse: function (token) {
            if (isNumberToken(token)) {
                return token.number;
            }
            if (isIdentToken(token)) {
                switch (token.value) {
                    case 'bold':
                        return 700;
                    case 'normal':
                    default:
                        return 400;
                }
            }
            return 400;
        }
    };

    var fontVariant = {
        name: 'font-variant',
        initialValue: 'none',
        type: PropertyDescriptorParsingType.LIST,
        prefix: false,
        parse: function (tokens) {
            return tokens.filter(isIdentToken).map(function (token) { return token.value; });
        }
    };

    var FONT_STYLE;
    (function (FONT_STYLE) {
        FONT_STYLE["NORMAL"] = "normal";
        FONT_STYLE["ITALIC"] = "italic";
        FONT_STYLE["OBLIQUE"] = "oblique";
    })(FONT_STYLE || (FONT_STYLE = {}));
    var fontStyle = {
        name: 'font-style',
        initialValue: 'normal',
        prefix: false,
        type: PropertyDescriptorParsingType.IDENT_VALUE,
        parse: function (overflow) {
            switch (overflow) {
                case 'oblique':
                    return FONT_STYLE.OBLIQUE;
                case 'italic':
                    return FONT_STYLE.ITALIC;
                case 'normal':
                default:
                    return FONT_STYLE.NORMAL;
            }
        }
    };

    var contains = function (bit, value) { return (bit & value) !== 0; };

    var content = {
        name: 'content',
        initialValue: 'none',
        type: PropertyDescriptorParsingType.LIST,
        prefix: false,
        parse: function (tokens) {
            if (tokens.length === 0) {
                return [];
            }
            var first = tokens[0];
            if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
                return [];
            }
            return tokens;
        }
    };

    var counterIncrement = {
        name: 'counter-increment',
        initialValue: 'none',
        prefix: true,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            if (tokens.length === 0) {
                return null;
            }
            var first = tokens[0];
            if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
                return null;
            }
            var increments = [];
            var filtered = tokens.filter(nonWhiteSpace);
            for (var i = 0; i < filtered.length; i++) {
                var counter = filtered[i];
                var next = filtered[i + 1];
                if (counter.type === TokenType.IDENT_TOKEN) {
                    var increment = next && isNumberToken(next) ? next.number : 1;
                    increments.push({ counter: counter.value, increment: increment });
                }
            }
            return increments;
        }
    };

    var counterReset = {
        name: 'counter-reset',
        initialValue: 'none',
        prefix: true,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            if (tokens.length === 0) {
                return [];
            }
            var resets = [];
            var filtered = tokens.filter(nonWhiteSpace);
            for (var i = 0; i < filtered.length; i++) {
                var counter = filtered[i];
                var next = filtered[i + 1];
                if (isIdentToken(counter) && counter.value !== 'none') {
                    var reset = next && isNumberToken(next) ? next.number : 0;
                    resets.push({ counter: counter.value, reset: reset });
                }
            }
            return resets;
        }
    };

    var quotes = {
        name: 'quotes',
        initialValue: 'none',
        prefix: true,
        type: PropertyDescriptorParsingType.LIST,
        parse: function (tokens) {
            if (tokens.length === 0) {
                return null;
            }
            var first = tokens[0];
            if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {
                return null;
            }
            var quotes = [];
            var filtered = tokens.filter(isStringToken);
            if (filtered.length % 2 !== 0) {
                return null;
            }
            for (var i = 0; i < filtered.length; i += 2) {
                var open_1 = filtered[i].value;
                var close_1 = filtered[i + 1].value;
                quotes.push({ open: open_1, close: close_1 });
            }
            return quotes;
        }
    };
    var getQuote = function (quotes, depth, open) {
        if (!quotes) {
            return '';
        }
        var quote = quotes[Math.min(depth, quotes.length - 1)];
        if (!quote) {
            return '';
        }
        return open ? quote.open : quote.close;
    };

    var boxShadow = {
        name: 'box-shadow',
        initialValue: 'none',
        type: PropertyDescriptorParsingType.LIST,
        prefix: false,
        parse: function (tokens) {
            if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
                return [];
            }
            return parseFunctionArgs(tokens).map(function (values) {
                var shadow = {
                    color: 0x000000ff,
                    offsetX: ZERO_LENGTH,
                    offsetY: ZERO_LENGTH,
                    blur: ZERO_LENGTH,
                    spread: ZERO_LENGTH,
                    inset: false
                };
                var c = 0;
                for (var i = 0; i < values.length; i++) {
                    var token = values[i];
                    if (isIdentWithValue(token, 'inset')) {
                        shadow.inset = true;
                    }
                    else if (isLength(token)) {
                        if (c === 0) {
                            shadow.offsetX = token;
                        }
                        else if (c === 1) {
                            shadow.offsetY = token;
                        }
                        else if (c === 2) {
                            shadow.blur = token;
                        }
                        else {
                            shadow.spread = token;
                        }
                        c++;
                    }
                    else {
                        shadow.color = color.parse(token);
                    }
                }
                return shadow;
            });
        }
    };

    var CSSParsedDeclaration = /** @class */ (function () {
        function CSSParsedDeclaration(declaration) {
            this.backgroundClip = parse(backgroundClip, declaration.backgroundClip);
            this.backgroundColor = parse(backgroundColor, declaration.backgroundColor);
            this.backgroundImage = parse(backgroundImage, declaration.backgroundImage);
            this.backgroundOrigin = parse(backgroundOrigin, declaration.backgroundOrigin);
            this.backgroundPosition = parse(backgroundPosition, declaration.backgroundPosition);
            this.backgroundRepeat = parse(backgroundRepeat, declaration.backgroundRepeat);
            this.backgroundSize = parse(backgroundSize, declaration.backgroundSize);
            this.borderTopColor = parse(borderTopColor, declaration.borderTopColor);
            this.borderRightColor = parse(borderRightColor, declaration.borderRightColor);
            this.borderBottomColor = parse(borderBottomColor, declaration.borderBottomColor);
            this.borderLeftColor = parse(borderLeftColor, declaration.borderLeftColor);
            this.borderTopLeftRadius = parse(borderTopLeftRadius, declaration.borderTopLeftRadius);
            this.borderTopRightRadius = parse(borderTopRightRadius, declaration.borderTopRightRadius);
            this.borderBottomRightRadius = parse(borderBottomRightRadius, declaration.borderBottomRightRadius);
            this.borderBottomLeftRadius = parse(borderBottomLeftRadius, declaration.borderBottomLeftRadius);
            this.borderTopStyle = parse(borderTopStyle, declaration.borderTopStyle);
            this.borderRightStyle = parse(borderRightStyle, declaration.borderRightStyle);
            this.borderBottomStyle = parse(borderBottomStyle, declaration.borderBottomStyle);
            this.borderLeftStyle = parse(borderLeftStyle, declaration.borderLeftStyle);
            this.borderTopWidth = parse(borderTopWidth, declaration.borderTopWidth);
            this.borderRightWidth = parse(borderRightWidth, declaration.borderRightWidth);
            this.borderBottomWidth = parse(borderBottomWidth, declaration.borderBottomWidth);
            this.borderLeftWidth = parse(borderLeftWidth, declaration.borderLeftWidth);
            this.boxShadow = parse(boxShadow, declaration.boxShadow);
            this.color = parse(color$1, declaration.color);
            this.display = parse(display, declaration.display);
            this.float = parse(float, declaration.cssFloat);
            this.fontFamily = parse(fontFamily, declaration.fontFamily);
            this.fontSize = parse(fontSize, declaration.fontSize);
            this.fontStyle = parse(fontStyle, declaration.fontStyle);
            this.fontVariant = parse(fontVariant, declaration.fontVariant);
            this.fontWeight = parse(fontWeight, declaration.fontWeight);
            this.letterSpacing = parse(letterSpacing, declaration.letterSpacing);
            this.lineBreak = parse(lineBreak, declaration.lineBreak);
            this.lineHeight = parse(lineHeight, declaration.lineHeight);
            this.listStyleImage = parse(listStyleImage, declaration.listStyleImage);
            this.listStylePosition = parse(listStylePosition, declaration.listStylePosition);
            this.listStyleType = parse(listStyleType, declaration.listStyleType);
            this.marginTop = parse(marginTop, declaration.marginTop);
            this.marginRight = parse(marginRight, declaration.marginRight);
            this.marginBottom = parse(marginBottom, declaration.marginBottom);
            this.marginLeft = parse(marginLeft, declaration.marginLeft);
            this.opacity = parse(opacity, declaration.opacity);
            var overflowTuple = parse(overflow, declaration.overflow);
            this.overflowX = overflowTuple[0];
            this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
            this.overflowWrap = parse(overflowWrap, declaration.overflowWrap);
            this.paddingTop = parse(paddingTop, declaration.paddingTop);
            this.paddingRight = parse(paddingRight, declaration.paddingRight);
            this.paddingBottom = parse(paddingBottom, declaration.paddingBottom);
            this.paddingLeft = parse(paddingLeft, declaration.paddingLeft);
            this.position = parse(position, declaration.position);
            this.textAlign = parse(textAlign, declaration.textAlign);
            this.textDecorationColor = parse(textDecorationColor, declaration.textDecorationColor || declaration.color);
            this.textDecorationLine = parse(textDecorationLine, declaration.textDecorationLine);
            this.textShadow = parse(textShadow, declaration.textShadow);
            this.textTransform = parse(textTransform, declaration.textTransform);
            this.transform = parse(transform, declaration.transform);
            this.transformOrigin = parse(transformOrigin, declaration.transformOrigin);
            this.visibility = parse(visibility, declaration.visibility);
            this.wordBreak = parse(wordBreak, declaration.wordBreak);
            this.zIndex = parse(zIndex, declaration.zIndex);
        }
        CSSParsedDeclaration.prototype.isVisible = function () {
            return this.display > 0 && this.opacity > 0 && this.visibility === VISIBILITY.VISIBLE;
        };
        CSSParsedDeclaration.prototype.isTransparent = function () {
            return isTransparent(this.backgroundColor);
        };
        CSSParsedDeclaration.prototype.isTransformed = function () {
            return this.transform !== null;
        };
        CSSParsedDeclaration.prototype.isPositioned = function () {
            return this.position !== POSITION.STATIC;
        };
        CSSParsedDeclaration.prototype.isPositionedWithZIndex = function () {
            return this.isPositioned() && !this.zIndex.auto;
        };
        CSSParsedDeclaration.prototype.isFloating = function () {
            return this.float !== FLOAT.NONE;
        };
        CSSParsedDeclaration.prototype.isInlineLevel = function () {
            return (contains(this.display, 4 /* INLINE */) ||
                contains(this.display, 33554432 /* INLINE_BLOCK */) ||
                contains(this.display, 268435456 /* INLINE_FLEX */) ||
                contains(this.display, 536870912 /* INLINE_GRID */) ||
                contains(this.display, 67108864 /* INLINE_LIST_ITEM */) ||
                contains(this.display, 134217728 /* INLINE_TABLE */));
        };
        return CSSParsedDeclaration;
    }());
    var CSSParsedPseudoDeclaration = /** @class */ (function () {
        function CSSParsedPseudoDeclaration(declaration) {
            this.content = parse(content, declaration.content);
            this.quotes = parse(quotes, declaration.quotes);
        }
        return CSSParsedPseudoDeclaration;
    }());
    var CSSParsedCounterDeclaration = /** @class */ (function () {
        function CSSParsedCounterDeclaration(declaration) {
            this.counterIncrement = parse(counterIncrement, declaration.counterIncrement);
            this.counterReset = parse(counterReset, declaration.counterReset);
        }
        return CSSParsedCounterDeclaration;
    }());
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var parse = function (descriptor, style) {
        var tokenizer = new Tokenizer();
        var value = style !== null && typeof style !== 'undefined' ? style.toString() : descriptor.initialValue;
        tokenizer.write(value);
        var parser = new Parser(tokenizer.read());
        switch (descriptor.type) {
            case PropertyDescriptorParsingType.IDENT_VALUE:
                var token = parser.parseComponentValue();
                return descriptor.parse(isIdentToken(token) ? token.value : descriptor.initialValue);
            case PropertyDescriptorParsingType.VALUE:
                return descriptor.parse(parser.parseComponentValue());
            case PropertyDescriptorParsingType.LIST:
                return descriptor.parse(parser.parseComponentValues());
            case PropertyDescriptorParsingType.TOKEN_VALUE:
                return parser.parseComponentValue();
            case PropertyDescriptorParsingType.TYPE_VALUE:
                switch (descriptor.format) {
                    case 'angle':
                        return angle.parse(parser.parseComponentValue());
                    case 'color':
                        return color.parse(parser.parseComponentValue());
                    case 'image':
                        return image.parse(parser.parseComponentValue());
                    case 'length':
                        var length_1 = parser.parseComponentValue();
                        return isLength(length_1) ? length_1 : ZERO_LENGTH;
                    case 'length-percentage':
                        var value_1 = parser.parseComponentValue();
                        return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
                }
        }
        throw new Error("Attempting to parse unsupported css format type " + descriptor.format);
    };

    var ElementContainer = /** @class */ (function () {
        function ElementContainer(element) {
            this.styles = new CSSParsedDeclaration(window.getComputedStyle(element, null));
            this.textNodes = [];
            this.elements = [];
            if (this.styles.transform !== null && isHTMLElementNode(element)) {
                // getBoundingClientRect takes transforms into account
                element.style.transform = 'none';
            }
            this.bounds = parseBounds(element);
            this.flags = 0;
        }
        return ElementContainer;
    }());

    var TextBounds = /** @class */ (function () {
        function TextBounds(text, bounds) {
            this.text = text;
            this.bounds = bounds;
        }
        return TextBounds;
    }());
    var parseTextBounds = function (value, styles, node) {
        var textList = breakText(value, styles);
        var textBounds = [];
        var offset = 0;
        textList.forEach(function (text) {
            if (styles.textDecorationLine.length || text.trim().length > 0) {
                if (FEATURES.SUPPORT_RANGE_BOUNDS) {
                    textBounds.push(new TextBounds(text, getRangeBounds(node, offset, text.length)));
                }
                else {
                    var replacementNode = node.splitText(text.length);
                    textBounds.push(new TextBounds(text, getWrapperBounds(node)));
                    node = replacementNode;
                }
            }
            else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
                node = node.splitText(text.length);
            }
            offset += text.length;
        });
        return textBounds;
    };
    var getWrapperBounds = function (node) {
        var ownerDocument = node.ownerDocument;
        if (ownerDocument) {
            var wrapper = ownerDocument.createElement('html2canvaswrapper');
            wrapper.appendChild(node.cloneNode(true));
            var parentNode = node.parentNode;
            if (parentNode) {
                parentNode.replaceChild(wrapper, node);
                var bounds = parseBounds(wrapper);
                if (wrapper.firstChild) {
                    parentNode.replaceChild(wrapper.firstChild, wrapper);
                }
                return bounds;
            }
        }
        return new Bounds(0, 0, 0, 0);
    };
    var getRangeBounds = function (node, offset, length) {
        var ownerDocument = node.ownerDocument;
        if (!ownerDocument) {
            throw new Error('Node has no owner document');
        }
        var range = ownerDocument.createRange();
        range.setStart(node, offset);
        range.setEnd(node, offset + length);
        return Bounds.fromClientRect(range.getBoundingClientRect());
    };
    var breakText = function (value, styles) {
        return styles.letterSpacing !== 0 ? toCodePoints(value).map(function (i) { return fromCodePoint(i); }) : breakWords(value, styles);
    };
    var breakWords = function (str, styles) {
        var breaker = LineBreaker(str, {
            lineBreak: styles.lineBreak,
            wordBreak: styles.overflowWrap === OVERFLOW_WRAP.BREAK_WORD ? 'break-word' : styles.wordBreak
        });
        var words = [];
        var bk;
        while (!(bk = breaker.next()).done) {
            if (bk.value) {
                words.push(bk.value.slice());
            }
        }
        return words;
    };

    var TextContainer = /** @class */ (function () {
        function TextContainer(node, styles) {
            this.text = transform$1(node.data, styles.textTransform);
            this.textBounds = parseTextBounds(this.text, styles, node);
        }
        return TextContainer;
    }());
    var transform$1 = function (text, transform) {
        switch (transform) {
            case TEXT_TRANSFORM.LOWERCASE:
                return text.toLowerCase();
            case TEXT_TRANSFORM.CAPITALIZE:
                return text.replace(CAPITALIZE, capitalize);
            case TEXT_TRANSFORM.UPPERCASE:
                return text.toUpperCase();
            default:
                return text;
        }
    };
    var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
    var capitalize = function (m, p1, p2) {
        if (m.length > 0) {
            return p1 + p2.toUpperCase();
        }
        return m;
    };

    var ImageElementContainer = /** @class */ (function (_super) {
        __extends(ImageElementContainer, _super);
        function ImageElementContainer(img) {
            var _this = _super.call(this, img) || this;
            _this.src = img.currentSrc || img.src;
            _this.intrinsicWidth = img.naturalWidth;
            _this.intrinsicHeight = img.naturalHeight;
            CacheStorage.getInstance().addImage(_this.src);
            return _this;
        }
        return ImageElementContainer;
    }(ElementContainer));

    var CanvasElementContainer = /** @class */ (function (_super) {
        __extends(CanvasElementContainer, _super);
        function CanvasElementContainer(canvas) {
            var _this = _super.call(this, canvas) || this;
            _this.canvas = canvas;
            _this.intrinsicWidth = canvas.width;
            _this.intrinsicHeight = canvas.height;
            return _this;
        }
        return CanvasElementContainer;
    }(ElementContainer));

    var SVGElementContainer = /** @class */ (function (_super) {
        __extends(SVGElementContainer, _super);
        function SVGElementContainer(img) {
            var _this = _super.call(this, img) || this;
            var s = new XMLSerializer();
            _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
            _this.intrinsicWidth = img.width.baseVal.value;
            _this.intrinsicHeight = img.height.baseVal.value;
            CacheStorage.getInstance().addImage(_this.svg);
            return _this;
        }
        return SVGElementContainer;
    }(ElementContainer));

    var LIElementContainer = /** @class */ (function (_super) {
        __extends(LIElementContainer, _super);
        function LIElementContainer(element) {
            var _this = _super.call(this, element) || this;
            _this.value = element.value;
            return _this;
        }
        return LIElementContainer;
    }(ElementContainer));

    var OLElementContainer = /** @class */ (function (_super) {
        __extends(OLElementContainer, _super);
        function OLElementContainer(element) {
            var _this = _super.call(this, element) || this;
            _this.start = element.start;
            _this.reversed = typeof element.reversed === 'boolean' && element.reversed === true;
            return _this;
        }
        return OLElementContainer;
    }(ElementContainer));

    var CHECKBOX_BORDER_RADIUS = [
        {
            type: TokenType.DIMENSION_TOKEN,
            flags: 0,
            unit: 'px',
            number: 3
        }
    ];
    var RADIO_BORDER_RADIUS = [
        {
            type: TokenType.PERCENTAGE_TOKEN,
            flags: 0,
            number: 50
        }
    ];
    var reformatInputBounds = function (bounds) {
        if (bounds.width > bounds.height) {
            return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
        }
        else if (bounds.width < bounds.height) {
            return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
        }
        return bounds;
    };
    var getInputValue = function (node) {
        var value = node.type === PASSWORD ? new Array(node.value.length + 1).join('\u2022') : node.value;
        return value.length === 0 ? node.placeholder || '' : value;
    };
    var CHECKBOX = 'checkbox';
    var RADIO = 'radio';
    var PASSWORD = 'password';
    var INPUT_COLOR = 0x2a2a2aff;
    var InputElementContainer = /** @class */ (function (_super) {
        __extends(InputElementContainer, _super);
        function InputElementContainer(input) {
            var _this = _super.call(this, input) || this;
            _this.type = input.type.toLowerCase();
            _this.checked = input.checked;
            _this.value = getInputValue(input);
            if (_this.type === CHECKBOX || _this.type === RADIO) {
                _this.styles.backgroundColor = 0xdededeff;
                _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 0xa5a5a5ff;
                _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
                _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle =
                    BORDER_STYLE.SOLID;
                _this.styles.backgroundClip = [BACKGROUND_CLIP.BORDER_BOX];
                _this.styles.backgroundOrigin = [0 /* BORDER_BOX */];
                _this.bounds = reformatInputBounds(_this.bounds);
            }
            switch (_this.type) {
                case CHECKBOX:
                    _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
                    break;
                case RADIO:
                    _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
                    break;
            }
            return _this;
        }
        return InputElementContainer;
    }(ElementContainer));

    var SelectElementContainer = /** @class */ (function (_super) {
        __extends(SelectElementContainer, _super);
        function SelectElementContainer(element) {
            var _this = _super.call(this, element) || this;
            var option = element.options[element.selectedIndex || 0];
            _this.value = option ? option.text || '' : '';
            return _this;
        }
        return SelectElementContainer;
    }(ElementContainer));

    var TextareaElementContainer = /** @class */ (function (_super) {
        __extends(TextareaElementContainer, _super);
        function TextareaElementContainer(element) {
            var _this = _super.call(this, element) || this;
            _this.value = element.value;
            return _this;
        }
        return TextareaElementContainer;
    }(ElementContainer));

    var parseColor = function (value) { return color.parse(Parser.create(value).parseComponentValue()); };
    var IFrameElementContainer = /** @class */ (function (_super) {
        __extends(IFrameElementContainer, _super);
        function IFrameElementContainer(iframe) {
            var _this = _super.call(this, iframe) || this;
            _this.src = iframe.src;
            _this.width = parseInt(iframe.width, 10);
            _this.height = parseInt(iframe.height, 10);
            _this.backgroundColor = _this.styles.backgroundColor;
            try {
                if (iframe.contentWindow &&
                    iframe.contentWindow.document &&
                    iframe.contentWindow.document.documentElement) {
                    _this.tree = parseTree(iframe.contentWindow.document.documentElement);
                    // http://www.w3.org/TR/css3-background/#special-backgrounds
                    var documentBackgroundColor = iframe.contentWindow.document.documentElement
                        ? parseColor(getComputedStyle(iframe.contentWindow.document.documentElement)
                            .backgroundColor)
                        : COLORS.TRANSPARENT;
                    var bodyBackgroundColor = iframe.contentWindow.document.body
                        ? parseColor(getComputedStyle(iframe.contentWindow.document.body).backgroundColor)
                        : COLORS.TRANSPARENT;
                    _this.backgroundColor = isTransparent(documentBackgroundColor)
                        ? isTransparent(bodyBackgroundColor)
                            ? _this.styles.backgroundColor
                            : bodyBackgroundColor
                        : documentBackgroundColor;
                }
            }
            catch (e) { }
            return _this;
        }
        return IFrameElementContainer;
    }(ElementContainer));

    var LIST_OWNERS = ['OL', 'UL', 'MENU'];
    var parseNodeTree = function (node, parent, root) {
        for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
            nextNode = childNode.nextSibling;
            if (isTextNode(childNode) && childNode.data.trim().length > 0) {
                parent.textNodes.push(new TextContainer(childNode, parent.styles));
            }
            else if (isElementNode(childNode)) {
                var container = createContainer(childNode);
                if (container.styles.isVisible()) {
                    if (createsRealStackingContext(childNode, container, root)) {
                        container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
                    }
                    else if (createsStackingContext(container.styles)) {
                        container.flags |= 2 /* CREATES_STACKING_CONTEXT */;
                    }
                    if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
                        container.flags |= 8 /* IS_LIST_OWNER */;
                    }
                    parent.elements.push(container);
                    if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
                        parseNodeTree(childNode, container, root);
                    }
                }
            }
        }
    };
    var createContainer = function (element) {
        if (isImageElement(element)) {
            return new ImageElementContainer(element);
        }
        if (isCanvasElement(element)) {
            return new CanvasElementContainer(element);
        }
        if (isSVGElement(element)) {
            return new SVGElementContainer(element);
        }
        if (isLIElement(element)) {
            return new LIElementContainer(element);
        }
        if (isOLElement(element)) {
            return new OLElementContainer(element);
        }
        if (isInputElement(element)) {
            return new InputElementContainer(element);
        }
        if (isSelectElement(element)) {
            return new SelectElementContainer(element);
        }
        if (isTextareaElement(element)) {
            return new TextareaElementContainer(element);
        }
        if (isIFrameElement(element)) {
            return new IFrameElementContainer(element);
        }
        return new ElementContainer(element);
    };
    var parseTree = function (element) {
        var container = createContainer(element);
        container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
        parseNodeTree(element, container, container);
        return container;
    };
    var createsRealStackingContext = function (node, container, root) {
        return (container.styles.isPositionedWithZIndex() ||
            container.styles.opacity < 1 ||
            container.styles.isTransformed() ||
            (isBodyElement(node) && root.styles.isTransparent()));
    };
    var createsStackingContext = function (styles) { return styles.isPositioned() || styles.isFloating(); };
    var isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
    var isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
    var isHTMLElementNode = function (node) {
        return typeof node.style !== 'undefined';
    };
    var isLIElement = function (node) { return node.tagName === 'LI'; };
    var isOLElement = function (node) { return node.tagName === 'OL'; };
    var isInputElement = function (node) { return node.tagName === 'INPUT'; };
    var isHTMLElement = function (node) { return node.tagName === 'HTML'; };
    var isSVGElement = function (node) { return node.tagName === 'svg'; };
    var isBodyElement = function (node) { return node.tagName === 'BODY'; };
    var isCanvasElement = function (node) { return node.tagName === 'CANVAS'; };
    var isImageElement = function (node) { return node.tagName === 'IMG'; };
    var isIFrameElement = function (node) { return node.tagName === 'IFRAME'; };
    var isStyleElement = function (node) { return node.tagName === 'STYLE'; };
    var isScriptElement = function (node) { return node.tagName === 'SCRIPT'; };
    var isTextareaElement = function (node) { return node.tagName === 'TEXTAREA'; };
    var isSelectElement = function (node) { return node.tagName === 'SELECT'; };

    var CounterState = /** @class */ (function () {
        function CounterState() {
            this.counters = {};
        }
        CounterState.prototype.getCounterValue = function (name) {
            var counter = this.counters[name];
            if (counter && counter.length) {
                return counter[counter.length - 1];
            }
            return 1;
        };
        CounterState.prototype.getCounterValues = function (name) {
            var counter = this.counters[name];
            return counter ? counter : [];
        };
        CounterState.prototype.pop = function (counters) {
            var _this = this;
            counters.forEach(function (counter) { return _this.counters[counter].pop(); });
        };
        CounterState.prototype.parse = function (style) {
            var _this = this;
            var counterIncrement = style.counterIncrement;
            var counterReset = style.counterReset;
            if (counterIncrement !== null) {
                counterIncrement.forEach(function (entry) {
                    var counter = _this.counters[entry.counter];
                    if (counter) {
                        counter[Math.max(0, counter.length - 1)] += entry.increment;
                    }
                });
            }
            var counterNames = [];
            counterReset.forEach(function (entry) {
                var counter = _this.counters[entry.counter];
                counterNames.push(entry.counter);
                if (!counter) {
                    counter = _this.counters[entry.counter] = [];
                }
                counter.push(entry.reset);
            });
            return counterNames;
        };
        return CounterState;
    }());
    var ROMAN_UPPER = {
        integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
        values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
    };
    var ARMENIAN = {
        integers: [
            9000,
            8000,
            7000,
            6000,
            5000,
            4000,
            3000,
            2000,
            1000,
            900,
            800,
            700,
            600,
            500,
            400,
            300,
            200,
            100,
            90,
            80,
            70,
            60,
            50,
            40,
            30,
            20,
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
        ],
        values: [
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            ''
        ]
    };
    var HEBREW = {
        integers: [
            10000,
            9000,
            8000,
            7000,
            6000,
            5000,
            4000,
            3000,
            2000,
            1000,
            400,
            300,
            200,
            100,
            90,
            80,
            70,
            60,
            50,
            40,
            30,
            20,
            19,
            18,
            17,
            16,
            15,
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
        ],
        values: [
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            ''
        ]
    };
    var GEORGIAN = {
        integers: [
            10000,
            9000,
            8000,
            7000,
            6000,
            5000,
            4000,
            3000,
            2000,
            1000,
            900,
            800,
            700,
            600,
            500,
            400,
            300,
            200,
            100,
            90,
            80,
            70,
            60,
            50,
            40,
            30,
            20,
            10,
            9,
            8,
            7,
            6,
            5,
            4,
            3,
            2,
            1
        ],
        values: [
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            '',
            ''
        ]
    };
    var createAdditiveCounter = function (value, min, max, symbols, fallback, suffix) {
        if (value < min || value > max) {
            return createCounterText(value, fallback, suffix.length > 0);
        }
        return (symbols.integers.reduce(function (string, integer, index) {
            while (value >= integer) {
                value -= integer;
                string += symbols.values[index];
            }
            return string;
        }, '') + suffix);
    };
    var createCounterStyleWithSymbolResolver = function (value, codePointRangeLength, isNumeric, resolver) {
        var string = '';
        do {
            if (!isNumeric) {
                value--;
            }
            string = resolver(value) + string;
            value /= codePointRangeLength;
        } while (value * codePointRangeLength >= codePointRangeLength);
        return string;
    };
    var createCounterStyleFromRange = function (value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
        var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
        return ((value < 0 ? '-' : '') +
            (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {
                return fromCodePoint(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
            }) +
                suffix));
    };
    var createCounterStyleFromSymbols = function (value, symbols, suffix) {
        if (suffix === void 0) { suffix = '. '; }
        var codePointRangeLength = symbols.length;
        return (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) { return symbols[Math.floor(codePoint % codePointRangeLength)]; }) + suffix);
    };
    var CJK_ZEROS = 1 << 0;
    var CJK_TEN_COEFFICIENTS = 1 << 1;
    var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
    var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
    var createCJKCounter = function (value, numbers, multipliers, negativeSign, suffix, flags) {
        if (value < -9999 || value > 9999) {
            return createCounterText(value, LIST_STYLE_TYPE.CJK_DECIMAL, suffix.length > 0);
        }
        var tmp = Math.abs(value);
        var string = suffix;
        if (tmp === 0) {
            return numbers[0] + string;
        }
        for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
            var coefficient = tmp % 10;
            if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== '') {
                string = numbers[coefficient] + string;
            }
            else if (coefficient > 1 ||
                (coefficient === 1 && digit === 0) ||
                (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS)) ||
                (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100) ||
                (coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS))) {
                string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;
            }
            else if (coefficient === 1 && digit > 0) {
                string = multipliers[digit - 1] + string;
            }
            tmp = Math.floor(tmp / 10);
        }
        return (value < 0 ? negativeSign : '') + string;
    };
    var CHINESE_INFORMAL_MULTIPLIERS = '';
    var CHINESE_FORMAL_MULTIPLIERS = '';
    var JAPANESE_NEGATIVE = '';
    var KOREAN_NEGATIVE = '';
    var createCounterText = function (value, type, appendSuffix) {
        var defaultSuffix = appendSuffix ? '. ' : '';
        var cjkSuffix = appendSuffix ? '' : '';
        var koreanSuffix = appendSuffix ? ', ' : '';
        var spaceSuffix = appendSuffix ? ' ' : '';
        switch (type) {
            case LIST_STYLE_TYPE.DISC:
                return '' + spaceSuffix;
            case LIST_STYLE_TYPE.CIRCLE:
                return '' + spaceSuffix;
            case LIST_STYLE_TYPE.SQUARE:
                return '' + spaceSuffix;
            case LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO:
                var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
                return string.length < 4 ? "0" + string : string;
            case LIST_STYLE_TYPE.CJK_DECIMAL:
                return createCounterStyleFromSymbols(value, '', cjkSuffix);
            case LIST_STYLE_TYPE.LOWER_ROMAN:
                return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
            case LIST_STYLE_TYPE.UPPER_ROMAN:
                return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.LOWER_GREEK:
                return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
            case LIST_STYLE_TYPE.LOWER_ALPHA:
                return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
            case LIST_STYLE_TYPE.UPPER_ALPHA:
                return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
            case LIST_STYLE_TYPE.ARABIC_INDIC:
                return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
            case LIST_STYLE_TYPE.ARMENIAN:
            case LIST_STYLE_TYPE.UPPER_ARMENIAN:
                return createAdditiveCounter(value, 1, 9999, ARMENIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.LOWER_ARMENIAN:
                return createAdditiveCounter(value, 1, 9999, ARMENIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
            case LIST_STYLE_TYPE.BENGALI:
                return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
            case LIST_STYLE_TYPE.CAMBODIAN:
            case LIST_STYLE_TYPE.KHMER:
                return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
            case LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH:
                return createCounterStyleFromSymbols(value, '', cjkSuffix);
            case LIST_STYLE_TYPE.CJK_HEAVENLY_STEM:
                return createCounterStyleFromSymbols(value, '', cjkSuffix);
            case LIST_STYLE_TYPE.CJK_IDEOGRAPHIC:
            case LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL:
                return createCJKCounter(value, '', CHINESE_INFORMAL_MULTIPLIERS, '', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL:
                return createCJKCounter(value, '', CHINESE_FORMAL_MULTIPLIERS, '', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL:
                return createCJKCounter(value, '', CHINESE_INFORMAL_MULTIPLIERS, '', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL:
                return createCJKCounter(value, '', CHINESE_FORMAL_MULTIPLIERS, '', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
            case LIST_STYLE_TYPE.JAPANESE_INFORMAL:
                return createCJKCounter(value, '', '', JAPANESE_NEGATIVE, cjkSuffix, 0);
            case LIST_STYLE_TYPE.JAPANESE_FORMAL:
                return createCJKCounter(value, '', '', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL:
                return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL:
                return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, 0);
            case LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL:
                return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
            case LIST_STYLE_TYPE.DEVANAGARI:
                return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);
            case LIST_STYLE_TYPE.GEORGIAN:
                return createAdditiveCounter(value, 1, 19999, GEORGIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.GUJARATI:
                return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);
            case LIST_STYLE_TYPE.GURMUKHI:
                return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);
            case LIST_STYLE_TYPE.HEBREW:
                return createAdditiveCounter(value, 1, 10999, HEBREW, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
            case LIST_STYLE_TYPE.HIRAGANA:
                return createCounterStyleFromSymbols(value, '');
            case LIST_STYLE_TYPE.HIRAGANA_IROHA:
                return createCounterStyleFromSymbols(value, '');
            case LIST_STYLE_TYPE.KANNADA:
                return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);
            case LIST_STYLE_TYPE.KATAKANA:
                return createCounterStyleFromSymbols(value, '', cjkSuffix);
            case LIST_STYLE_TYPE.KATAKANA_IROHA:
                return createCounterStyleFromSymbols(value, '', cjkSuffix);
            case LIST_STYLE_TYPE.LAO:
                return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);
            case LIST_STYLE_TYPE.MONGOLIAN:
                return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);
            case LIST_STYLE_TYPE.MYANMAR:
                return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);
            case LIST_STYLE_TYPE.ORIYA:
                return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);
            case LIST_STYLE_TYPE.PERSIAN:
                return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);
            case LIST_STYLE_TYPE.TAMIL:
                return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);
            case LIST_STYLE_TYPE.TELUGU:
                return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);
            case LIST_STYLE_TYPE.THAI:
                return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);
            case LIST_STYLE_TYPE.TIBETAN:
                return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);
            case LIST_STYLE_TYPE.DECIMAL:
            default:
                return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
        }
    };

    var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';
    var DocumentCloner = /** @class */ (function () {
        function DocumentCloner(element, options) {
            this.options = options;
            this.scrolledElements = [];
            this.referenceElement = element;
            this.counters = new CounterState();
            this.quoteDepth = 0;
            if (!element.ownerDocument) {
                throw new Error('Cloned element does not have an owner document');
            }
            this.documentElement = this.cloneNode(element.ownerDocument.documentElement);
        }
        DocumentCloner.prototype.toIFrame = function (ownerDocument, windowSize) {
            var _this = this;
            var iframe = createIFrameContainer(ownerDocument, windowSize);
            if (!iframe.contentWindow) {
                return Promise.reject("Unable to find iframe window");
            }
            var scrollX = ownerDocument.defaultView.pageXOffset;
            var scrollY = ownerDocument.defaultView.pageYOffset;
            var cloneWindow = iframe.contentWindow;
            var documentClone = cloneWindow.document;
            /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
             if window url is about:blank, we can assign the url to current by writing onto the document
             */
            var iframeLoad = iframeLoader(iframe).then(function () {
                _this.scrolledElements.forEach(restoreNodeScroll);
                if (cloneWindow) {
                    cloneWindow.scrollTo(windowSize.left, windowSize.top);
                    if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) &&
                        (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                        documentClone.documentElement.style.top = -windowSize.top + 'px';
                        documentClone.documentElement.style.left = -windowSize.left + 'px';
                        documentClone.documentElement.style.position = 'absolute';
                    }
                }
                var onclone = _this.options.onclone;
                if (typeof _this.clonedReferenceElement === 'undefined') {
                    return Promise.reject("Error finding the " + _this.referenceElement.nodeName + " in the cloned document");
                }
                if (typeof onclone === 'function') {
                    return Promise.resolve()
                        .then(function () { return onclone(documentClone); })
                        .then(function () { return iframe; });
                }
                return iframe;
            });
            documentClone.open();
            documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
            // Chrome scrolls the parent document for some reason after the write to the cloned window???
            restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
            documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
            documentClone.close();
            return iframeLoad;
        };
        DocumentCloner.prototype.createElementClone = function (node) {
            if (isCanvasElement(node)) {
                return this.createCanvasClone(node);
            }
            /*
            if (isIFrameElement(node)) {
                return this.createIFrameClone(node);
            }
    */
            if (isStyleElement(node)) {
                return this.createStyleClone(node);
            }
            return node.cloneNode(false);
        };
        DocumentCloner.prototype.createStyleClone = function (node) {
            try {
                var sheet = node.sheet;
                if (sheet && sheet.cssRules) {
                    var css = [].slice.call(sheet.cssRules, 0).reduce(function (css, rule) {
                        if (rule && typeof rule.cssText === 'string') {
                            return css + rule.cssText;
                        }
                        return css;
                    }, '');
                    var style = node.cloneNode(false);
                    style.textContent = css;
                    return style;
                }
            }
            catch (e) {
                // accessing node.sheet.cssRules throws a DOMException
                Logger.getInstance(this.options.id).error('Unable to access cssRules property', e);
                if (e.name !== 'SecurityError') {
                    throw e;
                }
            }
            return node.cloneNode(false);
        };
        DocumentCloner.prototype.createCanvasClone = function (canvas) {
            if (this.options.inlineImages && canvas.ownerDocument) {
                var img = canvas.ownerDocument.createElement('img');
                try {
                    img.src = canvas.toDataURL();
                    return img;
                }
                catch (e) {
                    Logger.getInstance(this.options.id).info("Unable to clone canvas contents, canvas is tainted");
                }
            }
            var clonedCanvas = canvas.cloneNode(false);
            try {
                clonedCanvas.width = canvas.width;
                clonedCanvas.height = canvas.height;
                var ctx = canvas.getContext('2d');
                var clonedCtx = clonedCanvas.getContext('2d');
                if (clonedCtx) {
                    if (ctx) {
                        clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                    }
                    else {
                        clonedCtx.drawImage(canvas, 0, 0);
                    }
                }
                return clonedCanvas;
            }
            catch (e) { }
            return clonedCanvas;
        };
        /*
        createIFrameClone(iframe: HTMLIFrameElement) {
            const tempIframe = <HTMLIFrameElement>iframe.cloneNode(false);
            const iframeKey = generateIframeKey();
            tempIframe.setAttribute('data-html2canvas-internal-iframe-key', iframeKey);

            const {width, height} = parseBounds(iframe);

            this.resourceLoader.cache[iframeKey] = getIframeDocumentElement(iframe, this.options)
                .then(documentElement => {
                    return this.renderer(
                        documentElement,
                        {
                            allowTaint: this.options.allowTaint,
                            backgroundColor: '#ffffff',
                            canvas: null,
                            imageTimeout: this.options.imageTimeout,
                            logging: this.options.logging,
                            proxy: this.options.proxy,
                            removeContainer: this.options.removeContainer,
                            scale: this.options.scale,
                            foreignObjectRendering: this.options.foreignObjectRendering,
                            useCORS: this.options.useCORS,
                            target: new CanvasRenderer(),
                            width,
                            height,
                            x: 0,
                            y: 0,
                            windowWidth: documentElement.ownerDocument.defaultView.innerWidth,
                            windowHeight: documentElement.ownerDocument.defaultView.innerHeight,
                            scrollX: documentElement.ownerDocument.defaultView.pageXOffset,
                            scrollY: documentElement.ownerDocument.defaultView.pageYOffset
                        },
                    );
                })
                .then(
                    (canvas: HTMLCanvasElement) =>
                        new Promise((resolve, reject) => {
                            const iframeCanvas = document.createElement('img');
                            iframeCanvas.onload = () => resolve(canvas);
                            iframeCanvas.onerror = (event) => {
                                // Empty iframes may result in empty "data:," URLs, which are invalid from the <img>'s point of view
                                // and instead of `onload` cause `onerror` and unhandled rejection warnings
                                // https://github.com/niklasvh/html2canvas/issues/1502
                                iframeCanvas.src == 'data:,' ? resolve(canvas) : reject(event);
                            };
                            iframeCanvas.src = canvas.toDataURL();
                            if (tempIframe.parentNode && iframe.ownerDocument && iframe.ownerDocument.defaultView) {
                                tempIframe.parentNode.replaceChild(
                                    copyCSSStyles(
                                        iframe.ownerDocument.defaultView.getComputedStyle(iframe),
                                        iframeCanvas
                                    ),
                                    tempIframe
                                );
                            }
                        })
                );
            return tempIframe;
        }
    */
        DocumentCloner.prototype.cloneNode = function (node) {
            if (isTextNode(node)) {
                return document.createTextNode(node.data);
            }
            if (!node.ownerDocument) {
                return node.cloneNode(false);
            }
            var window = node.ownerDocument.defaultView;
            if (isHTMLElementNode(node) && window) {
                var clone = this.createElementClone(node);
                var style = window.getComputedStyle(node);
                var styleBefore = window.getComputedStyle(node, ':before');
                var styleAfter = window.getComputedStyle(node, ':after');
                if (this.referenceElement === node) {
                    this.clonedReferenceElement = clone;
                }
                if (isBodyElement(clone)) {
                    createPseudoHideStyles(clone);
                }
                var counters = this.counters.parse(new CSSParsedCounterDeclaration(style));
                var before_1 = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
                for (var child = node.firstChild; child; child = child.nextSibling) {
                    if (!isElementNode(child) ||
                        (!isScriptElement(child) &&
                            !child.hasAttribute(IGNORE_ATTRIBUTE) &&
                            (typeof this.options.ignoreElements !== 'function' || !this.options.ignoreElements(child)))) {
                        if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
                            clone.appendChild(this.cloneNode(child));
                        }
                    }
                }
                if (before_1) {
                    clone.insertBefore(before_1, clone.firstChild);
                }
                var after_1 = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
                if (after_1) {
                    clone.appendChild(after_1);
                }
                this.counters.pop(counters);
                if (style && this.options.copyStyles && !isIFrameElement(node)) {
                    copyCSSStyles(style, clone);
                }
                //this.inlineAllImages(clone);
                if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
                    this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
                }
                if ((isTextareaElement(node) || isSelectElement(node)) &&
                    (isTextareaElement(clone) || isSelectElement(clone))) {
                    clone.value = node.value;
                }
                return clone;
            }
            return node.cloneNode(false);
        };
        DocumentCloner.prototype.resolvePseudoContent = function (node, clone, style, pseudoElt) {
            var _this = this;
            if (!style) {
                return;
            }
            var value = style.content;
            var document = clone.ownerDocument;
            if (!document || !value || value === 'none' || value === '-moz-alt-content' || style.display === 'none') {
                return;
            }
            this.counters.parse(new CSSParsedCounterDeclaration(style));
            var declaration = new CSSParsedPseudoDeclaration(style);
            var anonymousReplacedElement = document.createElement('html2canvaspseudoelement');
            copyCSSStyles(style, anonymousReplacedElement);
            declaration.content.forEach(function (token) {
                if (token.type === TokenType.STRING_TOKEN) {
                    anonymousReplacedElement.appendChild(document.createTextNode(token.value));
                }
                else if (token.type === TokenType.URL_TOKEN) {
                    var img = document.createElement('img');
                    img.src = token.value;
                    img.style.opacity = '1';
                    anonymousReplacedElement.appendChild(img);
                }
                else if (token.type === TokenType.FUNCTION) {
                    if (token.name === 'attr') {
                        var attr = token.values.filter(isIdentToken);
                        if (attr.length) {
                            anonymousReplacedElement.appendChild(document.createTextNode(node.getAttribute(attr[0].value) || ''));
                        }
                    }
                    else if (token.name === 'counter') {
                        var _a = token.values.filter(nonFunctionArgSeperator), counter = _a[0], counterStyle = _a[1];
                        if (counter && isIdentToken(counter)) {
                            var counterState = _this.counters.getCounterValue(counter.value);
                            var counterType = counterStyle && isIdentToken(counterStyle)
                                ? listStyleType.parse(counterStyle.value)
                                : LIST_STYLE_TYPE.DECIMAL;
                            anonymousReplacedElement.appendChild(document.createTextNode(createCounterText(counterState, counterType, false)));
                        }
                    }
                    else if (token.name === 'counters') {
                        var _b = token.values.filter(nonFunctionArgSeperator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
                        if (counter && isIdentToken(counter)) {
                            var counterStates = _this.counters.getCounterValues(counter.value);
                            var counterType_1 = counterStyle && isIdentToken(counterStyle)
                                ? listStyleType.parse(counterStyle.value)
                                : LIST_STYLE_TYPE.DECIMAL;
                            var separator = delim && delim.type === TokenType.STRING_TOKEN ? delim.value : '';
                            var text = counterStates
                                .map(function (value) { return createCounterText(value, counterType_1, false); })
                                .join(separator);
                            anonymousReplacedElement.appendChild(document.createTextNode(text));
                        }
                    }
                }
                else if (token.type === TokenType.IDENT_TOKEN) {
                    switch (token.value) {
                        case 'open-quote':
                            anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                            break;
                        case 'close-quote':
                            anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                            break;
                        default:
                        //    console.log('ident', token, declaration);
                    }
                }
            });
            anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            clone.className +=
                pseudoElt === PseudoElementType.BEFORE
                    ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE
                    : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
            return anonymousReplacedElement;
        };
        return DocumentCloner;
    }());
    var PseudoElementType;
    (function (PseudoElementType) {
        PseudoElementType[PseudoElementType["BEFORE"] = 0] = "BEFORE";
        PseudoElementType[PseudoElementType["AFTER"] = 1] = "AFTER";
    })(PseudoElementType || (PseudoElementType = {}));
    var createIFrameContainer = function (ownerDocument, bounds) {
        var cloneIframeContainer = ownerDocument.createElement('iframe');
        cloneIframeContainer.className = 'html2canvas-container';
        cloneIframeContainer.style.visibility = 'hidden';
        cloneIframeContainer.style.position = 'fixed';
        cloneIframeContainer.style.left = '-10000px';
        cloneIframeContainer.style.top = '0px';
        cloneIframeContainer.style.border = '0';
        cloneIframeContainer.width = bounds.width.toString();
        cloneIframeContainer.height = bounds.height.toString();
        cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it
        cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');
        ownerDocument.body.appendChild(cloneIframeContainer);
        return cloneIframeContainer;
    };
    var iframeLoader = function (iframe) {
        return new Promise(function (resolve, reject) {
            var cloneWindow = iframe.contentWindow;
            if (!cloneWindow) {
                return reject("No window assigned for iframe");
            }
            var documentClone = cloneWindow.document;
            cloneWindow.onload = iframe.onload = documentClone.onreadystatechange = function () {
                cloneWindow.onload = iframe.onload = documentClone.onreadystatechange = null;
                var interval = setInterval(function () {
                    if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {
                        clearInterval(interval);
                        resolve(iframe);
                    }
                }, 50);
            };
        });
    };
    var copyCSSStyles = function (style, target) {
        // Edge does not provide value for cssText
        for (var i = style.length - 1; i >= 0; i--) {
            var property = style.item(i);
            // Safari shows pseudoelements if content is set
            if (property !== 'content') {
                target.style.setProperty(property, style.getPropertyValue(property));
            }
        }
        return target;
    };
    var serializeDoctype = function (doctype) {
        var str = '';
        if (doctype) {
            str += '<!DOCTYPE ';
            if (doctype.name) {
                str += doctype.name;
            }
            if (doctype.internalSubset) {
                str += doctype.internalSubset;
            }
            if (doctype.publicId) {
                str += "\"" + doctype.publicId + "\"";
            }
            if (doctype.systemId) {
                str += "\"" + doctype.systemId + "\"";
            }
            str += '>';
        }
        return str;
    };
    var restoreOwnerScroll = function (ownerDocument, x, y) {
        if (ownerDocument &&
            ownerDocument.defaultView &&
            (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
            ownerDocument.defaultView.scrollTo(x, y);
        }
    };
    var restoreNodeScroll = function (_a) {
        var element = _a[0], x = _a[1], y = _a[2];
        element.scrollLeft = x;
        element.scrollTop = y;
    };
    var PSEUDO_BEFORE = ':before';
    var PSEUDO_AFTER = ':after';
    var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';
    var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';
    var PSEUDO_HIDE_ELEMENT_STYLE = "{\n    content: \"\" !important;\n    display: none !important;\n}";
    var createPseudoHideStyles = function (body) {
        createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
    };
    var createStyles = function (body, styles) {
        var document = body.ownerDocument;
        if (document) {
            var style = document.createElement('style');
            style.textContent = styles;
            body.appendChild(style);
        }
    };

    var PathType;
    (function (PathType) {
        PathType[PathType["VECTOR"] = 0] = "VECTOR";
        PathType[PathType["BEZIER_CURVE"] = 1] = "BEZIER_CURVE";
    })(PathType || (PathType = {}));
    var equalPath = function (a, b) {
        if (a.length === b.length) {
            return a.some(function (v, i) { return v === b[i]; });
        }
        return false;
    };
    var transformPath = function (path, deltaX, deltaY, deltaW, deltaH) {
        return path.map(function (point, index) {
            switch (index) {
                case 0:
                    return point.add(deltaX, deltaY);
                case 1:
                    return point.add(deltaX + deltaW, deltaY);
                case 2:
                    return point.add(deltaX + deltaW, deltaY + deltaH);
                case 3:
                    return point.add(deltaX, deltaY + deltaH);
            }
            return point;
        });
    };

    var Vector = /** @class */ (function () {
        function Vector(x, y) {
            this.type = PathType.VECTOR;
            this.x = x;
            this.y = y;
        }
        Vector.prototype.add = function (deltaX, deltaY) {
            return new Vector(this.x + deltaX, this.y + deltaY);
        };
        return Vector;
    }());

    var lerp = function (a, b, t) {
        return new Vector(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
    };
    var BezierCurve = /** @class */ (function () {
        function BezierCurve(start, startControl, endControl, end) {
            this.type = PathType.BEZIER_CURVE;
            this.start = start;
            this.startControl = startControl;
            this.endControl = endControl;
            this.end = end;
        }
        BezierCurve.prototype.subdivide = function (t, firstHalf) {
            var ab = lerp(this.start, this.startControl, t);
            var bc = lerp(this.startControl, this.endControl, t);
            var cd = lerp(this.endControl, this.end, t);
            var abbc = lerp(ab, bc, t);
            var bccd = lerp(bc, cd, t);
            var dest = lerp(abbc, bccd, t);
            return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);
        };
        BezierCurve.prototype.add = function (deltaX, deltaY) {
            return new BezierCurve(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
        };
        BezierCurve.prototype.reverse = function () {
            return new BezierCurve(this.end, this.endControl, this.startControl, this.start);
        };
        return BezierCurve;
    }());
    var isBezierCurve = function (path) { return path.type === PathType.BEZIER_CURVE; };

    var BoundCurves = /** @class */ (function () {
        function BoundCurves(element) {
            var styles = element.styles;
            var bounds = element.bounds;
            var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a[0], tlv = _a[1];
            var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
            var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
            var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
            var factors = [];
            factors.push((tlh + trh) / bounds.width);
            factors.push((blh + brh) / bounds.width);
            factors.push((tlv + blv) / bounds.height);
            factors.push((trv + brv) / bounds.height);
            var maxFactor = Math.max.apply(Math, factors);
            if (maxFactor > 1) {
                tlh /= maxFactor;
                tlv /= maxFactor;
                trh /= maxFactor;
                trv /= maxFactor;
                brh /= maxFactor;
                brv /= maxFactor;
                blh /= maxFactor;
                blv /= maxFactor;
            }
            var topWidth = bounds.width - trh;
            var rightHeight = bounds.height - brv;
            var bottomWidth = bounds.width - brh;
            var leftHeight = bounds.height - blv;
            var borderTopWidth = styles.borderTopWidth;
            var borderRightWidth = styles.borderRightWidth;
            var borderBottomWidth = styles.borderBottomWidth;
            var borderLeftWidth = styles.borderLeftWidth;
            var paddingTop = getAbsoluteValue(styles.paddingTop, element.bounds.width);
            var paddingRight = getAbsoluteValue(styles.paddingRight, element.bounds.width);
            var paddingBottom = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
            var paddingLeft = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
            this.topLeftBorderBox =
                tlh > 0 || tlv > 0
                    ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT)
                    : new Vector(bounds.left, bounds.top);
            this.topRightBorderBox =
                trh > 0 || trv > 0
                    ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT)
                    : new Vector(bounds.left + bounds.width, bounds.top);
            this.bottomRightBorderBox =
                brh > 0 || brv > 0
                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT)
                    : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
            this.bottomLeftBorderBox =
                blh > 0 || blv > 0
                    ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT)
                    : new Vector(bounds.left, bounds.top + bounds.height);
            this.topLeftPaddingBox =
                tlh > 0 || tlv > 0
                    ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + borderTopWidth, Math.max(0, tlh - borderLeftWidth), Math.max(0, tlv - borderTopWidth), CORNER.TOP_LEFT)
                    : new Vector(bounds.left + borderLeftWidth, bounds.top + borderTopWidth);
            this.topRightPaddingBox =
                trh > 0 || trv > 0
                    ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth), bounds.top + borderTopWidth, topWidth > bounds.width + borderLeftWidth ? 0 : trh - borderLeftWidth, trv - borderTopWidth, CORNER.TOP_RIGHT)
                    : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + borderTopWidth);
            this.bottomRightPaddingBox =
                brh > 0 || brv > 0
                    ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth), Math.max(0, brh - borderRightWidth), brv - borderBottomWidth, CORNER.BOTTOM_RIGHT)
                    : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + bounds.height - borderBottomWidth);
            this.bottomLeftPaddingBox =
                blh > 0 || blv > 0
                    ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + leftHeight, Math.max(0, blh - borderLeftWidth), blv - borderBottomWidth, CORNER.BOTTOM_LEFT)
                    : new Vector(bounds.left + borderLeftWidth, bounds.top + bounds.height - borderBottomWidth);
            this.topLeftContentBox =
                tlh > 0 || tlv > 0
                    ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop, Math.max(0, tlh - (borderLeftWidth + paddingLeft)), Math.max(0, tlv - (borderTopWidth + paddingTop)), CORNER.TOP_LEFT)
                    : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop);
            this.topRightContentBox =
                trh > 0 || trv > 0
                    ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth + paddingLeft), bounds.top + borderTopWidth + paddingTop, topWidth > bounds.width + borderLeftWidth + paddingLeft ? 0 : trh - borderLeftWidth + paddingLeft, trv - (borderTopWidth + paddingTop), CORNER.TOP_RIGHT)
                    : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + borderTopWidth + paddingTop);
            this.bottomRightContentBox =
                brh > 0 || brv > 0
                    ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth + paddingLeft)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth + paddingTop), Math.max(0, brh - (borderRightWidth + paddingRight)), brv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_RIGHT)
                    : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
            this.bottomLeftContentBox =
                blh > 0 || blv > 0
                    ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth + paddingLeft)), blv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_LEFT)
                    : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
        }
        return BoundCurves;
    }());
    var CORNER;
    (function (CORNER) {
        CORNER[CORNER["TOP_LEFT"] = 0] = "TOP_LEFT";
        CORNER[CORNER["TOP_RIGHT"] = 1] = "TOP_RIGHT";
        CORNER[CORNER["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
        CORNER[CORNER["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
    })(CORNER || (CORNER = {}));
    var getCurvePoints = function (x, y, r1, r2, position) {
        var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
        var ox = r1 * kappa; // control point offset horizontal
        var oy = r2 * kappa; // control point offset vertical
        var xm = x + r1; // x-middle
        var ym = y + r2; // y-middle
        switch (position) {
            case CORNER.TOP_LEFT:
                return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
            case CORNER.TOP_RIGHT:
                return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
            case CORNER.BOTTOM_RIGHT:
                return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
            case CORNER.BOTTOM_LEFT:
            default:
                return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
        }
    };
    var calculateBorderBoxPath = function (curves) {
        return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
    };
    var calculateContentBoxPath = function (curves) {
        return [
            curves.topLeftContentBox,
            curves.topRightContentBox,
            curves.bottomRightContentBox,
            curves.bottomLeftContentBox
        ];
    };
    var calculatePaddingBoxPath = function (curves) {
        return [
            curves.topLeftPaddingBox,
            curves.topRightPaddingBox,
            curves.bottomRightPaddingBox,
            curves.bottomLeftPaddingBox
        ];
    };

    var TransformEffect = /** @class */ (function () {
        function TransformEffect(offsetX, offsetY, matrix) {
            this.type = 0 /* TRANSFORM */;
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            this.matrix = matrix;
            this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
        }
        return TransformEffect;
    }());
    var ClipEffect = /** @class */ (function () {
        function ClipEffect(path, target) {
            this.type = 1 /* CLIP */;
            this.target = target;
            this.path = path;
        }
        return ClipEffect;
    }());
    var isTransformEffect = function (effect) {
        return effect.type === 0 /* TRANSFORM */;
    };
    var isClipEffect = function (effect) { return effect.type === 1 /* CLIP */; };

    var StackingContext = /** @class */ (function () {
        function StackingContext(container) {
            this.element = container;
            this.inlineLevel = [];
            this.nonInlineLevel = [];
            this.negativeZIndex = [];
            this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
            this.positiveZIndex = [];
            this.nonPositionedFloats = [];
            this.nonPositionedInlineLevel = [];
        }
        return StackingContext;
    }());
    var ElementPaint = /** @class */ (function () {
        function ElementPaint(element, parentStack) {
            this.container = element;
            this.effects = parentStack.slice(0);
            this.curves = new BoundCurves(element);
            if (element.styles.transform !== null) {
                var offsetX = element.bounds.left + element.styles.transformOrigin[0].number;
                var offsetY = element.bounds.top + element.styles.transformOrigin[1].number;
                var matrix = element.styles.transform;
                this.effects.push(new TransformEffect(offsetX, offsetY, matrix));
            }
            if (element.styles.overflowX !== OVERFLOW.VISIBLE) {
                var borderBox = calculateBorderBoxPath(this.curves);
                var paddingBox = calculatePaddingBoxPath(this.curves);
                if (equalPath(borderBox, paddingBox)) {
                    this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
                }
                else {
                    this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */));
                    this.effects.push(new ClipEffect(paddingBox, 4 /* CONTENT */));
                }
            }
        }
        ElementPaint.prototype.getParentEffects = function () {
            var effects = this.effects.slice(0);
            if (this.container.styles.overflowX !== OVERFLOW.VISIBLE) {
                var borderBox = calculateBorderBoxPath(this.curves);
                var paddingBox = calculatePaddingBoxPath(this.curves);
                if (!equalPath(borderBox, paddingBox)) {
                    effects.push(new ClipEffect(paddingBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
                }
            }
            return effects;
        };
        return ElementPaint;
    }());
    var parseStackTree = function (parent, stackingContext, realStackingContext, listItems) {
        parent.container.elements.forEach(function (child) {
            var treatAsRealStackingContext = contains(child.flags, 4 /* CREATES_REAL_STACKING_CONTEXT */);
            var createsStackingContext = contains(child.flags, 2 /* CREATES_STACKING_CONTEXT */);
            var paintContainer = new ElementPaint(child, parent.getParentEffects());
            if (contains(child.styles.display, 2048 /* LIST_ITEM */)) {
                listItems.push(paintContainer);
            }
            var listOwnerItems = contains(child.flags, 8 /* IS_LIST_OWNER */) ? [] : listItems;
            if (treatAsRealStackingContext || createsStackingContext) {
                var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
                var stack = new StackingContext(paintContainer);
                if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
                    var order_1 = child.styles.zIndex.order;
                    if (order_1 < 0) {
                        var index_1 = 0;
                        parentStack.negativeZIndex.some(function (current, i) {
                            if (order_1 > current.element.container.styles.zIndex.order) {
                                index_1 = i;
                                return true;
                            }
                            return false;
                        });
                        parentStack.negativeZIndex.splice(index_1, 0, stack);
                    }
                    else if (order_1 > 0) {
                        var index_2 = 0;
                        parentStack.positiveZIndex.some(function (current, i) {
                            if (order_1 > current.element.container.styles.zIndex.order) {
                                index_2 = i + 1;
                                return true;
                            }
                            return false;
                        });
                        parentStack.positiveZIndex.splice(index_2, 0, stack);
                    }
                    else {
                        parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
                    }
                }
                else {
                    if (child.styles.isFloating()) {
                        parentStack.nonPositionedFloats.push(stack);
                    }
                    else {
                        parentStack.nonPositionedInlineLevel.push(stack);
                    }
                }
                parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
            }
            else {
                if (child.styles.isInlineLevel()) {
                    stackingContext.inlineLevel.push(paintContainer);
                }
                else {
                    stackingContext.nonInlineLevel.push(paintContainer);
                }
                parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
            }
            if (contains(child.flags, 8 /* IS_LIST_OWNER */)) {
                processListItems(child, listOwnerItems);
            }
        });
    };
    var processListItems = function (owner, elements) {
        var numbering = owner instanceof OLElementContainer ? owner.start : 1;
        var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
        for (var i = 0; i < elements.length; i++) {
            var item = elements[i];
            if (item.container instanceof LIElementContainer &&
                typeof item.container.value === 'number' &&
                item.container.value !== 0) {
                numbering = item.container.value;
            }
            item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
            numbering += reversed ? -1 : 1;
        }
    };
    var parseStackingContexts = function (container) {
        var paintContainer = new ElementPaint(container, []);
        var root = new StackingContext(paintContainer);
        var listItems = [];
        parseStackTree(paintContainer, root, root, listItems);
        processListItems(paintContainer.container, listItems);
        return root;
    };

    var parsePathForBorder = function (curves, borderSide) {
        switch (borderSide) {
            case 0:
                return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
            case 1:
                return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
            case 2:
                return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
            case 3:
            default:
                return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
        }
    };
    var createPathFromCurves = function (outer1, inner1, outer2, inner2) {
        var path = [];
        if (isBezierCurve(outer1)) {
            path.push(outer1.subdivide(0.5, false));
        }
        else {
            path.push(outer1);
        }
        if (isBezierCurve(outer2)) {
            path.push(outer2.subdivide(0.5, true));
        }
        else {
            path.push(outer2);
        }
        if (isBezierCurve(inner2)) {
            path.push(inner2.subdivide(0.5, true).reverse());
        }
        else {
            path.push(inner2);
        }
        if (isBezierCurve(inner1)) {
            path.push(inner1.subdivide(0.5, false).reverse());
        }
        else {
            path.push(inner1);
        }
        return path;
    };

    var paddingBox = function (element) {
        var bounds = element.bounds;
        var styles = element.styles;
        return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
    };
    var contentBox = function (element) {
        var styles = element.styles;
        var bounds = element.bounds;
        var paddingLeft = getAbsoluteValue(styles.paddingLeft, bounds.width);
        var paddingRight = getAbsoluteValue(styles.paddingRight, bounds.width);
        var paddingTop = getAbsoluteValue(styles.paddingTop, bounds.width);
        var paddingBottom = getAbsoluteValue(styles.paddingBottom, bounds.width);
        return bounds.add(paddingLeft + styles.borderLeftWidth, paddingTop + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft + paddingRight), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop + paddingBottom));
    };

    var calculateBackgroundPositioningArea = function (backgroundOrigin, element) {
        if (backgroundOrigin === 0 /* BORDER_BOX */) {
            return element.bounds;
        }
        if (backgroundOrigin === 2 /* CONTENT_BOX */) {
            return contentBox(element);
        }
        return paddingBox(element);
    };
    var calculateBackgroundPaintingArea = function (backgroundClip, element) {
        if (backgroundClip === BACKGROUND_CLIP.BORDER_BOX) {
            return element.bounds;
        }
        if (backgroundClip === BACKGROUND_CLIP.CONTENT_BOX) {
            return contentBox(element);
        }
        return paddingBox(element);
    };
    var calculateBackgroundRendering = function (container, index, intrinsicSize) {
        var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
        var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
        var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
        var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
        var position = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
        var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
        var offsetX = Math.round(backgroundPositioningArea.left + position[0]);
        var offsetY = Math.round(backgroundPositioningArea.top + position[1]);
        return [path, offsetX, offsetY, sizeWidth, sizeHeight];
    };
    var isAuto = function (token) { return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO; };
    var hasIntrinsicValue = function (value) { return typeof value === 'number'; };
    var calculateBackgroundSize = function (size, _a, bounds) {
        var intrinsicWidth = _a[0], intrinsicHeight = _a[1], intrinsicProportion = _a[2];
        var first = size[0], second = size[1];
        if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
            return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
        }
        var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
        if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
            if (hasIntrinsicValue(intrinsicProportion)) {
                var targetRatio = bounds.width / bounds.height;
                return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER)
                    ? [bounds.width, bounds.width / intrinsicProportion]
                    : [bounds.height * intrinsicProportion, bounds.height];
            }
            return [bounds.width, bounds.height];
        }
        var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
        var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
        var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
        // If the background-size is auto or auto auto:
        if (isAuto(first) && (!second || isAuto(second))) {
            // If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.
            if (hasIntrinsicWidth && hasIntrinsicHeight) {
                return [intrinsicWidth, intrinsicHeight];
            }
            // If the image has no intrinsic dimensions and has no intrinsic proportions,
            // it's rendered at the size of the background positioning area.
            if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
                return [bounds.width, bounds.height];
            }
            // TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.
            // If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.
            // The other dimension is computed using the specified dimension and the intrinsic proportions.
            if (hasIntrinsicDimensions && hasIntrinsicProportion) {
                var width_1 = hasIntrinsicWidth
                    ? intrinsicWidth
                    : intrinsicHeight * intrinsicProportion;
                var height_1 = hasIntrinsicHeight
                    ? intrinsicHeight
                    : intrinsicWidth / intrinsicProportion;
                return [width_1, height_1];
            }
            // If the image has only one intrinsic dimension but has no intrinsic proportions,
            // it's rendered using the specified dimension and the other dimension of the background positioning area.
            var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
            var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
            return [width_2, height_2];
        }
        // If the image has intrinsic proportions, it's stretched to the specified dimension.
        // The unspecified dimension is computed using the specified dimension and the intrinsic proportions.
        if (hasIntrinsicProportion) {
            var width_3 = 0;
            var height_3 = 0;
            if (isLengthPercentage(first)) {
                width_3 = getAbsoluteValue(first, bounds.width);
            }
            else if (isLengthPercentage(second)) {
                height_3 = getAbsoluteValue(second, bounds.height);
            }
            if (isAuto(first)) {
                width_3 = height_3 * intrinsicProportion;
            }
            else if (!second || isAuto(second)) {
                height_3 = width_3 / intrinsicProportion;
            }
            return [width_3, height_3];
        }
        // If the image has no intrinsic proportions, it's stretched to the specified dimension.
        // The unspecified dimension is computed using the image's corresponding intrinsic dimension,
        // if there is one. If there is no such intrinsic dimension,
        // it becomes the corresponding dimension of the background positioning area.
        var width = null;
        var height = null;
        if (isLengthPercentage(first)) {
            width = getAbsoluteValue(first, bounds.width);
        }
        else if (second && isLengthPercentage(second)) {
            height = getAbsoluteValue(second, bounds.height);
        }
        if (width !== null && (!second || isAuto(second))) {
            height =
                hasIntrinsicWidth && hasIntrinsicHeight
                    ? (width / intrinsicWidth) * intrinsicHeight
                    : bounds.height;
        }
        if (height !== null && isAuto(first)) {
            width =
                hasIntrinsicWidth && hasIntrinsicHeight
                    ? (height / intrinsicHeight) * intrinsicWidth
                    : bounds.width;
        }
        if (width !== null && height !== null) {
            return [width, height];
        }
        throw new Error("Unable to calculate background-size for element");
    };
    var getBackgroundValueForIndex = function (values, index) {
        var value = values[index];
        if (typeof value === 'undefined') {
            return values[0];
        }
        return value;
    };
    var calculateBackgroundRepeatPath = function (repeat, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {
        var x = _a[0], y = _a[1];
        var width = _b[0], height = _b[1];
        switch (repeat) {
            case BACKGROUND_REPEAT.REPEAT_X:
                return [
                    new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
                    new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
                    new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
                    new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
                ];
            case BACKGROUND_REPEAT.REPEAT_Y:
                return [
                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
                ];
            case BACKGROUND_REPEAT.NO_REPEAT:
                return [
                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
                ];
            default:
                return [
                    new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
                    new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
                    new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
                    new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
                ];
        }
    };

    var SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

    var SAMPLE_TEXT = 'Hidden Text';
    var FontMetrics = /** @class */ (function () {
        function FontMetrics(document) {
            this._data = {};
            this._document = document;
        }
        FontMetrics.prototype.parseMetrics = function (fontFamily, fontSize) {
            var container = this._document.createElement('div');
            var img = this._document.createElement('img');
            var span = this._document.createElement('span');
            var body = this._document.body;
            container.style.visibility = 'hidden';
            container.style.fontFamily = fontFamily;
            container.style.fontSize = fontSize;
            container.style.margin = '0';
            container.style.padding = '0';
            body.appendChild(container);
            img.src = SMALL_IMAGE;
            img.width = 1;
            img.height = 1;
            img.style.margin = '0';
            img.style.padding = '0';
            img.style.verticalAlign = 'baseline';
            span.style.fontFamily = fontFamily;
            span.style.fontSize = fontSize;
            span.style.margin = '0';
            span.style.padding = '0';
            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.appendChild(span);
            container.appendChild(img);
            var baseline = img.offsetTop - span.offsetTop + 2;
            container.removeChild(span);
            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.style.lineHeight = 'normal';
            img.style.verticalAlign = 'super';
            var middle = img.offsetTop - container.offsetTop + 2;
            body.removeChild(container);
            return { baseline: baseline, middle: middle };
        };
        FontMetrics.prototype.getMetrics = function (fontFamily, fontSize) {
            var key = fontFamily + " " + fontSize;
            if (typeof this._data[key] === 'undefined') {
                this._data[key] = this.parseMetrics(fontFamily, fontSize);
            }
            return this._data[key];
        };
        return FontMetrics;
    }());

    var MASK_OFFSET = 10000;
    var CanvasRenderer = /** @class */ (function () {
        function CanvasRenderer(options) {
            this._activeEffects = [];
            this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.options = options;
            this.canvas.width = Math.floor(options.width * options.scale);
            this.canvas.height = Math.floor(options.height * options.scale);
            this.canvas.style.width = options.width + "px";
            this.canvas.style.height = options.height + "px";
            this.fontMetrics = new FontMetrics(document);
            this.ctx.scale(this.options.scale, this.options.scale);
            this.ctx.translate(-options.x + options.scrollX, -options.y + options.scrollY);
            this.ctx.textBaseline = 'bottom';
            this._activeEffects = [];
            Logger.getInstance(options.id).debug("Canvas renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
        }
        CanvasRenderer.prototype.applyEffects = function (effects, target) {
            var _this = this;
            while (this._activeEffects.length) {
                this.popEffect();
            }
            effects.filter(function (effect) { return contains(effect.target, target); }).forEach(function (effect) { return _this.applyEffect(effect); });
        };
        CanvasRenderer.prototype.applyEffect = function (effect) {
            this.ctx.save();
            if (isTransformEffect(effect)) {
                this.ctx.translate(effect.offsetX, effect.offsetY);
                this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
                this.ctx.translate(-effect.offsetX, -effect.offsetY);
            }
            if (isClipEffect(effect)) {
                this.path(effect.path);
                this.ctx.clip();
            }
            this._activeEffects.push(effect);
        };
        CanvasRenderer.prototype.popEffect = function () {
            this._activeEffects.pop();
            this.ctx.restore();
        };
        CanvasRenderer.prototype.renderStack = function (stack) {
            return __awaiter(this, void 0, void 0, function () {
                var styles;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            styles = stack.element.container.styles;
                            if (!styles.isVisible()) return [3 /*break*/, 2];
                            this.ctx.globalAlpha = styles.opacity;
                            return [4 /*yield*/, this.renderStackContent(stack)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2: return [2 /*return*/];
                    }
                });
            });
        };
        CanvasRenderer.prototype.renderNode = function (paint) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!paint.container.styles.isVisible()) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.renderNodeBackgroundAndBorders(paint)];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.renderNodeContent(paint)];
                        case 2:
                            _a.sent();
                            _a.label = 3;
                        case 3: return [2 /*return*/];
                    }
                });
            });
        };
        CanvasRenderer.prototype.renderTextWithLetterSpacing = function (text, letterSpacing) {
            var _this = this;
            if (letterSpacing === 0) {
                this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);
            }
            else {
                var letters = toCodePoints(text.text).map(function (i) { return fromCodePoint(i); });
                letters.reduce(function (left, letter) {
                    _this.ctx.fillText(letter, left, text.bounds.top + text.bounds.height);
                    return left + _this.ctx.measureText(letter).width;
                }, text.bounds.left);
            }
        };
        CanvasRenderer.prototype.createFontStyle = function (styles) {
            var fontVariant = styles.fontVariant
                .filter(function (variant) { return variant === 'normal' || variant === 'small-caps'; })
                .join('');
            var fontFamily = styles.fontFamily.join(', ');
            var fontSize = isDimensionToken(styles.fontSize)
                ? "" + styles.fontSize.number + styles.fontSize.unit
                : styles.fontSize.number + "px";
            return [
                [styles.fontStyle, fontVariant, styles.fontWeight, fontSize, fontFamily].join(' '),
                fontFamily,
                fontSize
            ];
        };
        CanvasRenderer.prototype.renderTextNode = function (text, styles) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, font, fontFamily, fontSize;
                var _this = this;
                return __generator(this, function (_b) {
                    _a = this.createFontStyle(styles), font = _a[0], fontFamily = _a[1], fontSize = _a[2];
                    this.ctx.font = font;
                    text.textBounds.forEach(function (text) {
                        _this.ctx.fillStyle = asString(styles.color);
                        _this.renderTextWithLetterSpacing(text, styles.letterSpacing);
                        var textShadows = styles.textShadow;
                        if (textShadows.length && text.text.trim().length) {
                            textShadows
                                .slice(0)
                                .reverse()
                                .forEach(function (textShadow) {
                                _this.ctx.shadowColor = asString(textShadow.color);
                                _this.ctx.shadowOffsetX = textShadow.offsetX.number * _this.options.scale;
                                _this.ctx.shadowOffsetY = textShadow.offsetY.number * _this.options.scale;
                                _this.ctx.shadowBlur = textShadow.blur.number;
                                _this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);
                            });
                            _this.ctx.shadowColor = '';
                            _this.ctx.shadowOffsetX = 0;
                            _this.ctx.shadowOffsetY = 0;
                            _this.ctx.shadowBlur = 0;
                        }
                        if (styles.textDecorationLine.length) {
                            _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                            styles.textDecorationLine.forEach(function (textDecorationLine) {
                                switch (textDecorationLine) {
                                    case 1 /* UNDERLINE */:
                                        // Draws a line at the baseline of the font
                                        // TODO As some browsers display the line as more than 1px if the font-size is big,
                                        // need to take that into account both in position and size
                                        var baseline = _this.fontMetrics.getMetrics(fontFamily, fontSize).baseline;
                                        _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1);
                                        break;
                                    case 2 /* OVERLINE */:
                                        _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1);
                                        break;
                                    case 3 /* LINE_THROUGH */:
                                        // TODO try and find exact position for line-through
                                        var middle = _this.fontMetrics.getMetrics(fontFamily, fontSize).middle;
                                        _this.ctx.fillRect(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1);
                                        break;
                                }
                            });
                        }
                    });
                    return [2 /*return*/];
                });
            });
        };
        CanvasRenderer.prototype.renderReplacedElement = function (container, curves, image) {
            if (image && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
                var box = contentBox(container);
                var path = calculatePaddingBoxPath(curves);
                this.path(path);
                this.ctx.save();
                this.ctx.clip();
                this.ctx.drawImage(image, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
                this.ctx.restore();
            }
        };
        CanvasRenderer.prototype.renderNodeContent = function (paint) {
            return __awaiter(this, void 0, void 0, function () {
                var container, curves, styles, _i, _a, child, image, e_1, image, e_2, iframeRenderer, canvas, size, bounds, x, textBounds, img, image, url, e_3, bounds;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            this.applyEffects(paint.effects, 4 /* CONTENT */);
                            container = paint.container;
                            curves = paint.curves;
                            styles = container.styles;
                            _i = 0, _a = container.textNodes;
                            _b.label = 1;
                        case 1:
                            if (!(_i < _a.length)) return [3 /*break*/, 4];
                            child = _a[_i];
                            return [4 /*yield*/, this.renderTextNode(child, styles)];
                        case 2:
                            _b.sent();
                            _b.label = 3;
                        case 3:
                            _i++;
                            return [3 /*break*/, 1];
                        case 4:
                            if (!(container instanceof ImageElementContainer)) return [3 /*break*/, 8];
                            _b.label = 5;
                        case 5:
                            _b.trys.push([5, 7, , 8]);
                            return [4 /*yield*/, this.options.cache.match(container.src)];
                        case 6:
                            image = _b.sent();
                            this.renderReplacedElement(container, curves, image);
                            return [3 /*break*/, 8];
                        case 7:
                            e_1 = _b.sent();
                            Logger.getInstance(this.options.id).error("Error loading image " + container.src);
                            return [3 /*break*/, 8];
                        case 8:
                            if (container instanceof CanvasElementContainer) {
                                this.renderReplacedElement(container, curves, container.canvas);
                            }
                            if (!(container instanceof SVGElementContainer)) return [3 /*break*/, 12];
                            _b.label = 9;
                        case 9:
                            _b.trys.push([9, 11, , 12]);
                            return [4 /*yield*/, this.options.cache.match(container.svg)];
                        case 10:
                            image = _b.sent();
                            this.renderReplacedElement(container, curves, image);
                            return [3 /*break*/, 12];
                        case 11:
                            e_2 = _b.sent();
                            Logger.getInstance(this.options.id).error("Error loading svg " + container.svg.substring(0, 255));
                            return [3 /*break*/, 12];
                        case 12:
                            if (!(container instanceof IFrameElementContainer && container.tree)) return [3 /*break*/, 14];
                            iframeRenderer = new CanvasRenderer({
                                id: this.options.id,
                                scale: this.options.scale,
                                backgroundColor: container.backgroundColor,
                                x: 0,
                                y: 0,
                                scrollX: 0,
                                scrollY: 0,
                                width: container.width,
                                height: container.height,
                                cache: this.options.cache,
                                windowWidth: container.width,
                                windowHeight: container.height
                            });
                            return [4 /*yield*/, iframeRenderer.render(container.tree)];
                        case 13:
                            canvas = _b.sent();
                            this.ctx.drawImage(canvas, 0, 0, container.width, container.width, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                            _b.label = 14;
                        case 14:
                            if (container instanceof InputElementContainer) {
                                size = Math.min(container.bounds.width, container.bounds.height);
                                if (container.type === CHECKBOX) {
                                    if (container.checked) {
                                        this.ctx.save();
                                        this.path([
                                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                                            new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                                            new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                                            new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                                            new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                                            new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                                        ]);
                                        this.ctx.fillStyle = asString(INPUT_COLOR);
                                        this.ctx.fill();
                                        this.ctx.restore();
                                    }
                                }
                                else if (container.type === RADIO) {
                                    if (container.checked) {
                                        this.ctx.save();
                                        this.ctx.beginPath();
                                        this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                                        this.ctx.fillStyle = asString(INPUT_COLOR);
                                        this.ctx.fill();
                                        this.ctx.restore();
                                    }
                                }
                            }
                            if (isTextInputElement(container) && container.value.length) {
                                this.ctx.font = this.createFontStyle(styles)[0];
                                this.ctx.fillStyle = asString(styles.color);
                                this.ctx.textBaseline = 'middle';
                                this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                                bounds = contentBox(container);
                                x = 0;
                                switch (container.styles.textAlign) {
                                    case TEXT_ALIGN.CENTER:
                                        x += bounds.width / 2;
                                        break;
                                    case TEXT_ALIGN.RIGHT:
                                        x += bounds.width;
                                        break;
                                }
                                textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
                                this.ctx.save();
                                this.path([
                                    new Vector(bounds.left, bounds.top),
                                    new Vector(bounds.left + bounds.width, bounds.top),
                                    new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                                    new Vector(bounds.left, bounds.top + bounds.height)
                                ]);
                                this.ctx.clip();
                                this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing);
                                this.ctx.restore();
                                this.ctx.textBaseline = 'bottom';
                                this.ctx.textAlign = 'left';
                            }
                            if (!contains(container.styles.display, 2048 /* LIST_ITEM */)) return [3 /*break*/, 20];
                            if (!(container.styles.listStyleImage !== null)) return [3 /*break*/, 19];
                            img = container.styles.listStyleImage;
                            if (!(img.type === CSSImageType.URL)) return [3 /*break*/, 18];
                            image = void 0;
                            url = img.url;
                            _b.label = 15;
                        case 15:
                            _b.trys.push([15, 17, , 18]);
                            return [4 /*yield*/, this.options.cache.match(url)];
                        case 16:
                            image = _b.sent();
                            this.ctx.drawImage(image, container.bounds.left - (image.width + 10), container.bounds.top);
                            return [3 /*break*/, 18];
                        case 17:
                            e_3 = _b.sent();
                            Logger.getInstance(this.options.id).error("Error loading list-style-image " + url);
                            return [3 /*break*/, 18];
                        case 18: return [3 /*break*/, 20];
                        case 19:
                            if (paint.listValue && container.styles.listStyleType !== LIST_STYLE_TYPE.NONE) {
                                this.ctx.font = this.createFontStyle(styles)[0];
                                this.ctx.fillStyle = asString(styles.color);
                                this.ctx.textBaseline = 'middle';
                                this.ctx.textAlign = 'right';
                                bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                                this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing);
                                this.ctx.textBaseline = 'bottom';
                                this.ctx.textAlign = 'left';
                            }
                            _b.label = 20;
                        case 20: return [2 /*return*/];
                    }
                });
            });
        };
        CanvasRenderer.prototype.renderStackContent = function (stack) {
            return __awaiter(this, void 0, void 0, function () {
                var _i, _a, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
                return __generator(this, function (_p) {
                    switch (_p.label) {
                        case 0: 
                        // https://www.w3.org/TR/css-position-3/#painting-order
                        // 1. the background and borders of the element forming the stacking context.
                        return [4 /*yield*/, this.renderNodeBackgroundAndBorders(stack.element)];
                        case 1:
                            // https://www.w3.org/TR/css-position-3/#painting-order
                            // 1. the background and borders of the element forming the stacking context.
                            _p.sent();
                            _i = 0, _a = stack.negativeZIndex;
                            _p.label = 2;
                        case 2:
                            if (!(_i < _a.length)) return [3 /*break*/, 5];
                            child = _a[_i];
                            return [4 /*yield*/, this.renderStack(child)];
                        case 3:
                            _p.sent();
                            _p.label = 4;
                        case 4:
                            _i++;
                            return [3 /*break*/, 2];
                        case 5: 
                        // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
                        return [4 /*yield*/, this.renderNodeContent(stack.element)];
                        case 6:
                            // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
                            _p.sent();
                            _b = 0, _c = stack.nonInlineLevel;
                            _p.label = 7;
                        case 7:
                            if (!(_b < _c.length)) return [3 /*break*/, 10];
                            child = _c[_b];
                            return [4 /*yield*/, this.renderNode(child)];
                        case 8:
                            _p.sent();
                            _p.label = 9;
                        case 9:
                            _b++;
                            return [3 /*break*/, 7];
                        case 10:
                            _d = 0, _e = stack.nonPositionedFloats;
                            _p.label = 11;
                        case 11:
                            if (!(_d < _e.length)) return [3 /*break*/, 14];
                            child = _e[_d];
                            return [4 /*yield*/, this.renderStack(child)];
                        case 12:
                            _p.sent();
                            _p.label = 13;
                        case 13:
                            _d++;
                            return [3 /*break*/, 11];
                        case 14:
                            _f = 0, _g = stack.nonPositionedInlineLevel;
                            _p.label = 15;
                        case 15:
                            if (!(_f < _g.length)) return [3 /*break*/, 18];
                            child = _g[_f];
                            return [4 /*yield*/, this.renderStack(child)];
                        case 16:
                            _p.sent();
                            _p.label = 17;
                        case 17:
                            _f++;
                            return [3 /*break*/, 15];
                        case 18:
                            _h = 0, _j = stack.inlineLevel;
                            _p.label = 19;
                        case 19:
                            if (!(_h < _j.length)) return [3 /*break*/, 22];
                            child = _j[_h];
                            return [4 /*yield*/, this.renderNode(child)];
                        case 20:
                            _p.sent();
                            _p.label = 21;
                        case 21:
                            _h++;
                            return [3 /*break*/, 19];
                        case 22:
                            _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                            _p.label = 23;
                        case 23:
                            if (!(_k < _l.length)) return [3 /*break*/, 26];
                            child = _l[_k];
                            return [4 /*yield*/, this.renderStack(child)];
                        case 24:
                            _p.sent();
                            _p.label = 25;
                        case 25:
                            _k++;
                            return [3 /*break*/, 23];
                        case 26:
                            _m = 0, _o = stack.positiveZIndex;
                            _p.label = 27;
                        case 27:
                            if (!(_m < _o.length)) return [3 /*break*/, 30];
                            child = _o[_m];
                            return [4 /*yield*/, this.renderStack(child)];
                        case 28:
                            _p.sent();
                            _p.label = 29;
                        case 29:
                            _m++;
                            return [3 /*break*/, 27];
                        case 30: return [2 /*return*/];
                    }
                });
            });
        };
        CanvasRenderer.prototype.mask = function (paths) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, 0);
            this.ctx.lineTo(this.canvas.width, 0);
            this.ctx.lineTo(this.canvas.width, this.canvas.height);
            this.ctx.lineTo(0, this.canvas.height);
            this.ctx.lineTo(0, 0);
            this.formatPath(paths.slice(0).reverse());
            this.ctx.closePath();
        };
        CanvasRenderer.prototype.path = function (paths) {
            this.ctx.beginPath();
            this.formatPath(paths);
            this.ctx.closePath();
        };
        CanvasRenderer.prototype.formatPath = function (paths) {
            var _this = this;
            paths.forEach(function (point, index) {
                var start = isBezierCurve(point) ? point.start : point;
                if (index === 0) {
                    _this.ctx.moveTo(start.x, start.y);
                }
                else {
                    _this.ctx.lineTo(start.x, start.y);
                }
                if (isBezierCurve(point)) {
                    _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
                }
            });
        };
        CanvasRenderer.prototype.renderRepeat = function (path, pattern, offsetX, offsetY) {
            this.path(path);
            this.ctx.fillStyle = pattern;
            this.ctx.translate(offsetX, offsetY);
            this.ctx.fill();
            this.ctx.translate(-offsetX, -offsetY);
        };
        CanvasRenderer.prototype.resizeImage = function (image, width, height) {
            if (image.width === width && image.height === height) {
                return image;
            }
            var canvas = this.canvas.ownerDocument.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
            return canvas;
        };
        CanvasRenderer.prototype.renderBackgroundImage = function (container) {
            return __awaiter(this, void 0, void 0, function () {
                var index, _loop_1, this_1, _i, _a, backgroundImage;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            index = container.styles.backgroundImage.length - 1;
                            _loop_1 = function (backgroundImage) {
                                var image, url, e_4, _a, path, x, y, width, height, pattern, _b, path, x, y, width, height, _c, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _d, path, left, top_1, width, height, position, x, y, _e, rx, ry, radialGradient_1, midX, midY, f, invF;
                                return __generator(this, function (_f) {
                                    switch (_f.label) {
                                        case 0:
                                            if (!(backgroundImage.type === CSSImageType.URL)) return [3 /*break*/, 5];
                                            image = void 0;
                                            url = backgroundImage.url;
                                            _f.label = 1;
                                        case 1:
                                            _f.trys.push([1, 3, , 4]);
                                            return [4 /*yield*/, this_1.options.cache.match(url)];
                                        case 2:
                                            image = _f.sent();
                                            return [3 /*break*/, 4];
                                        case 3:
                                            e_4 = _f.sent();
                                            Logger.getInstance(this_1.options.id).error("Error loading background-image " + url);
                                            return [3 /*break*/, 4];
                                        case 4:
                                            if (image) {
                                                _a = calculateBackgroundRendering(container, index, [
                                                    image.width,
                                                    image.height,
                                                    image.width / image.height
                                                ]), path = _a[0], x = _a[1], y = _a[2], width = _a[3], height = _a[4];
                                                pattern = this_1.ctx.createPattern(this_1.resizeImage(image, width, height), 'repeat');
                                                this_1.renderRepeat(path, pattern, x, y);
                                            }
                                            return [3 /*break*/, 6];
                                        case 5:
                                            if (isLinearGradient(backgroundImage)) {
                                                _b = calculateBackgroundRendering(container, index, [null, null, null]), path = _b[0], x = _b[1], y = _b[2], width = _b[3], height = _b[4];
                                                _c = calculateGradientDirection(backgroundImage.angle, width, height), lineLength = _c[0], x0 = _c[1], x1 = _c[2], y0 = _c[3], y1 = _c[4];
                                                canvas = document.createElement('canvas');
                                                canvas.width = width;
                                                canvas.height = height;
                                                ctx = canvas.getContext('2d');
                                                gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                                                processColorStops(backgroundImage.stops, lineLength).forEach(function (colorStop) {
                                                    return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                                });
                                                ctx.fillStyle = gradient_1;
                                                ctx.fillRect(0, 0, width, height);
                                                pattern = this_1.ctx.createPattern(canvas, 'repeat');
                                                this_1.renderRepeat(path, pattern, x, y);
                                            }
                                            else if (isRadialGradient(backgroundImage)) {
                                                _d = calculateBackgroundRendering(container, index, [
                                                    null,
                                                    null,
                                                    null
                                                ]), path = _d[0], left = _d[1], top_1 = _d[2], width = _d[3], height = _d[4];
                                                position = backgroundImage.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage.position;
                                                x = getAbsoluteValue(position[0], width);
                                                y = getAbsoluteValue(position[position.length - 1], height);
                                                _e = calculateRadius(backgroundImage, x, y, width, height), rx = _e[0], ry = _e[1];
                                                if (rx > 0 && rx > 0) {
                                                    radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
                                                    processColorStops(backgroundImage.stops, rx * 2).forEach(function (colorStop) {
                                                        return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                                                    });
                                                    this_1.path(path);
                                                    this_1.ctx.fillStyle = radialGradient_1;
                                                    if (rx !== ry) {
                                                        midX = container.bounds.left + 0.5 * container.bounds.width;
                                                        midY = container.bounds.top + 0.5 * container.bounds.height;
                                                        f = ry / rx;
                                                        invF = 1 / f;
                                                        this_1.ctx.save();
                                                        this_1.ctx.translate(midX, midY);
                                                        this_1.ctx.transform(1, 0, 0, f, 0, 0);
                                                        this_1.ctx.translate(-midX, -midY);
                                                        this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                                                        this_1.ctx.restore();
                                                    }
                                                    else {
                                                        this_1.ctx.fill();
                                                    }
                                                }
                                            }
                                            _f.label = 6;
                                        case 6:
                                            index--;
                                            return [2 /*return*/];
                                    }
                                });
                            };
                            this_1 = this;
                            _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();
                            _b.label = 1;
                        case 1:
                            if (!(_i < _a.length)) return [3 /*break*/, 4];
                            backgroundImage = _a[_i];
                            return [5 /*yield**/, _loop_1(backgroundImage)];
                        case 2:
                            _b.sent();
                            _b.label = 3;
                        case 3:
                            _i++;
                            return [3 /*break*/, 1];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        CanvasRenderer.prototype.renderBorder = function (color, side, curvePoints) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    this.path(parsePathForBorder(curvePoints, side));
                    this.ctx.fillStyle = asString(color);
                    this.ctx.fill();
                    return [2 /*return*/];
                });
            });
        };
        CanvasRenderer.prototype.renderNodeBackgroundAndBorders = function (paint) {
            return __awaiter(this, void 0, void 0, function () {
                var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.applyEffects(paint.effects, 2 /* BACKGROUND_BORDERS */);
                            styles = paint.container.styles;
                            hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                            borders = [
                                { style: styles.borderTopStyle, color: styles.borderTopColor },
                                { style: styles.borderRightStyle, color: styles.borderRightColor },
                                { style: styles.borderBottomStyle, color: styles.borderBottomColor },
                                { style: styles.borderLeftStyle, color: styles.borderLeftColor }
                            ];
                            backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                            if (!(hasBackground || styles.boxShadow.length)) return [3 /*break*/, 2];
                            this.ctx.save();
                            this.path(backgroundPaintingArea);
                            this.ctx.clip();
                            if (!isTransparent(styles.backgroundColor)) {
                                this.ctx.fillStyle = asString(styles.backgroundColor);
                                this.ctx.fill();
                            }
                            return [4 /*yield*/, this.renderBackgroundImage(paint.container)];
                        case 1:
                            _a.sent();
                            this.ctx.restore();
                            styles.boxShadow
                                .slice(0)
                                .reverse()
                                .forEach(function (shadow) {
                                _this.ctx.save();
                                var borderBoxArea = calculateBorderBoxPath(paint.curves);
                                var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                                var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                                if (shadow.inset) {
                                    _this.path(borderBoxArea);
                                    _this.ctx.clip();
                                    _this.mask(shadowPaintingArea);
                                }
                                else {
                                    _this.mask(borderBoxArea);
                                    _this.ctx.clip();
                                    _this.path(shadowPaintingArea);
                                }
                                _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                                _this.ctx.shadowOffsetY = shadow.offsetY.number;
                                _this.ctx.shadowColor = asString(shadow.color);
                                _this.ctx.shadowBlur = shadow.blur.number;
                                _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : 'rgba(0,0,0,1)';
                                _this.ctx.fill();
                                _this.ctx.restore();
                            });
                            _a.label = 2;
                        case 2:
                            side = 0;
                            _i = 0, borders_1 = borders;
                            _a.label = 3;
                        case 3:
                            if (!(_i < borders_1.length)) return [3 /*break*/, 6];
                            border = borders_1[_i];
                            if (!(border.style !== BORDER_STYLE.NONE && !isTransparent(border.color))) return [3 /*break*/, 5];
                            return [4 /*yield*/, this.renderBorder(border.color, side++, paint.curves)];
                        case 4:
                            _a.sent();
                            _a.label = 5;
                        case 5:
                            _i++;
                            return [3 /*break*/, 3];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        CanvasRenderer.prototype.render = function (element) {
            return __awaiter(this, void 0, void 0, function () {
                var stack;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.options.backgroundColor) {
                                this.ctx.fillStyle = asString(this.options.backgroundColor);
                                this.ctx.fillRect(this.options.x - this.options.scrollX, this.options.y - this.options.scrollY, this.options.width, this.options.height);
                            }
                            stack = parseStackingContexts(element);
                            return [4 /*yield*/, this.renderStack(stack)];
                        case 1:
                            _a.sent();
                            this.applyEffects([], 2 /* BACKGROUND_BORDERS */);
                            return [2 /*return*/, this.canvas];
                    }
                });
            });
        };
        return CanvasRenderer;
    }());
    var isTextInputElement = function (container) {
        if (container instanceof TextareaElementContainer) {
            return true;
        }
        else if (container instanceof SelectElementContainer) {
            return true;
        }
        else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
            return true;
        }
        return false;
    };
    var calculateBackgroundCurvedPaintingArea = function (clip, curves) {
        switch (clip) {
            case BACKGROUND_CLIP.BORDER_BOX:
                return calculateBorderBoxPath(curves);
            case BACKGROUND_CLIP.CONTENT_BOX:
                return calculateContentBoxPath(curves);
            case BACKGROUND_CLIP.PADDING_BOX:
            default:
                return calculatePaddingBoxPath(curves);
        }
    };
    var canvasTextAlign = function (textAlign) {
        switch (textAlign) {
            case TEXT_ALIGN.CENTER:
                return 'center';
            case TEXT_ALIGN.RIGHT:
                return 'right';
            case TEXT_ALIGN.LEFT:
            default:
                return 'left';
        }
    };

    var ForeignObjectRenderer = /** @class */ (function () {
        function ForeignObjectRenderer(options) {
            this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.options = options;
            this.canvas.width = Math.floor(options.width * options.scale);
            this.canvas.height = Math.floor(options.height * options.scale);
            this.canvas.style.width = options.width + "px";
            this.canvas.style.height = options.height + "px";
            this.ctx.scale(this.options.scale, this.options.scale);
            this.ctx.translate(-options.x + options.scrollX, -options.y + options.scrollY);
            Logger.getInstance(options.id).debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
        }
        ForeignObjectRenderer.prototype.render = function (element) {
            return __awaiter(this, void 0, void 0, function () {
                var svg, img;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            svg = createForeignObjectSVG(Math.max(this.options.windowWidth, this.options.width) * this.options.scale, Math.max(this.options.windowHeight, this.options.height) * this.options.scale, this.options.scrollX * this.options.scale, this.options.scrollY * this.options.scale, element);
                            return [4 /*yield*/, loadSerializedSVG$1(svg)];
                        case 1:
                            img = _a.sent();
                            if (this.options.backgroundColor) {
                                this.ctx.fillStyle = asString(this.options.backgroundColor);
                                this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                            }
                            this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                            return [2 /*return*/, this.canvas];
                    }
                });
            });
        };
        return ForeignObjectRenderer;
    }());
    var loadSerializedSVG$1 = function (svg) {
        return new Promise(function (resolve, reject) {
            var img = new Image();
            img.onload = function () {
                resolve(img);
            };
            img.onerror = reject;
            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
        });
    };

    var _this = undefined;
    var parseColor$1 = function (value) { return color.parse(Parser.create(value).parseComponentValue()); };
    var html2canvas = function (element, options) {
        if (options === void 0) { options = {}; }
        return renderElement(element, options);
    };
    CacheStorage.setContext(window);
    var renderElement = function (element, opts) { return __awaiter(_this, void 0, void 0, function () {
        var ownerDocument, defaultView, instanceName, _a, width, height, left, top, defaultResourceOptions, resourceOptions, defaultOptions, options, windowBounds, documentCloner, clonedElement, container, documentBackgroundColor, bodyBackgroundColor, bgColor, defaultBackgroundColor, backgroundColor, renderOptions, canvas, renderer, root, renderer;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    ownerDocument = element.ownerDocument;
                    if (!ownerDocument) {
                        throw new Error("Element is not attached to a Document");
                    }
                    defaultView = ownerDocument.defaultView;
                    if (!defaultView) {
                        throw new Error("Document is not attached to a Window");
                    }
                    instanceName = (Math.round(Math.random() * 1000) + Date.now()).toString(16);
                    _a = isBodyElement(element) || isHTMLElement(element) ? parseDocumentSize(ownerDocument) : parseBounds(element), width = _a.width, height = _a.height, left = _a.left, top = _a.top;
                    defaultResourceOptions = {
                        allowTaint: false,
                        imageTimeout: 15000,
                        proxy: undefined,
                        useCORS: false
                    };
                    resourceOptions = __assign({}, defaultResourceOptions, opts);
                    defaultOptions = {
                        backgroundColor: '#ffffff',
                        cache: opts.cache ? opts.cache : CacheStorage.create(instanceName, resourceOptions),
                        logging: true,
                        removeContainer: true,
                        foreignObjectRendering: false,
                        scale: defaultView.devicePixelRatio || 1,
                        windowWidth: defaultView.innerWidth,
                        windowHeight: defaultView.innerHeight,
                        scrollX: defaultView.pageXOffset,
                        scrollY: defaultView.pageYOffset,
                        x: left,
                        y: top,
                        width: Math.ceil(width),
                        height: Math.ceil(height),
                        id: instanceName
                    };
                    options = __assign({}, defaultOptions, resourceOptions, opts);
                    windowBounds = new Bounds(options.scrollX, options.scrollY, options.windowWidth, options.windowHeight);
                    Logger.create(instanceName);
                    Logger.getInstance(instanceName).debug("Starting document clone");
                    documentCloner = new DocumentCloner(element, {
                        id: instanceName,
                        onclone: options.onclone,
                        ignoreElements: options.ignoreElements,
                        inlineImages: options.foreignObjectRendering,
                        copyStyles: options.foreignObjectRendering
                    });
                    clonedElement = documentCloner.clonedReferenceElement;
                    if (!clonedElement) {
                        return [2 /*return*/, Promise.reject("Unable to find element in cloned iframe")];
                    }
                    return [4 /*yield*/, documentCloner.toIFrame(ownerDocument, windowBounds)];
                case 1:
                    container = _b.sent();
                    documentBackgroundColor = ownerDocument.documentElement
                        ? parseColor$1(getComputedStyle(ownerDocument.documentElement).backgroundColor)
                        : COLORS.TRANSPARENT;
                    bodyBackgroundColor = ownerDocument.body
                        ? parseColor$1(getComputedStyle(ownerDocument.body).backgroundColor)
                        : COLORS.TRANSPARENT;
                    bgColor = opts.backgroundColor;
                    defaultBackgroundColor = typeof bgColor === 'string' ? parseColor$1(bgColor) : 0xffffffff;
                    backgroundColor = element === ownerDocument.documentElement
                        ? isTransparent(documentBackgroundColor)
                            ? isTransparent(bodyBackgroundColor)
                                ? defaultBackgroundColor
                                : bodyBackgroundColor
                            : documentBackgroundColor
                        : defaultBackgroundColor;
                    renderOptions = {
                        id: instanceName,
                        cache: options.cache,
                        backgroundColor: backgroundColor,
                        scale: options.scale,
                        x: options.x,
                        y: options.y,
                        scrollX: options.scrollX,
                        scrollY: options.scrollY,
                        width: options.width,
                        height: options.height,
                        windowWidth: options.windowWidth,
                        windowHeight: options.windowHeight
                    };
                    if (!options.foreignObjectRendering) return [3 /*break*/, 3];
                    Logger.getInstance(instanceName).debug("Document cloned, using foreign object rendering");
                    renderer = new ForeignObjectRenderer(renderOptions);
                    return [4 /*yield*/, renderer.render(clonedElement)];
                case 2:
                    canvas = _b.sent();
                    return [3 /*break*/, 5];
                case 3:
                    Logger.getInstance(instanceName).debug("Document cloned, using computed rendering");
                    CacheStorage.attachInstance(options.cache);
                    Logger.getInstance(instanceName).debug("Starting DOM parsing");
                    root = parseTree(clonedElement);
                    CacheStorage.detachInstance();
                    if (backgroundColor === root.styles.backgroundColor) {
                        root.styles.backgroundColor = COLORS.TRANSPARENT;
                    }
                    Logger.getInstance(instanceName).debug("Starting renderer");
                    renderer = new CanvasRenderer(renderOptions);
                    return [4 /*yield*/, renderer.render(root)];
                case 4:
                    canvas = _b.sent();
                    _b.label = 5;
                case 5:
                    if (options.removeContainer === true) {
                        if (!cleanContainer(container)) {
                            Logger.getInstance(instanceName).error("Cannot detach cloned iframe as it is not in the DOM anymore");
                        }
                    }
                    Logger.getInstance(instanceName).debug("Finished rendering");
                    Logger.destroy(instanceName);
                    CacheStorage.destroy(instanceName);
                    return [2 /*return*/, canvas];
            }
        });
    }); };
    var cleanContainer = function (container) {
        if (container.parentNode) {
            container.parentNode.removeChild(container);
            return true;
        }
        return false;
    };

    return html2canvas;

}));
//# sourceMappingURL=html2canvas.js.map


/***/ }),

/***/ "./node_modules/interactjs/dist/interact.js":
/*!**************************************************!*\
  !*** ./node_modules/interactjs/dist/interact.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * interact.js 1.5.4
 *
 * Copyright (c) 2012-2019 Taye Adeyemi <dev@taye.me>
 * Released under the MIT License.
 * https://raw.github.com/taye/interact.js/master/LICENSE
 */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;
var createModuleFactory = function createModuleFactory(t){var e;return function(r){return e||t(e={exports:{},parent:r},e.exports),e.exports}};
var _$scope_24 = createModuleFactory(function (module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/* common-shake removed: exports.createScope = */ void createScope;
/* common-shake removed: exports.initScope = */ void initScope;
exports.Scope = exports.ActionName = void 0;

var utils = _interopRequireWildcard(_$utils_56);

var _domObjects = _interopRequireDefault(_$domObjects_50);

var _defaultOptions = _interopRequireDefault(_$defaultOptions_20);

var _Eventable = _interopRequireDefault(_$Eventable_14);

var _Interactable = _interopRequireDefault(_$Interactable_16);

var _InteractableSet = _interopRequireDefault(_$InteractableSet_17);

var _InteractEvent = _interopRequireDefault(_$InteractEvent_15);

var _interactions = _interopRequireDefault(_$interactions_23({}));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var win = utils.win,
    browser = utils.browser,
    raf = utils.raf,
    Signals = utils.Signals,
    events = utils.events;
var ActionName;
exports.ActionName = ActionName;

(function (ActionName) {})(ActionName || (exports.ActionName = ActionName = {}));

function createScope() {
  return new Scope();
}

var Scope =
/*#__PURE__*/
function () {
  function Scope() {
    var _this = this;

    _classCallCheck(this, Scope);

    this.id = "__interact_scope_".concat(Math.floor(Math.random() * 100));
    this.signals = new Signals();
    this.browser = browser;
    this.events = events;
    this.utils = utils;
    this.defaults = utils.clone(_defaultOptions["default"]);
    this.Eventable = _Eventable["default"];
    this.actions = {
      names: [],
      methodDict: {},
      eventTypes: []
    };
    this.InteractEvent = _InteractEvent["default"];
    this.interactables = new _InteractableSet["default"](this); // all documents being listened to

    this.documents = [];
    this._plugins = [];
    this._pluginMap = {};

    this.onWindowUnload = function (event) {
      return _this.removeDocument(event.target);
    };

    var scope = this;

    this.Interactable =
    /*#__PURE__*/
    function (_InteractableBase) {
      _inherits(Interactable, _InteractableBase);

      function Interactable() {
        _classCallCheck(this, Interactable);

        return _possibleConstructorReturn(this, _getPrototypeOf(Interactable).apply(this, arguments));
      }

      _createClass(Interactable, [{
        key: "set",
        value: function set(options) {
          _get(_getPrototypeOf(Interactable.prototype), "set", this).call(this, options);

          scope.interactables.signals.fire('set', {
            options: options,
            interactable: this
          });
          return this;
        }
      }, {
        key: "unset",
        value: function unset() {
          _get(_getPrototypeOf(Interactable.prototype), "unset", this).call(this);

          for (var i = scope.interactions.list.length - 1; i >= 0; i--) {
            var interaction = scope.interactions.list[i];

            if (interaction.interactable === this) {
              interaction.stop();
              scope.interactions.signals.fire('destroy', {
                interaction: interaction
              });
              interaction.destroy();

              if (scope.interactions.list.length > 2) {
                scope.interactions.list.splice(i, 1);
              }
            }
          }

          scope.interactables.signals.fire('unset', {
            interactable: this
          });
        }
      }, {
        key: "_defaults",
        get: function get() {
          return scope.defaults;
        }
      }]);

      return Interactable;
    }(_Interactable["default"]);
  }

  _createClass(Scope, [{
    key: "init",
    value: function init(window) {
      return initScope(this, window);
    }
  }, {
    key: "pluginIsInstalled",
    value: function pluginIsInstalled(plugin) {
      return this._pluginMap[plugin.id] || this._plugins.indexOf(plugin) !== -1;
    }
  }, {
    key: "usePlugin",
    value: function usePlugin(plugin, options) {
      if (this.pluginIsInstalled(plugin)) {
        return this;
      }

      if (plugin.id) {
        this._pluginMap[plugin.id] = plugin;
      }

      plugin.install(this, options);

      this._plugins.push(plugin);

      return this;
    }
  }, {
    key: "addDocument",
    value: function addDocument(doc, options) {
      // do nothing if document is already known
      if (this.getDocIndex(doc) !== -1) {
        return false;
      }

      var window = win.getWindow(doc);
      options = options ? utils.extend({}, options) : {};
      this.documents.push({
        doc: doc,
        options: options
      });
      events.documents.push(doc); // don't add an unload event for the main document
      // so that the page may be cached in browser history

      if (doc !== this.document) {
        events.add(window, 'unload', this.onWindowUnload);
      }

      this.signals.fire('add-document', {
        doc: doc,
        window: window,
        scope: this,
        options: options
      });
    }
  }, {
    key: "removeDocument",
    value: function removeDocument(doc) {
      var index = this.getDocIndex(doc);
      var window = win.getWindow(doc);
      var options = this.documents[index].options;
      events.remove(window, 'unload', this.onWindowUnload);
      this.documents.splice(index, 1);
      events.documents.splice(index, 1);
      this.signals.fire('remove-document', {
        doc: doc,
        window: window,
        scope: this,
        options: options
      });
    }
  }, {
    key: "getDocIndex",
    value: function getDocIndex(doc) {
      for (var i = 0; i < this.documents.length; i++) {
        if (this.documents[i].doc === doc) {
          return i;
        }
      }

      return -1;
    }
  }, {
    key: "getDocOptions",
    value: function getDocOptions(doc) {
      var docIndex = this.getDocIndex(doc);
      return docIndex === -1 ? null : this.documents[docIndex].options;
    }
  }, {
    key: "now",
    value: function now() {
      return (this.window.Date || Date).now();
    }
  }]);

  return Scope;
}();

exports.Scope = Scope;

function initScope(scope, window) {
  win.init(window);

  _domObjects["default"].init(window);

  browser.init(window);
  raf.init(window);
  events.init(window);
  scope.usePlugin(_interactions["default"]);
  scope.document = window.document;
  scope.window = window;
  return scope;
}

});
var _$interactions_23 = createModuleFactory(function (module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _browser = _interopRequireDefault(_$browser_48);

var _domObjects = _interopRequireDefault(_$domObjects_50);

/* removed: var _$domUtils_51 = require("@interactjs/utils/domUtils"); */;

var _events = _interopRequireDefault(_$events_52);

var _pointerUtils = _interopRequireDefault(_$pointerUtils_61);

var _Signals = _interopRequireDefault(_$Signals_46);

var _Interaction = _interopRequireDefault(_$Interaction_18({}));

var _interactionFinder = _interopRequireDefault(_$interactionFinder_22);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var methodNames = ['pointerDown', 'pointerMove', 'pointerUp', 'updatePointer', 'removePointer', 'windowBlur'];

function install(scope) {
  var signals = new _Signals["default"]();
  var listeners = {};

  for (var _i = 0; _i < methodNames.length; _i++) {
    var method = methodNames[_i];
    listeners[method] = doOnInteractions(method, scope);
  }

  var pEventTypes = _browser["default"].pEventTypes;
  var docEvents;

  if (_domObjects["default"].PointerEvent) {
    docEvents = [{
      type: pEventTypes.down,
      listener: releasePointersOnRemovedEls
    }, {
      type: pEventTypes.down,
      listener: listeners.pointerDown
    }, {
      type: pEventTypes.move,
      listener: listeners.pointerMove
    }, {
      type: pEventTypes.up,
      listener: listeners.pointerUp
    }, {
      type: pEventTypes.cancel,
      listener: listeners.pointerUp
    }];
  } else {
    docEvents = [{
      type: 'mousedown',
      listener: listeners.pointerDown
    }, {
      type: 'mousemove',
      listener: listeners.pointerMove
    }, {
      type: 'mouseup',
      listener: listeners.pointerUp
    }, {
      type: 'touchstart',
      listener: releasePointersOnRemovedEls
    }, {
      type: 'touchstart',
      listener: listeners.pointerDown
    }, {
      type: 'touchmove',
      listener: listeners.pointerMove
    }, {
      type: 'touchend',
      listener: listeners.pointerUp
    }, {
      type: 'touchcancel',
      listener: listeners.pointerUp
    }];
  }

  docEvents.push({
    type: 'blur',
    listener: function listener(event) {
      for (var _i2 = 0; _i2 < scope.interactions.list.length; _i2++) {
        var _ref;

        _ref = scope.interactions.list[_i2];
        var interaction = _ref;
        interaction.documentBlur(event);
      }
    }
  });
  scope.signals.on('add-document', onDocSignal);
  scope.signals.on('remove-document', onDocSignal); // for ignoring browser's simulated mouse events

  scope.prevTouchTime = 0;

  scope.Interaction =
  /*#__PURE__*/
  function (_InteractionBase) {
    _inherits(Interaction, _InteractionBase);

    function Interaction() {
      _classCallCheck(this, Interaction);

      return _possibleConstructorReturn(this, _getPrototypeOf(Interaction).apply(this, arguments));
    }

    _createClass(Interaction, [{
      key: "_now",
      value: function _now() {
        return scope.now();
      }
    }, {
      key: "pointerMoveTolerance",
      get: function get() {
        return scope.interactions.pointerMoveTolerance;
      },
      set: function set(value) {
        scope.interactions.pointerMoveTolerance = value;
      }
    }]);

    return Interaction;
  }(_Interaction["default"]);

  scope.interactions = {
    signals: signals,
    // all active and idle interactions
    list: [],
    "new": function _new(options) {
      options.signals = signals;
      var interaction = new scope.Interaction(options);
      scope.interactions.list.push(interaction);
      return interaction;
    },
    listeners: listeners,
    docEvents: docEvents,
    pointerMoveTolerance: 1
  };

  function releasePointersOnRemovedEls() {
    // for all inactive touch interactions with pointers down
    for (var _i3 = 0; _i3 < scope.interactions.list.length; _i3++) {
      var _ref2;

      _ref2 = scope.interactions.list[_i3];
      var interaction = _ref2;

      if (!interaction.pointerIsDown || interaction.pointerType !== 'touch' || interaction._interacting) {
        continue;
      } // if a pointer is down on an element that is no longer in the DOM tree


      var _loop = function _loop() {
        _ref3 = interaction.pointers[_i4];
        var pointer = _ref3;

        if (!scope.documents.some(function (_ref4) {
          var doc = _ref4.doc;
          return (0, _$domUtils_51.nodeContains)(doc, pointer.downTarget);
        })) {
          // remove the pointer from the interaction
          interaction.removePointer(pointer.pointer, pointer.event);
        }
      };

      for (var _i4 = 0; _i4 < interaction.pointers.length; _i4++) {
        var _ref3;

        _loop();
      }
    }
  }
}

function doOnInteractions(method, scope) {
  return function (event) {
    var interactions = scope.interactions.list;

    var pointerType = _pointerUtils["default"].getPointerType(event);

    var _pointerUtils$getEven = _pointerUtils["default"].getEventTargets(event),
        _pointerUtils$getEven2 = _slicedToArray(_pointerUtils$getEven, 2),
        eventTarget = _pointerUtils$getEven2[0],
        curEventTarget = _pointerUtils$getEven2[1];

    var matches = []; // [ [pointer, interaction], ...]

    if (/^touch/.test(event.type)) {
      scope.prevTouchTime = scope.now();

      for (var _i5 = 0; _i5 < event.changedTouches.length; _i5++) {
        var _ref5;

        _ref5 = event.changedTouches[_i5];
        var changedTouch = _ref5;
        var pointer = changedTouch;

        var pointerId = _pointerUtils["default"].getPointerId(pointer);

        var searchDetails = {
          pointer: pointer,
          pointerId: pointerId,
          pointerType: pointerType,
          eventType: event.type,
          eventTarget: eventTarget,
          curEventTarget: curEventTarget,
          scope: scope
        };
        var interaction = getInteraction(searchDetails);
        matches.push([searchDetails.pointer, searchDetails.eventTarget, searchDetails.curEventTarget, interaction]);
      }
    } else {
      var invalidPointer = false;

      if (!_browser["default"].supportsPointerEvent && /mouse/.test(event.type)) {
        // ignore mouse events while touch interactions are active
        for (var i = 0; i < interactions.length && !invalidPointer; i++) {
          invalidPointer = interactions[i].pointerType !== 'mouse' && interactions[i].pointerIsDown;
        } // try to ignore mouse events that are simulated by the browser
        // after a touch event


        invalidPointer = invalidPointer || scope.now() - scope.prevTouchTime < 500 || // on iOS and Firefox Mobile, MouseEvent.timeStamp is zero if simulated
        event.timeStamp === 0;
      }

      if (!invalidPointer) {
        var _searchDetails = {
          pointer: event,
          pointerId: _pointerUtils["default"].getPointerId(event),
          pointerType: pointerType,
          eventType: event.type,
          curEventTarget: curEventTarget,
          eventTarget: eventTarget,
          scope: scope
        };

        var _interaction = getInteraction(_searchDetails);

        matches.push([_searchDetails.pointer, _searchDetails.eventTarget, _searchDetails.curEventTarget, _interaction]);
      }
    } // eslint-disable-next-line no-shadow


    for (var _i6 = 0; _i6 < matches.length; _i6++) {
      var _matches$_i = _slicedToArray(matches[_i6], 4),
          _pointer = _matches$_i[0],
          _eventTarget = _matches$_i[1],
          _curEventTarget = _matches$_i[2],
          _interaction2 = _matches$_i[3];

      _interaction2[method](_pointer, event, _eventTarget, _curEventTarget);
    }
  };
}

function getInteraction(searchDetails) {
  var pointerType = searchDetails.pointerType,
      scope = searchDetails.scope;

  var foundInteraction = _interactionFinder["default"].search(searchDetails);

  var signalArg = {
    interaction: foundInteraction,
    searchDetails: searchDetails
  };
  scope.interactions.signals.fire('find', signalArg);
  return signalArg.interaction || scope.interactions["new"]({
    pointerType: pointerType
  });
}

function onDocSignal(_ref6, signalName) {
  var doc = _ref6.doc,
      scope = _ref6.scope,
      options = _ref6.options;
  var docEvents = scope.interactions.docEvents;
  var eventMethod = signalName.indexOf('add') === 0 ? _events["default"].add : _events["default"].remove;

  if (scope.browser.isIOS && !options.events) {
    options.events = {
      passive: false
    };
  } // delegate event listener


  for (var eventType in _events["default"].delegatedEvents) {
    eventMethod(doc, eventType, _events["default"].delegateListener);
    eventMethod(doc, eventType, _events["default"].delegateUseCapture, true);
  }

  var eventOptions = options && options.events;

  for (var _i7 = 0; _i7 < docEvents.length; _i7++) {
    var _ref7;

    _ref7 = docEvents[_i7];
    var _ref8 = _ref7,
        type = _ref8.type,
        listener = _ref8.listener;
    eventMethod(doc, type, listener, eventOptions);
  }
}

var _default = {
  id: 'core/interactions',
  install: install,
  onDocSignal: onDocSignal,
  doOnInteractions: doOnInteractions,
  methodNames: methodNames
};
exports["default"] = _default;

});
var _$Interaction_18 = createModuleFactory(function (module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "PointerInfo", {
  enumerable: true,
  get: function get() {
    return _PointerInfo["default"];
  }
});
exports["default"] = exports.Interaction = exports._ProxyMethods = exports._ProxyValues = void 0;

var utils = _interopRequireWildcard(_$utils_56);

var _InteractEvent = _interopRequireWildcard(_$InteractEvent_15);

var _PointerInfo = _interopRequireDefault(_$PointerInfo_19);

var _scope = _$scope_24({});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _ProxyValues;

exports._ProxyValues = _ProxyValues;

(function (_ProxyValues) {
  _ProxyValues["interactable"] = "";
  _ProxyValues["element"] = "";
  _ProxyValues["prepared"] = "";
  _ProxyValues["pointerIsDown"] = "";
  _ProxyValues["pointerWasMoved"] = "";
  _ProxyValues["_proxy"] = "";
})(_ProxyValues || (exports._ProxyValues = _ProxyValues = {}));

var _ProxyMethods;

exports._ProxyMethods = _ProxyMethods;

(function (_ProxyMethods) {
  _ProxyMethods["start"] = "";
  _ProxyMethods["move"] = "";
  _ProxyMethods["end"] = "";
  _ProxyMethods["stop"] = "";
  _ProxyMethods["interacting"] = "";
})(_ProxyMethods || (exports._ProxyMethods = _ProxyMethods = {}));

var Interaction =
/*#__PURE__*/
function () {
  /** */
  function Interaction(_ref) {
    var _this = this;

    var pointerType = _ref.pointerType,
        signals = _ref.signals;

    _classCallCheck(this, Interaction);

    // current interactable being interacted with
    this.interactable = null; // the target element of the interactable

    this.element = null; // action that's ready to be fired on next move event

    this.prepared = {
      name: null,
      axis: null,
      edges: null
    }; // keep track of added pointers

    this.pointers = []; // pointerdown/mousedown/touchstart event

    this.downEvent = null;
    this.downPointer = {};
    this._latestPointer = {
      pointer: null,
      event: null,
      eventTarget: null
    }; // previous action event

    this.prevEvent = null;
    this.pointerIsDown = false;
    this.pointerWasMoved = false;
    this._interacting = false;
    this._ending = false;
    this._stopped = true;
    this._proxy = null;
    this.simulation = null;
    /**
     * @alias Interaction.prototype.move
     */

    this.doMove = utils.warnOnce(function (signalArg) {
      this.move(signalArg);
    }, 'The interaction.doMove() method has been renamed to interaction.move()');
    this.coords = {
      // Starting InteractEvent pointer coordinates
      start: utils.pointer.newCoords(),
      // Previous native pointer move event coordinates
      prev: utils.pointer.newCoords(),
      // current native pointer move event coordinates
      cur: utils.pointer.newCoords(),
      // Change in coordinates and time of the pointer
      delta: utils.pointer.newCoords(),
      // pointer velocity
      velocity: utils.pointer.newCoords()
    };
    this._signals = signals;
    this.pointerType = pointerType;
    var that = this;
    this._proxy = {};

    var _loop = function _loop(key) {
      Object.defineProperty(_this._proxy, key, {
        get: function get() {
          return that[key];
        }
      });
    };

    for (var key in _ProxyValues) {
      _loop(key);
    }

    var _loop2 = function _loop2(key) {
      Object.defineProperty(_this._proxy, key, {
        value: function value() {
          return that[key].apply(that, arguments);
        }
      });
    };

    for (var key in _ProxyMethods) {
      _loop2(key);
    }

    this._signals.fire('new', {
      interaction: this
    });
  }

  _createClass(Interaction, [{
    key: "pointerDown",
    value: function pointerDown(pointer, event, eventTarget) {
      var pointerIndex = this.updatePointer(pointer, event, eventTarget, true);

      this._signals.fire('down', {
        pointer: pointer,
        event: event,
        eventTarget: eventTarget,
        pointerIndex: pointerIndex,
        interaction: this
      });
    }
    /**
     * ```js
     * interact(target)
     *   .draggable({
     *     // disable the default drag start by down->move
     *     manualStart: true
     *   })
     *   // start dragging after the user holds the pointer down
     *   .on('hold', function (event) {
     *     var interaction = event.interaction
     *
     *     if (!interaction.interacting()) {
     *       interaction.start({ name: 'drag' },
     *                         event.interactable,
     *                         event.currentTarget)
     *     }
     * })
     * ```
     *
     * Start an action with the given Interactable and Element as tartgets. The
     * action must be enabled for the target Interactable and an appropriate
     * number of pointers must be held down - 1 for drag/resize, 2 for gesture.
     *
     * Use it with `interactable.<action>able({ manualStart: false })` to always
     * [start actions manually](https://github.com/taye/interact.js/issues/114)
     *
     * @param {object} action   The action to be performed - drag, resize, etc.
     * @param {Interactable} target  The Interactable to target
     * @param {Element} element The DOM Element to target
     * @return {object} interact
     */

  }, {
    key: "start",
    value: function start(action, interactable, element) {
      if (this.interacting() || !this.pointerIsDown || this.pointers.length < (action.name === _scope.ActionName.Gesture ? 2 : 1) || !interactable.options[action.name].enabled) {
        return false;
      }

      utils.copyAction(this.prepared, action);
      this.interactable = interactable;
      this.element = element;
      this.rect = interactable.getRect(element);
      this.edges = this.prepared.edges;
      this._stopped = false;
      this._interacting = this._doPhase({
        interaction: this,
        event: this.downEvent,
        phase: _InteractEvent.EventPhase.Start
      }) && !this._stopped;
      return this._interacting;
    }
  }, {
    key: "pointerMove",
    value: function pointerMove(pointer, event, eventTarget) {
      if (!this.simulation && !(this.modifiers && this.modifiers.endPrevented)) {
        this.updatePointer(pointer, event, eventTarget, false);
        utils.pointer.setCoords(this.coords.cur, this.pointers.map(function (p) {
          return p.pointer;
        }), this._now());
      }

      var duplicateMove = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
      var dx;
      var dy; // register movement greater than pointerMoveTolerance

      if (this.pointerIsDown && !this.pointerWasMoved) {
        dx = this.coords.cur.client.x - this.coords.start.client.x;
        dy = this.coords.cur.client.y - this.coords.start.client.y;
        this.pointerWasMoved = utils.hypot(dx, dy) > this.pointerMoveTolerance;
      }

      var signalArg = {
        pointer: pointer,
        pointerIndex: this.getPointerIndex(pointer),
        event: event,
        eventTarget: eventTarget,
        dx: dx,
        dy: dy,
        duplicate: duplicateMove,
        interaction: this
      };

      if (!duplicateMove) {
        // set pointer coordinate, time changes and velocity
        utils.pointer.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur);
        utils.pointer.setCoordVelocity(this.coords.velocity, this.coords.delta);
      }

      this._signals.fire('move', signalArg);

      if (!duplicateMove) {
        // if interacting, fire an 'action-move' signal etc
        if (this.interacting()) {
          this.move(signalArg);
        }

        if (this.pointerWasMoved) {
          utils.pointer.copyCoords(this.coords.prev, this.coords.cur);
        }
      }
    }
    /**
     * ```js
     * interact(target)
     *   .draggable(true)
     *   .on('dragmove', function (event) {
     *     if (someCondition) {
     *       // change the snap settings
     *       event.interactable.draggable({ snap: { targets: [] }})
     *       // fire another move event with re-calculated snap
     *       event.interaction.move()
     *     }
     *   })
     * ```
     *
     * Force a move of the current action at the same coordinates. Useful if
     * snap/restrict has been changed and you want a movement with the new
     * settings.
     */

  }, {
    key: "move",
    value: function move(signalArg) {
      signalArg = utils.extend({
        pointer: this._latestPointer.pointer,
        event: this._latestPointer.event,
        eventTarget: this._latestPointer.eventTarget,
        interaction: this
      }, signalArg || {});
      signalArg.phase = _InteractEvent.EventPhase.Move;

      this._doPhase(signalArg);
    } // End interact move events and stop auto-scroll unless simulation is running

  }, {
    key: "pointerUp",
    value: function pointerUp(pointer, event, eventTarget, curEventTarget) {
      var pointerIndex = this.getPointerIndex(pointer);

      if (pointerIndex === -1) {
        pointerIndex = this.updatePointer(pointer, event, eventTarget, false);
      }

      this._signals.fire(/cancel$/i.test(event.type) ? 'cancel' : 'up', {
        pointer: pointer,
        pointerIndex: pointerIndex,
        event: event,
        eventTarget: eventTarget,
        curEventTarget: curEventTarget,
        interaction: this
      });

      if (!this.simulation) {
        this.end(event);
      }

      this.pointerIsDown = false;
      this.removePointer(pointer, event);
    }
  }, {
    key: "documentBlur",
    value: function documentBlur(event) {
      this.end(event);

      this._signals.fire('blur', {
        event: event,
        interaction: this
      });
    }
    /**
     * ```js
     * interact(target)
     *   .draggable(true)
     *   .on('move', function (event) {
     *     if (event.pageX > 1000) {
     *       // end the current action
     *       event.interaction.end()
     *       // stop all further listeners from being called
     *       event.stopImmediatePropagation()
     *     }
     *   })
     * ```
     *
     * @param {PointerEvent} [event]
     */

  }, {
    key: "end",
    value: function end(event) {
      this._ending = true;
      event = event || this._latestPointer.event;
      var endPhaseResult;

      if (this.interacting()) {
        endPhaseResult = this._doPhase({
          event: event,
          interaction: this,
          phase: _InteractEvent.EventPhase.End
        });
      }

      this._ending = false;

      if (endPhaseResult === true) {
        this.stop();
      }
    }
  }, {
    key: "currentAction",
    value: function currentAction() {
      return this._interacting ? this.prepared.name : null;
    }
  }, {
    key: "interacting",
    value: function interacting() {
      return this._interacting;
    }
    /** */

  }, {
    key: "stop",
    value: function stop() {
      this._signals.fire('stop', {
        interaction: this
      });

      this.interactable = this.element = null;
      this._interacting = false;
      this._stopped = true;
      this.prepared.name = this.prevEvent = null;
    }
  }, {
    key: "getPointerIndex",
    value: function getPointerIndex(pointer) {
      var pointerId = utils.pointer.getPointerId(pointer); // mouse and pen interactions may have only one pointer

      return this.pointerType === 'mouse' || this.pointerType === 'pen' ? this.pointers.length - 1 : utils.arr.findIndex(this.pointers, function (curPointer) {
        return curPointer.id === pointerId;
      });
    }
  }, {
    key: "getPointerInfo",
    value: function getPointerInfo(pointer) {
      return this.pointers[this.getPointerIndex(pointer)];
    }
  }, {
    key: "updatePointer",
    value: function updatePointer(pointer, event, eventTarget, down) {
      var id = utils.pointer.getPointerId(pointer);
      var pointerIndex = this.getPointerIndex(pointer);
      var pointerInfo = this.pointers[pointerIndex];
      down = down === false ? false : down || /(down|start)$/i.test(event.type);

      if (!pointerInfo) {
        pointerInfo = new _PointerInfo["default"](id, pointer, event, null, null);
        pointerIndex = this.pointers.length;
        this.pointers.push(pointerInfo);
      } else {
        pointerInfo.pointer = pointer;
      }

      if (down) {
        this.pointerIsDown = true;

        if (!this.interacting()) {
          utils.pointer.setCoords(this.coords.start, this.pointers.map(function (p) {
            return p.pointer;
          }), this._now());
          utils.pointer.copyCoords(this.coords.cur, this.coords.start);
          utils.pointer.copyCoords(this.coords.prev, this.coords.start);
          utils.pointer.pointerExtend(this.downPointer, pointer);
          this.downEvent = event;
          pointerInfo.downTime = this.coords.cur.timeStamp;
          pointerInfo.downTarget = eventTarget;
          this.pointerWasMoved = false;
        }
      }

      this._updateLatestPointer(pointer, event, eventTarget);

      this._signals.fire('update-pointer', {
        pointer: pointer,
        event: event,
        eventTarget: eventTarget,
        down: down,
        pointerInfo: pointerInfo,
        pointerIndex: pointerIndex,
        interaction: this
      });

      return pointerIndex;
    }
  }, {
    key: "removePointer",
    value: function removePointer(pointer, event) {
      var pointerIndex = this.getPointerIndex(pointer);

      if (pointerIndex === -1) {
        return;
      }

      var pointerInfo = this.pointers[pointerIndex];

      this._signals.fire('remove-pointer', {
        pointer: pointer,
        event: event,
        pointerIndex: pointerIndex,
        pointerInfo: pointerInfo,
        interaction: this
      });

      this.pointers.splice(pointerIndex, 1);
    }
  }, {
    key: "_updateLatestPointer",
    value: function _updateLatestPointer(pointer, event, eventTarget) {
      this._latestPointer.pointer = pointer;
      this._latestPointer.event = event;
      this._latestPointer.eventTarget = eventTarget;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._latestPointer.pointer = null;
      this._latestPointer.event = null;
      this._latestPointer.eventTarget = null;
    }
  }, {
    key: "_createPreparedEvent",
    value: function _createPreparedEvent(event, phase, preEnd, type) {
      var actionName = this.prepared.name;
      return new _InteractEvent["default"](this, event, actionName, phase, this.element, null, preEnd, type);
    }
  }, {
    key: "_fireEvent",
    value: function _fireEvent(iEvent) {
      this.interactable.fire(iEvent);

      if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {
        this.prevEvent = iEvent;
      }
    }
  }, {
    key: "_doPhase",
    value: function _doPhase(signalArg) {
      var event = signalArg.event,
          phase = signalArg.phase,
          preEnd = signalArg.preEnd,
          type = signalArg.type;

      var beforeResult = this._signals.fire("before-action-".concat(phase), signalArg);

      if (beforeResult === false) {
        return false;
      }

      var iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type);

      var rect = this.rect;

      if (rect) {
        // update the rect modifications
        var edges = this.edges || this.prepared.edges || {
          left: true,
          right: true,
          top: true,
          bottom: true
        };

        if (edges.top) {
          rect.top += iEvent.delta.y;
        }

        if (edges.bottom) {
          rect.bottom += iEvent.delta.y;
        }

        if (edges.left) {
          rect.left += iEvent.delta.x;
        }

        if (edges.right) {
          rect.right += iEvent.delta.x;
        }

        rect.width = rect.right - rect.left;
        rect.height = rect.bottom - rect.top;
      }

      this._signals.fire("action-".concat(phase), signalArg);

      this._fireEvent(iEvent);

      this._signals.fire("after-action-".concat(phase), signalArg);

      return true;
    }
  }, {
    key: "_now",
    value: function _now() {
      return Date.now();
    }
  }, {
    key: "pointerMoveTolerance",
    get: function get() {
      return 1;
    }
  }]);

  return Interaction;
}();

exports.Interaction = Interaction;
var _default = Interaction;
exports["default"] = _default;

});
var _$arr_47 = {};
"use strict";

Object.defineProperty(_$arr_47, "__esModule", {
  value: true
});
_$arr_47.contains = contains;
_$arr_47.remove = remove;
_$arr_47.merge = merge;
_$arr_47.from = from;
_$arr_47.findIndex = findIndex;
_$arr_47.find = find;

function contains(array, target) {
  return array.indexOf(target) !== -1;
}

function remove(array, target) {
  return array.splice(array.indexOf(target), 1);
}

function merge(target, source) {
  for (var _i = 0; _i < source.length; _i++) {
    var _ref;

    _ref = source[_i];
    var item = _ref;
    target.push(item);
  }

  return target;
}

function from(source) {
  return merge([], source);
}

function findIndex(array, func) {
  for (var i = 0; i < array.length; i++) {
    if (func(array[i], i, array)) {
      return i;
    }
  }

  return -1;
}

function find(array, func) {
  return array[findIndex(array, func)];
}

var _$domObjects_50 = {};
"use strict";

Object.defineProperty(_$domObjects_50, "__esModule", {
  value: true
});
_$domObjects_50["default"] = void 0;
var domObjects = {
  init: init,
  document: null,
  DocumentFragment: null,
  SVGElement: null,
  SVGSVGElement: null,
  // eslint-disable-next-line no-undef
  SVGElementInstance: null,
  Element: null,
  HTMLElement: null,
  Event: null,
  Touch: null,
  PointerEvent: null
};

function blank() {}

var _default = domObjects;
_$domObjects_50["default"] = _default;

function init(window) {
  var win = window;
  domObjects.document = win.document;
  domObjects.DocumentFragment = win.DocumentFragment || blank;
  domObjects.SVGElement = win.SVGElement || blank;
  domObjects.SVGSVGElement = win.SVGSVGElement || blank;
  domObjects.SVGElementInstance = win.SVGElementInstance || blank;
  domObjects.Element = win.Element || blank;
  domObjects.HTMLElement = win.HTMLElement || domObjects.Element;
  domObjects.Event = win.Event;
  domObjects.Touch = win.Touch || blank;
  domObjects.PointerEvent = win.PointerEvent || win.MSPointerEvent;
}

var _$isWindow_58 = {};
"use strict";

Object.defineProperty(_$isWindow_58, "__esModule", {
  value: true
});
_$isWindow_58["default"] = void 0;

var ___default_58 = function _default(thing) {
  return !!(thing && thing.Window) && thing instanceof thing.Window;
};

_$isWindow_58["default"] = ___default_58;

var _$window_66 = {};
"use strict";

Object.defineProperty(_$window_66, "__esModule", {
  value: true
});
_$window_66.init = __init_66;
_$window_66.getWindow = getWindow;
_$window_66["default"] = void 0;

var _isWindow = _interopRequireDefault(_$isWindow_58);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var win = {
  realWindow: undefined,
  window: undefined,
  getWindow: getWindow,
  init: __init_66
};

function __init_66(window) {
  // get wrapped window if using Shadow DOM polyfill
  win.realWindow = window; // create a TextNode

  var el = window.document.createTextNode(''); // check if it's wrapped by a polyfill

  if (el.ownerDocument !== window.document && typeof window.wrap === 'function' && window.wrap(el) === el) {
    // use wrapped window
    window = window.wrap(window);
  }

  win.window = window;
}

if (typeof window === 'undefined') {
  win.window = undefined;
  win.realWindow = undefined;
} else {
  __init_66(window);
}

function getWindow(node) {
  if ((0, _isWindow["default"])(node)) {
    return node;
  }

  var rootNode = node.ownerDocument || node;
  return rootNode.defaultView || win.window;
}

win.init = __init_66;
var ___default_66 = win;
_$window_66["default"] = ___default_66;

var _$is_57 = {};
"use strict";

Object.defineProperty(_$is_57, "__esModule", {
  value: true
});
_$is_57.array = _$is_57.plainObject = _$is_57.element = _$is_57.string = _$is_57.bool = _$is_57.number = _$is_57.func = _$is_57.object = _$is_57.docFrag = _$is_57.window = void 0;

var ___isWindow_57 = ___interopRequireDefault_57(_$isWindow_58);

var _window2 = ___interopRequireDefault_57(_$window_66);

function ___interopRequireDefault_57(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __window_57 = function window(thing) {
  return thing === _window2["default"].window || (0, ___isWindow_57["default"])(thing);
};

_$is_57.window = __window_57;

var docFrag = function docFrag(thing) {
  return object(thing) && thing.nodeType === 11;
};

_$is_57.docFrag = docFrag;

var object = function object(thing) {
  return !!thing && _typeof(thing) === 'object';
};

_$is_57.object = object;

var func = function func(thing) {
  return typeof thing === 'function';
};

_$is_57.func = func;

var number = function number(thing) {
  return typeof thing === 'number';
};

_$is_57.number = number;

var bool = function bool(thing) {
  return typeof thing === 'boolean';
};

_$is_57.bool = bool;

var string = function string(thing) {
  return typeof thing === 'string';
};

_$is_57.string = string;

var element = function element(thing) {
  if (!thing || _typeof(thing) !== 'object') {
    return false;
  }

  var _window = _window2["default"].getWindow(thing) || _window2["default"].window;

  return /object|function/.test(_typeof(_window.Element)) ? thing instanceof _window.Element // DOM2
  : thing.nodeType === 1 && typeof thing.nodeName === 'string';
};

_$is_57.element = element;

var plainObject = function plainObject(thing) {
  return object(thing) && !!thing.constructor && /function Object\b/.test(thing.constructor.toString());
};

_$is_57.plainObject = plainObject;

var array = function array(thing) {
  return object(thing) && typeof thing.length !== 'undefined' && func(thing.splice);
};

_$is_57.array = array;

var _$browser_48 = {};
"use strict";

Object.defineProperty(_$browser_48, "__esModule", {
  value: true
});
_$browser_48["default"] = void 0;

var _domObjects = ___interopRequireDefault_48(_$domObjects_50);

var is = _interopRequireWildcard(_$is_57);

var _window = ___interopRequireDefault_48(_$window_66);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_48(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var browser = {
  init: __init_48,
  supportsTouch: null,
  supportsPointerEvent: null,
  isIOS7: null,
  isIOS: null,
  isIe9: null,
  isOperaMobile: null,
  prefixedMatchesSelector: null,
  pEventTypes: null,
  wheelEvent: null
};

function __init_48(window) {
  var Element = _domObjects["default"].Element;
  var navigator = _window["default"].window.navigator; // Does the browser support touch input?

  browser.supportsTouch = 'ontouchstart' in window || is.func(window.DocumentTouch) && _domObjects["default"].document instanceof window.DocumentTouch; // Does the browser support PointerEvents

  browser.supportsPointerEvent = navigator.pointerEnabled !== false && !!_domObjects["default"].PointerEvent;
  browser.isIOS = /iP(hone|od|ad)/.test(navigator.platform); // scrolling doesn't change the result of getClientRects on iOS 7

  browser.isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\d]/.test(navigator.appVersion);
  browser.isIe9 = /MSIE 9/.test(navigator.userAgent); // Opera Mobile must be handled differently

  browser.isOperaMobile = navigator.appName === 'Opera' && browser.supportsTouch && /Presto/.test(navigator.userAgent); // prefix matchesSelector

  browser.prefixedMatchesSelector = 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector';
  browser.pEventTypes = browser.supportsPointerEvent ? _domObjects["default"].PointerEvent === window.MSPointerEvent ? {
    up: 'MSPointerUp',
    down: 'MSPointerDown',
    over: 'mouseover',
    out: 'mouseout',
    move: 'MSPointerMove',
    cancel: 'MSPointerCancel'
  } : {
    up: 'pointerup',
    down: 'pointerdown',
    over: 'pointerover',
    out: 'pointerout',
    move: 'pointermove',
    cancel: 'pointercancel'
  } : null; // because Webkit and Opera still use 'mousewheel' event type

  browser.wheelEvent = 'onmousewheel' in _domObjects["default"].document ? 'mousewheel' : 'wheel';
}

var ___default_48 = browser;
_$browser_48["default"] = ___default_48;

var _$domUtils_51 = {};
"use strict";

Object.defineProperty(_$domUtils_51, "__esModule", {
  value: true
});
_$domUtils_51.nodeContains = nodeContains;
_$domUtils_51.closest = closest;
_$domUtils_51.parentNode = parentNode;
_$domUtils_51.matchesSelector = matchesSelector;
_$domUtils_51.indexOfDeepestElement = indexOfDeepestElement;
_$domUtils_51.matchesUpTo = matchesUpTo;
_$domUtils_51.getActualElement = getActualElement;
_$domUtils_51.getScrollXY = getScrollXY;
_$domUtils_51.getElementClientRect = getElementClientRect;
_$domUtils_51.getElementRect = getElementRect;
_$domUtils_51.getPath = getPath;
_$domUtils_51.trySelector = trySelector;

var _browser = ___interopRequireDefault_51(_$browser_48);

var ___domObjects_51 = ___interopRequireDefault_51(_$domObjects_50);

var __is_51 = ___interopRequireWildcard_51(_$is_57);

var ___window_51 = ___interopRequireDefault_51(_$window_66);

function ___interopRequireWildcard_51(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_51(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function nodeContains(parent, child) {
  while (child) {
    if (child === parent) {
      return true;
    }

    child = child.parentNode;
  }

  return false;
}

function closest(element, selector) {
  while (__is_51.element(element)) {
    if (matchesSelector(element, selector)) {
      return element;
    }

    element = parentNode(element);
  }

  return null;
}

function parentNode(node) {
  var parent = node.parentNode;

  if (__is_51.docFrag(parent)) {
    // skip past #shado-root fragments
    // tslint:disable-next-line
    while ((parent = parent.host) && __is_51.docFrag(parent)) {
      continue;
    }

    return parent;
  }

  return parent;
}

function matchesSelector(element, selector) {
  // remove /deep/ from selectors if shadowDOM polyfill is used
  if (___window_51["default"].window !== ___window_51["default"].realWindow) {
    selector = selector.replace(/\/deep\//g, ' ');
  }

  return element[_browser["default"].prefixedMatchesSelector](selector);
}

var getParent = function getParent(el) {
  return el.parentNode ? el.parentNode : el.host;
}; // Test for the element that's "above" all other qualifiers


function indexOfDeepestElement(elements) {
  var deepestZoneParents = [];
  var dropzoneParents = [];
  var dropzone;
  var deepestZone = elements[0];
  var index = deepestZone ? 0 : -1;
  var parent;
  var child;
  var i;
  var n;

  for (i = 1; i < elements.length; i++) {
    dropzone = elements[i]; // an element might belong to multiple selector dropzones

    if (!dropzone || dropzone === deepestZone) {
      continue;
    }

    if (!deepestZone) {
      deepestZone = dropzone;
      index = i;
      continue;
    } // check if the deepest or current are document.documentElement or document.rootElement
    // - if the current dropzone is, do nothing and continue


    if (dropzone.parentNode === dropzone.ownerDocument) {
      continue;
    } // - if deepest is, update with the current dropzone and continue to next
    else if (deepestZone.parentNode === dropzone.ownerDocument) {
        deepestZone = dropzone;
        index = i;
        continue;
      }

    if (!deepestZoneParents.length) {
      parent = deepestZone;

      while (getParent(parent) && getParent(parent) !== parent.ownerDocument) {
        deepestZoneParents.unshift(parent);
        parent = getParent(parent);
      }
    } // if this element is an svg element and the current deepest is
    // an HTMLElement


    if (deepestZone instanceof ___domObjects_51["default"].HTMLElement && dropzone instanceof ___domObjects_51["default"].SVGElement && !(dropzone instanceof ___domObjects_51["default"].SVGSVGElement)) {
      if (dropzone === deepestZone.parentNode) {
        continue;
      }

      parent = dropzone.ownerSVGElement;
    } else {
      parent = dropzone;
    }

    dropzoneParents = [];

    while (parent.parentNode !== parent.ownerDocument) {
      dropzoneParents.unshift(parent);
      parent = getParent(parent);
    }

    n = 0; // get (position of last common ancestor) + 1

    while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {
      n++;
    }

    var parents = [dropzoneParents[n - 1], dropzoneParents[n], deepestZoneParents[n]];
    child = parents[0].lastChild;

    while (child) {
      if (child === parents[1]) {
        deepestZone = dropzone;
        index = i;
        deepestZoneParents = [];
        break;
      } else if (child === parents[2]) {
        break;
      }

      child = child.previousSibling;
    }
  }

  return index;
}

function matchesUpTo(element, selector, limit) {
  while (__is_51.element(element)) {
    if (matchesSelector(element, selector)) {
      return true;
    }

    element = parentNode(element);

    if (element === limit) {
      return matchesSelector(element, selector);
    }
  }

  return false;
}

function getActualElement(element) {
  return element instanceof ___domObjects_51["default"].SVGElementInstance ? element.correspondingUseElement : element;
}

function getScrollXY(relevantWindow) {
  relevantWindow = relevantWindow || ___window_51["default"].window;
  return {
    x: relevantWindow.scrollX || relevantWindow.document.documentElement.scrollLeft,
    y: relevantWindow.scrollY || relevantWindow.document.documentElement.scrollTop
  };
}

function getElementClientRect(element) {
  var clientRect = element instanceof ___domObjects_51["default"].SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];
  return clientRect && {
    left: clientRect.left,
    right: clientRect.right,
    top: clientRect.top,
    bottom: clientRect.bottom,
    width: clientRect.width || clientRect.right - clientRect.left,
    height: clientRect.height || clientRect.bottom - clientRect.top
  };
}

function getElementRect(element) {
  var clientRect = getElementClientRect(element);

  if (!_browser["default"].isIOS7 && clientRect) {
    var scroll = getScrollXY(___window_51["default"].getWindow(element));
    clientRect.left += scroll.x;
    clientRect.right += scroll.x;
    clientRect.top += scroll.y;
    clientRect.bottom += scroll.y;
  }

  return clientRect;
}

function getPath(node) {
  var path = [];

  while (node) {
    path.push(node);
    node = parentNode(node);
  }

  return path;
}

function trySelector(value) {
  if (!__is_51.string(value)) {
    return false;
  } // an exception will be raised if it is invalid


  ___domObjects_51["default"].document.querySelector(value);

  return true;
}

var _$clone_49 = {};
"use strict";

Object.defineProperty(_$clone_49, "__esModule", {
  value: true
});
_$clone_49["default"] = clone;

var arr = ___interopRequireWildcard_49(_$arr_47);

var __is_49 = ___interopRequireWildcard_49(_$is_57);

function ___interopRequireWildcard_49(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function clone(source) {
  var dest = {};

  for (var prop in source) {
    var value = source[prop];

    if (__is_49.plainObject(value)) {
      dest[prop] = clone(value);
    } else if (__is_49.array(value)) {
      dest[prop] = arr.from(value);
    } else {
      dest[prop] = value;
    }
  }

  return dest;
}

var _$pointerExtend_60 = {};
"use strict";

Object.defineProperty(_$pointerExtend_60, "__esModule", {
  value: true
});
_$pointerExtend_60["default"] = void 0;

function pointerExtend(dest, source) {
  for (var prop in source) {
    var prefixedPropREs = pointerExtend.prefixedPropREs;
    var deprecated = false; // skip deprecated prefixed properties

    for (var vendor in prefixedPropREs) {
      if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {
        deprecated = true;
        break;
      }
    }

    if (!deprecated && typeof source[prop] !== 'function') {
      dest[prop] = source[prop];
    }
  }

  return dest;
}

pointerExtend.prefixedPropREs = {
  webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/
};
var ___default_60 = pointerExtend;
_$pointerExtend_60["default"] = ___default_60;

var _$hypot_55 = {};
"use strict";

Object.defineProperty(_$hypot_55, "__esModule", {
  value: true
});
_$hypot_55["default"] = void 0;

var ___default_55 = function _default(x, y) {
  return Math.sqrt(x * x + y * y);
};

_$hypot_55["default"] = ___default_55;

var _$pointerUtils_61 = {};
"use strict";

Object.defineProperty(_$pointerUtils_61, "__esModule", {
  value: true
});
_$pointerUtils_61["default"] = void 0;

var ___browser_61 = ___interopRequireDefault_61(_$browser_48);

var ___domObjects_61 = ___interopRequireDefault_61(_$domObjects_50);

var domUtils = ___interopRequireWildcard_61(_$domUtils_51);

var _hypot = ___interopRequireDefault_61(_$hypot_55);

var __is_61 = ___interopRequireWildcard_61(_$is_57);

var _pointerExtend = ___interopRequireDefault_61(_$pointerExtend_60);

function ___interopRequireWildcard_61(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_61(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var pointerUtils = {
  copyCoords: function copyCoords(dest, src) {
    dest.page = dest.page || {};
    dest.page.x = src.page.x;
    dest.page.y = src.page.y;
    dest.client = dest.client || {};
    dest.client.x = src.client.x;
    dest.client.y = src.client.y;
    dest.timeStamp = src.timeStamp;
  },
  setCoordDeltas: function setCoordDeltas(targetObj, prev, cur) {
    targetObj.page.x = cur.page.x - prev.page.x;
    targetObj.page.y = cur.page.y - prev.page.y;
    targetObj.client.x = cur.client.x - prev.client.x;
    targetObj.client.y = cur.client.y - prev.client.y;
    targetObj.timeStamp = cur.timeStamp - prev.timeStamp;
  },
  setCoordVelocity: function setCoordVelocity(targetObj, delta) {
    var dt = Math.max(delta.timeStamp / 1000, 0.001);
    targetObj.page.x = delta.page.x / dt;
    targetObj.page.y = delta.page.y / dt;
    targetObj.client.x = delta.client.x / dt;
    targetObj.client.y = delta.client.y / dt;
    targetObj.timeStamp = dt;
  },
  isNativePointer: function isNativePointer(pointer) {
    return pointer instanceof ___domObjects_61["default"].Event || pointer instanceof ___domObjects_61["default"].Touch;
  },
  // Get specified X/Y coords for mouse or event.touches[0]
  getXY: function getXY(type, pointer, xy) {
    xy = xy || {};
    type = type || 'page';
    xy.x = pointer[type + 'X'];
    xy.y = pointer[type + 'Y'];
    return xy;
  },
  getPageXY: function getPageXY(pointer, page) {
    page = page || {
      x: 0,
      y: 0
    }; // Opera Mobile handles the viewport and scrolling oddly

    if (___browser_61["default"].isOperaMobile && pointerUtils.isNativePointer(pointer)) {
      pointerUtils.getXY('screen', pointer, page);
      page.x += window.scrollX;
      page.y += window.scrollY;
    } else {
      pointerUtils.getXY('page', pointer, page);
    }

    return page;
  },
  getClientXY: function getClientXY(pointer, client) {
    client = client || {};

    if (___browser_61["default"].isOperaMobile && pointerUtils.isNativePointer(pointer)) {
      // Opera Mobile handles the viewport and scrolling oddly
      pointerUtils.getXY('screen', pointer, client);
    } else {
      pointerUtils.getXY('client', pointer, client);
    }

    return client;
  },
  getPointerId: function getPointerId(pointer) {
    return __is_61.number(pointer.pointerId) ? pointer.pointerId : pointer.identifier;
  },
  setCoords: function setCoords(targetObj, pointers, timeStamp) {
    var pointer = pointers.length > 1 ? pointerUtils.pointerAverage(pointers) : pointers[0];
    var tmpXY = {};
    pointerUtils.getPageXY(pointer, tmpXY);
    targetObj.page.x = tmpXY.x;
    targetObj.page.y = tmpXY.y;
    pointerUtils.getClientXY(pointer, tmpXY);
    targetObj.client.x = tmpXY.x;
    targetObj.client.y = tmpXY.y;
    targetObj.timeStamp = timeStamp;
  },
  pointerExtend: _pointerExtend["default"],
  getTouchPair: function getTouchPair(event) {
    var touches = []; // array of touches is supplied

    if (__is_61.array(event)) {
      touches[0] = event[0];
      touches[1] = event[1];
    } // an event
    else {
        if (event.type === 'touchend') {
          if (event.touches.length === 1) {
            touches[0] = event.touches[0];
            touches[1] = event.changedTouches[0];
          } else if (event.touches.length === 0) {
            touches[0] = event.changedTouches[0];
            touches[1] = event.changedTouches[1];
          }
        } else {
          touches[0] = event.touches[0];
          touches[1] = event.touches[1];
        }
      }

    return touches;
  },
  pointerAverage: function pointerAverage(pointers) {
    var average = {
      pageX: 0,
      pageY: 0,
      clientX: 0,
      clientY: 0,
      screenX: 0,
      screenY: 0
    };

    for (var _i = 0; _i < pointers.length; _i++) {
      var _ref;

      _ref = pointers[_i];
      var pointer = _ref;

      for (var _prop in average) {
        average[_prop] += pointer[_prop];
      }
    }

    for (var prop in average) {
      average[prop] /= pointers.length;
    }

    return average;
  },
  touchBBox: function touchBBox(event) {
    if (!event.length && !(event.touches && event.touches.length > 1)) {
      return null;
    }

    var touches = pointerUtils.getTouchPair(event);
    var minX = Math.min(touches[0].pageX, touches[1].pageX);
    var minY = Math.min(touches[0].pageY, touches[1].pageY);
    var maxX = Math.max(touches[0].pageX, touches[1].pageX);
    var maxY = Math.max(touches[0].pageY, touches[1].pageY);
    return {
      x: minX,
      y: minY,
      left: minX,
      top: minY,
      right: maxX,
      bottom: maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  },
  touchDistance: function touchDistance(event, deltaSource) {
    var sourceX = deltaSource + 'X';
    var sourceY = deltaSource + 'Y';
    var touches = pointerUtils.getTouchPair(event);
    var dx = touches[0][sourceX] - touches[1][sourceX];
    var dy = touches[0][sourceY] - touches[1][sourceY];
    return (0, _hypot["default"])(dx, dy);
  },
  touchAngle: function touchAngle(event, deltaSource) {
    var sourceX = deltaSource + 'X';
    var sourceY = deltaSource + 'Y';
    var touches = pointerUtils.getTouchPair(event);
    var dx = touches[1][sourceX] - touches[0][sourceX];
    var dy = touches[1][sourceY] - touches[0][sourceY];
    var angle = 180 * Math.atan2(dy, dx) / Math.PI;
    return angle;
  },
  getPointerType: function getPointerType(pointer) {
    return __is_61.string(pointer.pointerType) ? pointer.pointerType : __is_61.number(pointer.pointerType) ? [undefined, undefined, 'touch', 'pen', 'mouse'][pointer.pointerType] // if the PointerEvent API isn't available, then the "pointer" must
    // be either a MouseEvent, TouchEvent, or Touch object
    : /touch/.test(pointer.type) || pointer instanceof ___domObjects_61["default"].Touch ? 'touch' : 'mouse';
  },
  // [ event.target, event.currentTarget ]
  getEventTargets: function getEventTargets(event) {
    var path = __is_61.func(event.composedPath) ? event.composedPath() : event.path;
    return [domUtils.getActualElement(path ? path[0] : event.target), domUtils.getActualElement(event.currentTarget)];
  },
  newCoords: function newCoords() {
    return {
      page: {
        x: 0,
        y: 0
      },
      client: {
        x: 0,
        y: 0
      },
      timeStamp: 0
    };
  },
  coordsToEvent: function coordsToEvent(coords) {
    var event = {
      coords: coords,

      get page() {
        return this.coords.page;
      },

      get client() {
        return this.coords.client;
      },

      get timeStamp() {
        return this.coords.timeStamp;
      },

      get pageX() {
        return this.coords.page.x;
      },

      get pageY() {
        return this.coords.page.y;
      },

      get clientX() {
        return this.coords.client.x;
      },

      get clientY() {
        return this.coords.client.y;
      },

      get pointerId() {
        return this.coords.pointerId;
      },

      get target() {
        return this.coords.target;
      },

      get type() {
        return this.coords.type;
      },

      get pointerType() {
        return this.coords.pointerType;
      },

      get buttons() {
        return this.coords.buttons;
      }

    };
    return event;
  }
};
var ___default_61 = pointerUtils;
_$pointerUtils_61["default"] = ___default_61;

var _$events_52 = {};
"use strict";

Object.defineProperty(_$events_52, "__esModule", {
  value: true
});
_$events_52["default"] = _$events_52.FakeEvent = void 0;

/* removed: var _$arr_47 = require("./arr"); */;

var __domUtils_52 = ___interopRequireWildcard_52(_$domUtils_51);

var __is_52 = ___interopRequireWildcard_52(_$is_57);

var ___pointerExtend_52 = ___interopRequireDefault_52(_$pointerExtend_60);

var _pointerUtils = ___interopRequireDefault_52(_$pointerUtils_61);

function ___interopRequireDefault_52(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_52(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var elements = [];
var targets = [];
var delegatedEvents = {};
var documents = [];

function add(element, type, listener, optionalArg) {
  var options = getOptions(optionalArg);
  var elementIndex = elements.indexOf(element);
  var target = targets[elementIndex];

  if (!target) {
    target = {
      events: {},
      typeCount: 0
    };
    elementIndex = elements.push(element) - 1;
    targets.push(target);
  }

  if (!target.events[type]) {
    target.events[type] = [];
    target.typeCount++;
  }

  if (!(0, _$arr_47.contains)(target.events[type], listener)) {
    element.addEventListener(type, listener, events.supportsOptions ? options : !!options.capture);
    target.events[type].push(listener);
  }
}

function __remove_52(element, type, listener, optionalArg) {
  var options = getOptions(optionalArg);
  var elementIndex = elements.indexOf(element);
  var target = targets[elementIndex];

  if (!target || !target.events) {
    return;
  }

  if (type === 'all') {
    for (type in target.events) {
      if (target.events.hasOwnProperty(type)) {
        __remove_52(element, type, 'all');
      }
    }

    return;
  }

  if (target.events[type]) {
    var len = target.events[type].length;

    if (listener === 'all') {
      for (var i = 0; i < len; i++) {
        __remove_52(element, type, target.events[type][i], options);
      }

      return;
    } else {
      for (var _i = 0; _i < len; _i++) {
        if (target.events[type][_i] === listener) {
          element.removeEventListener(type, listener, events.supportsOptions ? options : !!options.capture);
          target.events[type].splice(_i, 1);
          break;
        }
      }
    }

    if (target.events[type] && target.events[type].length === 0) {
      target.events[type] = null;
      target.typeCount--;
    }
  }

  if (!target.typeCount) {
    targets.splice(elementIndex, 1);
    elements.splice(elementIndex, 1);
  }
}

function addDelegate(selector, context, type, listener, optionalArg) {
  var options = getOptions(optionalArg);

  if (!delegatedEvents[type]) {
    delegatedEvents[type] = {
      contexts: [],
      listeners: [],
      selectors: []
    }; // add delegate listener functions

    for (var _i2 = 0; _i2 < documents.length; _i2++) {
      var doc = documents[_i2];
      add(doc, type, delegateListener);
      add(doc, type, delegateUseCapture, true);
    }
  }

  var delegated = delegatedEvents[type];
  var index;

  for (index = delegated.selectors.length - 1; index >= 0; index--) {
    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {
      break;
    }
  }

  if (index === -1) {
    index = delegated.selectors.length;
    delegated.selectors.push(selector);
    delegated.contexts.push(context);
    delegated.listeners.push([]);
  } // keep listener and capture and passive flags


  delegated.listeners[index].push([listener, !!options.capture, options.passive]);
}

function removeDelegate(selector, context, type, listener, optionalArg) {
  var options = getOptions(optionalArg);
  var delegated = delegatedEvents[type];
  var matchFound = false;
  var index;

  if (!delegated) {
    return;
  } // count from last index of delegated to 0


  for (index = delegated.selectors.length - 1; index >= 0; index--) {
    // look for matching selector and context Node
    if (delegated.selectors[index] === selector && delegated.contexts[index] === context) {
      var listeners = delegated.listeners[index]; // each item of the listeners array is an array: [function, capture, passive]

      for (var i = listeners.length - 1; i >= 0; i--) {
        var _listeners$i = _slicedToArray(listeners[i], 3),
            fn = _listeners$i[0],
            capture = _listeners$i[1],
            passive = _listeners$i[2]; // check if the listener functions and capture and passive flags match


        if (fn === listener && capture === !!options.capture && passive === options.passive) {
          // remove the listener from the array of listeners
          listeners.splice(i, 1); // if all listeners for this interactable have been removed
          // remove the interactable from the delegated arrays

          if (!listeners.length) {
            delegated.selectors.splice(index, 1);
            delegated.contexts.splice(index, 1);
            delegated.listeners.splice(index, 1); // remove delegate function from context

            __remove_52(context, type, delegateListener);
            __remove_52(context, type, delegateUseCapture, true); // remove the arrays if they are empty

            if (!delegated.selectors.length) {
              delegatedEvents[type] = null;
            }
          } // only remove one listener


          matchFound = true;
          break;
        }
      }

      if (matchFound) {
        break;
      }
    }
  }
} // bound to the interactable context when a DOM event
// listener is added to a selector interactable


function delegateListener(event, optionalArg) {
  var options = getOptions(optionalArg);
  var fakeEvent = new FakeEvent(event);
  var delegated = delegatedEvents[event.type];

  var _pointerUtils$getEven = _pointerUtils["default"].getEventTargets(event),
      _pointerUtils$getEven2 = _slicedToArray(_pointerUtils$getEven, 1),
      eventTarget = _pointerUtils$getEven2[0];

  var element = eventTarget; // climb up document tree looking for selector matches

  while (__is_52.element(element)) {
    for (var i = 0; i < delegated.selectors.length; i++) {
      var selector = delegated.selectors[i];
      var context = delegated.contexts[i];

      if (__domUtils_52.matchesSelector(element, selector) && __domUtils_52.nodeContains(context, eventTarget) && __domUtils_52.nodeContains(context, element)) {
        var listeners = delegated.listeners[i];
        fakeEvent.currentTarget = element;

        for (var _i3 = 0; _i3 < listeners.length; _i3++) {
          var _ref;

          _ref = listeners[_i3];

          var _ref2 = _ref,
              _ref3 = _slicedToArray(_ref2, 3),
              fn = _ref3[0],
              capture = _ref3[1],
              passive = _ref3[2];

          if (capture === !!options.capture && passive === options.passive) {
            fn(fakeEvent);
          }
        }
      }
    }

    element = __domUtils_52.parentNode(element);
  }
}

function delegateUseCapture(event) {
  return delegateListener.call(this, event, true);
}

function getOptions(param) {
  return __is_52.object(param) ? param : {
    capture: param
  };
}

var FakeEvent =
/*#__PURE__*/
function () {
  function FakeEvent(originalEvent) {
    _classCallCheck(this, FakeEvent);

    this.originalEvent = originalEvent; // duplicate the event so that currentTarget can be changed

    (0, ___pointerExtend_52["default"])(this, originalEvent);
  }

  _createClass(FakeEvent, [{
    key: "preventOriginalDefault",
    value: function preventOriginalDefault() {
      this.originalEvent.preventDefault();
    }
  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this.originalEvent.stopPropagation();
    }
  }, {
    key: "stopImmediatePropagation",
    value: function stopImmediatePropagation() {
      this.originalEvent.stopImmediatePropagation();
    }
  }]);

  return FakeEvent;
}();

_$events_52.FakeEvent = FakeEvent;
var events = {
  add: add,
  remove: __remove_52,
  addDelegate: addDelegate,
  removeDelegate: removeDelegate,
  delegateListener: delegateListener,
  delegateUseCapture: delegateUseCapture,
  delegatedEvents: delegatedEvents,
  documents: documents,
  supportsOptions: false,
  supportsPassive: false,
  _elements: elements,
  _targets: targets,
  init: function init(window) {
    window.document.createElement('div').addEventListener('test', null, {
      get capture() {
        return events.supportsOptions = true;
      },

      get passive() {
        return events.supportsPassive = true;
      }

    });
  }
};
var ___default_52 = events;
_$events_52["default"] = ___default_52;

var _$extend_53 = {};
"use strict";

Object.defineProperty(_$extend_53, "__esModule", {
  value: true
});
_$extend_53["default"] = extend;

function extend(dest, source) {
  for (var prop in source) {
    dest[prop] = source[prop];
  }

  return dest;
}

var _$rect_63 = {};
"use strict";

Object.defineProperty(_$rect_63, "__esModule", {
  value: true
});
_$rect_63.getStringOptionResult = getStringOptionResult;
_$rect_63.resolveRectLike = resolveRectLike;
_$rect_63.rectToXY = rectToXY;
_$rect_63.xywhToTlbr = xywhToTlbr;
_$rect_63.tlbrToXywh = tlbrToXywh;
_$rect_63["default"] = void 0;

/* removed: var _$domUtils_51 = require("./domUtils"); */;

var _extend = ___interopRequireDefault_63(_$extend_53);

var __is_63 = ___interopRequireWildcard_63(_$is_57);

function ___interopRequireWildcard_63(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_63(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function getStringOptionResult(value, interactable, element) {
  if (value === 'parent') {
    return (0, _$domUtils_51.parentNode)(element);
  }

  if (value === 'self') {
    return interactable.getRect(element);
  }

  return (0, _$domUtils_51.closest)(element, value);
}

function resolveRectLike(value, interactable, element, functionArgs) {
  if (__is_63.string(value)) {
    value = getStringOptionResult(value, interactable, element);
  } else if (__is_63.func(value)) {
    value = value.apply(void 0, _toConsumableArray(functionArgs));
  }

  if (__is_63.element(value)) {
    value = (0, _$domUtils_51.getElementRect)(value);
  }

  return value;
}

function rectToXY(rect) {
  return rect && {
    x: 'x' in rect ? rect.x : rect.left,
    y: 'y' in rect ? rect.y : rect.top
  };
}

function xywhToTlbr(rect) {
  if (rect && !('left' in rect && 'top' in rect)) {
    rect = (0, _extend["default"])({}, rect);
    rect.left = rect.x || 0;
    rect.top = rect.y || 0;
    rect.right = rect.right || rect.left + rect.width;
    rect.bottom = rect.bottom || rect.top + rect.height;
  }

  return rect;
}

function tlbrToXywh(rect) {
  if (rect && !('x' in rect && 'y' in rect)) {
    rect = (0, _extend["default"])({}, rect);
    rect.x = rect.left || 0;
    rect.y = rect.top || 0;
    rect.width = rect.width || rect.right - rect.x;
    rect.height = rect.height || rect.bottom - rect.y;
  }

  return rect;
}

var ___default_63 = {
  getStringOptionResult: getStringOptionResult,
  resolveRectLike: resolveRectLike,
  rectToXY: rectToXY,
  xywhToTlbr: xywhToTlbr,
  tlbrToXywh: tlbrToXywh
};
_$rect_63["default"] = ___default_63;

var _$getOriginXY_54 = {};
"use strict";

Object.defineProperty(_$getOriginXY_54, "__esModule", {
  value: true
});
_$getOriginXY_54["default"] = ___default_54;

/* removed: var _$rect_63 = require("./rect"); */;

function ___default_54(target, element, action) {
  var actionOptions = target.options[action];
  var actionOrigin = actionOptions && actionOptions.origin;
  var origin = actionOrigin || target.options.origin;
  var originRect = (0, _$rect_63.resolveRectLike)(origin, target, element, [target && element]);
  return (0, _$rect_63.rectToXY)(originRect) || {
    x: 0,
    y: 0
  };
}

var _$normalizeListeners_59 = {};
"use strict";

Object.defineProperty(_$normalizeListeners_59, "__esModule", {
  value: true
});
_$normalizeListeners_59["default"] = normalize;

var ___extend_59 = ___interopRequireDefault_59(_$extend_53);

var __is_59 = ___interopRequireWildcard_59(_$is_57);

function ___interopRequireWildcard_59(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_59(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function normalize(type, listeners, result) {
  result = result || {};

  if (__is_59.string(type) && type.search(' ') !== -1) {
    type = split(type);
  }

  if (__is_59.array(type)) {
    return type.reduce(function (acc, t) {
      return (0, ___extend_59["default"])(acc, normalize(t, listeners, result));
    }, result);
  } // ({ type: fn }) -> ('', { type: fn })


  if (__is_59.object(type)) {
    listeners = type;
    type = '';
  }

  if (__is_59.func(listeners)) {
    result[type] = result[type] || [];
    result[type].push(listeners);
  } else if (__is_59.array(listeners)) {
    for (var _i = 0; _i < listeners.length; _i++) {
      var _ref;

      _ref = listeners[_i];
      var l = _ref;
      normalize(type, l, result);
    }
  } else if (__is_59.object(listeners)) {
    for (var prefix in listeners) {
      var combinedTypes = split(prefix).map(function (p) {
        return "".concat(type).concat(p);
      });
      normalize(combinedTypes, listeners[prefix], result);
    }
  }

  return result;
}

function split(type) {
  return type.trim().split(/ +/);
}

var _$raf_62 = {};
"use strict";

Object.defineProperty(_$raf_62, "__esModule", {
  value: true
});
_$raf_62["default"] = void 0;
var lastTime = 0;

var _request;

var _cancel;

function __init_62(window) {
  _request = window.requestAnimationFrame;
  _cancel = window.cancelAnimationFrame;

  if (!_request) {
    var vendors = ['ms', 'moz', 'webkit', 'o'];

    for (var _i = 0; _i < vendors.length; _i++) {
      var vendor = vendors[_i];
      _request = window["".concat(vendor, "RequestAnimationFrame")];
      _cancel = window["".concat(vendor, "CancelAnimationFrame")] || window["".concat(vendor, "CancelRequestAnimationFrame")];
    }
  }

  if (!_request) {
    _request = function request(callback) {
      var currTime = Date.now();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime)); // eslint-disable-next-line standard/no-callback-literal

      var token = setTimeout(function () {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return token;
    };

    _cancel = function cancel(token) {
      return clearTimeout(token);
    };
  }
}

var ___default_62 = {
  request: function request(callback) {
    return _request(callback);
  },
  cancel: function cancel(token) {
    return _cancel(token);
  },
  init: __init_62
};
_$raf_62["default"] = ___default_62;

var _$Signals_46 = {};
"use strict";

Object.defineProperty(_$Signals_46, "__esModule", {
  value: true
});
_$Signals_46["default"] = void 0;

function ___classCallCheck_46(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ___defineProperties_46(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ___createClass_46(Constructor, protoProps, staticProps) { if (protoProps) ___defineProperties_46(Constructor.prototype, protoProps); if (staticProps) ___defineProperties_46(Constructor, staticProps); return Constructor; }

var Signals =
/*#__PURE__*/
function () {
  function Signals() {
    ___classCallCheck_46(this, Signals);

    this.listeners = {};
  }

  ___createClass_46(Signals, [{
    key: "on",
    value: function on(name, listener) {
      if (!this.listeners[name]) {
        this.listeners[name] = [listener];
        return;
      }

      this.listeners[name].push(listener);
    }
  }, {
    key: "off",
    value: function off(name, listener) {
      if (!this.listeners[name]) {
        return;
      }

      var index = this.listeners[name].indexOf(listener);

      if (index !== -1) {
        this.listeners[name].splice(index, 1);
      }
    }
  }, {
    key: "fire",
    value: function fire(name, arg) {
      var targetListeners = this.listeners[name];

      if (!targetListeners) {
        return;
      }

      for (var _i = 0; _i < targetListeners.length; _i++) {
        var _ref;

        _ref = targetListeners[_i];
        var listener = _ref;

        if (listener(arg, name) === false) {
          return false;
        }
      }
    }
  }]);

  return Signals;
}();

var ___default_46 = Signals;
_$Signals_46["default"] = ___default_46;

var _$utils_56 = {};
"use strict";

Object.defineProperty(_$utils_56, "__esModule", {
  value: true
});
_$utils_56.warnOnce = warnOnce;
_$utils_56._getQBezierValue = _getQBezierValue;
_$utils_56.getQuadraticCurvePoint = getQuadraticCurvePoint;
_$utils_56.easeOutQuad = easeOutQuad;
_$utils_56.copyAction = copyAction;
Object.defineProperty(_$utils_56, "win", {
  enumerable: true,
  get: function get() {
    return ___window_56["default"];
  }
});
Object.defineProperty(_$utils_56, "browser", {
  enumerable: true,
  get: function get() {
    return ___browser_56["default"];
  }
});
Object.defineProperty(_$utils_56, "clone", {
  enumerable: true,
  get: function get() {
    return _clone["default"];
  }
});
Object.defineProperty(_$utils_56, "events", {
  enumerable: true,
  get: function get() {
    return _events["default"];
  }
});
Object.defineProperty(_$utils_56, "extend", {
  enumerable: true,
  get: function get() {
    return ___extend_56["default"];
  }
});
Object.defineProperty(_$utils_56, "getOriginXY", {
  enumerable: true,
  get: function get() {
    return _getOriginXY["default"];
  }
});
Object.defineProperty(_$utils_56, "hypot", {
  enumerable: true,
  get: function get() {
    return ___hypot_56["default"];
  }
});
Object.defineProperty(_$utils_56, "normalizeListeners", {
  enumerable: true,
  get: function get() {
    return _normalizeListeners["default"];
  }
});
Object.defineProperty(_$utils_56, "pointer", {
  enumerable: true,
  get: function get() {
    return ___pointerUtils_56["default"];
  }
});
Object.defineProperty(_$utils_56, "raf", {
  enumerable: true,
  get: function get() {
    return _raf["default"];
  }
});
Object.defineProperty(_$utils_56, "rect", {
  enumerable: true,
  get: function get() {
    return ___rect_56["default"];
  }
});
Object.defineProperty(_$utils_56, "Signals", {
  enumerable: true,
  get: function get() {
    return _Signals["default"];
  }
});
_$utils_56.is = _$utils_56.dom = _$utils_56.arr = void 0;

var __arr_56 = ___interopRequireWildcard_56(_$arr_47);

_$utils_56.arr = __arr_56;

var dom = ___interopRequireWildcard_56(_$domUtils_51);

_$utils_56.dom = dom;

var __is_56 = ___interopRequireWildcard_56(_$is_57);

_$utils_56.is = __is_56;

var ___window_56 = ___interopRequireDefault_56(_$window_66);

var ___browser_56 = ___interopRequireDefault_56(_$browser_48);

var _clone = ___interopRequireDefault_56(_$clone_49);

var _events = ___interopRequireDefault_56(_$events_52);

var ___extend_56 = ___interopRequireDefault_56(_$extend_53);

var _getOriginXY = ___interopRequireDefault_56(_$getOriginXY_54);

var ___hypot_56 = ___interopRequireDefault_56(_$hypot_55);

var _normalizeListeners = ___interopRequireDefault_56(_$normalizeListeners_59);

var ___pointerUtils_56 = ___interopRequireDefault_56(_$pointerUtils_61);

var _raf = ___interopRequireDefault_56(_$raf_62);

var ___rect_56 = ___interopRequireDefault_56(_$rect_63);

var _Signals = ___interopRequireDefault_56(_$Signals_46);

function ___interopRequireDefault_56(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_56(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function warnOnce(method, message) {
  var warned = false; // eslint-disable-next-line no-shadow

  return function () {
    if (!warned) {
      ___window_56["default"].window.console.warn(message);

      warned = true;
    }

    return method.apply(this, arguments);
  };
} // http://stackoverflow.com/a/5634528/2280888


function _getQBezierValue(t, p1, p2, p3) {
  var iT = 1 - t;
  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;
}

function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {
  return {
    x: _getQBezierValue(position, startX, cpX, endX),
    y: _getQBezierValue(position, startY, cpY, endY)
  };
} // http://gizma.com/easing/


function easeOutQuad(t, b, c, d) {
  t /= d;
  return -c * t * (t - 2) + b;
}

function copyAction(dest, src) {
  dest.name = src.name;
  dest.axis = src.axis;
  dest.edges = src.edges;
  return dest;
}

var _$defaultOptions_20 = {};
"use strict";

Object.defineProperty(_$defaultOptions_20, "__esModule", {
  value: true
});
_$defaultOptions_20["default"] = _$defaultOptions_20.defaults = void 0;
// tslint:disable no-empty-interface
var defaults = {
  base: {
    preventDefault: 'auto',
    deltaSource: 'page'
  },
  perAction: {
    enabled: false,
    origin: {
      x: 0,
      y: 0
    }
  },
  actions: {}
};
_$defaultOptions_20.defaults = defaults;
var ___default_20 = defaults;
_$defaultOptions_20["default"] = ___default_20;

var _$Eventable_14 = {};
"use strict";

Object.defineProperty(_$Eventable_14, "__esModule", {
  value: true
});
_$Eventable_14["default"] = void 0;

var __arr_14 = ___interopRequireWildcard_14(_$arr_47);

var ___extend_14 = ___interopRequireDefault_14(_$extend_53);

var ___normalizeListeners_14 = ___interopRequireDefault_14(_$normalizeListeners_59);

function ___interopRequireDefault_14(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_14(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___classCallCheck_14(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ___defineProperties_14(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ___createClass_14(Constructor, protoProps, staticProps) { if (protoProps) ___defineProperties_14(Constructor.prototype, protoProps); if (staticProps) ___defineProperties_14(Constructor, staticProps); return Constructor; }

function fireUntilImmediateStopped(event, listeners) {
  for (var _i = 0; _i < listeners.length; _i++) {
    var _ref;

    _ref = listeners[_i];
    var listener = _ref;

    if (event.immediatePropagationStopped) {
      break;
    }

    listener(event);
  }
}

var Eventable =
/*#__PURE__*/
function () {
  function Eventable(options) {
    ___classCallCheck_14(this, Eventable);

    this.types = {};
    this.propagationStopped = false;
    this.immediatePropagationStopped = false;
    this.options = (0, ___extend_14["default"])({}, options || {});
  }

  ___createClass_14(Eventable, [{
    key: "fire",
    value: function fire(event) {
      var listeners;
      var global = this.global; // Interactable#on() listeners
      // tslint:disable no-conditional-assignment

      if (listeners = this.types[event.type]) {
        fireUntilImmediateStopped(event, listeners);
      } // interact.on() listeners


      if (!event.propagationStopped && global && (listeners = global[event.type])) {
        fireUntilImmediateStopped(event, listeners);
      }
    }
  }, {
    key: "on",
    value: function on(type, listener) {
      var listeners = (0, ___normalizeListeners_14["default"])(type, listener);

      for (type in listeners) {
        this.types[type] = __arr_14.merge(this.types[type] || [], listeners[type]);
      }
    }
  }, {
    key: "off",
    value: function off(type, listener) {
      var listeners = (0, ___normalizeListeners_14["default"])(type, listener);

      for (type in listeners) {
        var eventList = this.types[type];

        if (!eventList || !eventList.length) {
          continue;
        }

        for (var _i2 = 0; _i2 < listeners[type].length; _i2++) {
          var _ref2;

          _ref2 = listeners[type][_i2];
          var subListener = _ref2;
          var index = eventList.indexOf(subListener);

          if (index !== -1) {
            eventList.splice(index, 1);
          }
        }
      }
    }
  }]);

  return Eventable;
}();

var ___default_14 = Eventable;
_$Eventable_14["default"] = ___default_14;

var _$Interactable_16 = {};
"use strict";

Object.defineProperty(_$Interactable_16, "__esModule", {
  value: true
});
_$Interactable_16["default"] = _$Interactable_16.Interactable = void 0;

var __arr_16 = ___interopRequireWildcard_16(_$arr_47);

var ___browser_16 = ___interopRequireDefault_16(_$browser_48);

var ___clone_16 = ___interopRequireDefault_16(_$clone_49);

/* removed: var _$domUtils_51 = require("@interactjs/utils/domUtils"); */;

var ___events_16 = ___interopRequireDefault_16(_$events_52);

var ___extend_16 = ___interopRequireDefault_16(_$extend_53);

var __is_16 = ___interopRequireWildcard_16(_$is_57);

var ___normalizeListeners_16 = ___interopRequireDefault_16(_$normalizeListeners_59);

/* removed: var _$window_66 = require("@interactjs/utils/window"); */;

var _Eventable = ___interopRequireDefault_16(_$Eventable_14);

function ___interopRequireDefault_16(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_16(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___classCallCheck_16(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ___defineProperties_16(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ___createClass_16(Constructor, protoProps, staticProps) { if (protoProps) ___defineProperties_16(Constructor.prototype, protoProps); if (staticProps) ___defineProperties_16(Constructor, staticProps); return Constructor; }

/** */
var Interactable =
/*#__PURE__*/
function () {
  /** */
  function Interactable(target, options, defaultContext) {
    ___classCallCheck_16(this, Interactable);

    this.events = new _Eventable["default"]();
    this._actions = options.actions;
    this.target = target;
    this._context = options.context || defaultContext;
    this._win = (0, _$window_66.getWindow)((0, _$domUtils_51.trySelector)(target) ? this._context : target);
    this._doc = this._win.document;
    this.set(options);
  }

  ___createClass_16(Interactable, [{
    key: "setOnEvents",
    value: function setOnEvents(actionName, phases) {
      if (__is_16.func(phases.onstart)) {
        this.on("".concat(actionName, "start"), phases.onstart);
      }

      if (__is_16.func(phases.onmove)) {
        this.on("".concat(actionName, "move"), phases.onmove);
      }

      if (__is_16.func(phases.onend)) {
        this.on("".concat(actionName, "end"), phases.onend);
      }

      if (__is_16.func(phases.oninertiastart)) {
        this.on("".concat(actionName, "inertiastart"), phases.oninertiastart);
      }

      return this;
    }
  }, {
    key: "updatePerActionListeners",
    value: function updatePerActionListeners(actionName, prev, cur) {
      if (__is_16.array(prev) || __is_16.object(prev)) {
        this.off(actionName, prev);
      }

      if (__is_16.array(cur) || __is_16.object(cur)) {
        this.on(actionName, cur);
      }
    }
  }, {
    key: "setPerAction",
    value: function setPerAction(actionName, options) {
      var defaults = this._defaults; // for all the default per-action options

      for (var optionName in options) {
        var actionOptions = this.options[actionName];
        var optionValue = options[optionName];
        var isArray = __is_16.array(optionValue); // remove old event listeners and add new ones

        if (optionName === 'listeners') {
          this.updatePerActionListeners(actionName, actionOptions.listeners, optionValue);
        } // if the option value is an array


        if (isArray) {
          actionOptions[optionName] = __arr_16.from(optionValue);
        } // if the option value is an object
        else if (!isArray && __is_16.plainObject(optionValue)) {
            // copy the object
            actionOptions[optionName] = (0, ___extend_16["default"])(actionOptions[optionName] || {}, (0, ___clone_16["default"])(optionValue)); // set anabled field to true if it exists in the defaults

            if (__is_16.object(defaults.perAction[optionName]) && 'enabled' in defaults.perAction[optionName]) {
              actionOptions[optionName].enabled = optionValue.enabled !== false;
            }
          } // if the option value is a boolean and the default is an object
          else if (__is_16.bool(optionValue) && __is_16.object(defaults.perAction[optionName])) {
              actionOptions[optionName].enabled = optionValue;
            } // if it's anything else, do a plain assignment
            else {
                actionOptions[optionName] = optionValue;
              }
      }
    }
    /**
     * The default function to get an Interactables bounding rect. Can be
     * overridden using {@link Interactable.rectChecker}.
     *
     * @param {Element} [element] The element to measure.
     * @return {object} The object's bounding rectangle.
     */

  }, {
    key: "getRect",
    value: function getRect(element) {
      element = element || (__is_16.element(this.target) ? this.target : null);

      if (__is_16.string(this.target)) {
        element = element || this._context.querySelector(this.target);
      }

      return (0, _$domUtils_51.getElementRect)(element);
    }
    /**
     * Returns or sets the function used to calculate the interactable's
     * element's rectangle
     *
     * @param {function} [checker] A function which returns this Interactable's
     * bounding rectangle. See {@link Interactable.getRect}
     * @return {function | object} The checker function or this Interactable
     */

  }, {
    key: "rectChecker",
    value: function rectChecker(checker) {
      if (__is_16.func(checker)) {
        this.getRect = checker;
        return this;
      }

      if (checker === null) {
        delete this.getRect;
        return this;
      }

      return this.getRect;
    }
  }, {
    key: "_backCompatOption",
    value: function _backCompatOption(optionName, newValue) {
      if ((0, _$domUtils_51.trySelector)(newValue) || __is_16.object(newValue)) {
        this.options[optionName] = newValue;

        for (var _i = 0; _i < this._actions.names.length; _i++) {
          var _ref;

          _ref = this._actions.names[_i];
          var action = _ref;
          this.options[action][optionName] = newValue;
        }

        return this;
      }

      return this.options[optionName];
    }
    /**
     * Gets or sets the origin of the Interactable's element.  The x and y
     * of the origin will be subtracted from action event coordinates.
     *
     * @param {Element | object | string} [origin] An HTML or SVG Element whose
     * rect will be used, an object eg. { x: 0, y: 0 } or string 'parent', 'self'
     * or any CSS selector
     *
     * @return {object} The current origin or this Interactable
     */

  }, {
    key: "origin",
    value: function origin(newValue) {
      return this._backCompatOption('origin', newValue);
    }
    /**
     * Returns or sets the mouse coordinate types used to calculate the
     * movement of the pointer.
     *
     * @param {string} [newValue] Use 'client' if you will be scrolling while
     * interacting; Use 'page' if you want autoScroll to work
     * @return {string | object} The current deltaSource or this Interactable
     */

  }, {
    key: "deltaSource",
    value: function deltaSource(newValue) {
      if (newValue === 'page' || newValue === 'client') {
        this.options.deltaSource = newValue;
        return this;
      }

      return this.options.deltaSource;
    }
    /**
     * Gets the selector context Node of the Interactable. The default is
     * `window.document`.
     *
     * @return {Node} The context Node of this Interactable
     */

  }, {
    key: "context",
    value: function context() {
      return this._context;
    }
  }, {
    key: "inContext",
    value: function inContext(element) {
      return this._context === element.ownerDocument || (0, _$domUtils_51.nodeContains)(this._context, element);
    }
  }, {
    key: "testIgnoreAllow",
    value: function testIgnoreAllow(options, targetNode, eventTarget) {
      return !this.testIgnore(options.ignoreFrom, targetNode, eventTarget) && this.testAllow(options.allowFrom, targetNode, eventTarget);
    }
  }, {
    key: "testAllow",
    value: function testAllow(allowFrom, targetNode, element) {
      if (!allowFrom) {
        return true;
      }

      if (!__is_16.element(element)) {
        return false;
      }

      if (__is_16.string(allowFrom)) {
        return (0, _$domUtils_51.matchesUpTo)(element, allowFrom, targetNode);
      } else if (__is_16.element(allowFrom)) {
        return (0, _$domUtils_51.nodeContains)(allowFrom, element);
      }

      return false;
    }
  }, {
    key: "testIgnore",
    value: function testIgnore(ignoreFrom, targetNode, element) {
      if (!ignoreFrom || !__is_16.element(element)) {
        return false;
      }

      if (__is_16.string(ignoreFrom)) {
        return (0, _$domUtils_51.matchesUpTo)(element, ignoreFrom, targetNode);
      } else if (__is_16.element(ignoreFrom)) {
        return (0, _$domUtils_51.nodeContains)(ignoreFrom, element);
      }

      return false;
    }
    /**
     * Calls listeners for the given InteractEvent type bound globally
     * and directly to this Interactable
     *
     * @param {InteractEvent} iEvent The InteractEvent object to be fired on this
     * Interactable
     * @return {Interactable} this Interactable
     */

  }, {
    key: "fire",
    value: function fire(iEvent) {
      this.events.fire(iEvent);
      return this;
    }
  }, {
    key: "_onOff",
    value: function _onOff(method, typeArg, listenerArg, options) {
      if (__is_16.object(typeArg) && !__is_16.array(typeArg)) {
        options = listenerArg;
        listenerArg = null;
      }

      var addRemove = method === 'on' ? 'add' : 'remove';
      var listeners = (0, ___normalizeListeners_16["default"])(typeArg, listenerArg);

      for (var type in listeners) {
        if (type === 'wheel') {
          type = ___browser_16["default"].wheelEvent;
        }

        for (var _i2 = 0; _i2 < listeners[type].length; _i2++) {
          var _ref2;

          _ref2 = listeners[type][_i2];
          var listener = _ref2;

          // if it is an action event type
          if (__arr_16.contains(this._actions.eventTypes, type)) {
            this.events[method](type, listener);
          } // delegated event
          else if (__is_16.string(this.target)) {
              ___events_16["default"]["".concat(addRemove, "Delegate")](this.target, this._context, type, listener, options);
            } // remove listener from this Interatable's element
            else {
                ___events_16["default"][addRemove](this.target, type, listener, options);
              }
        }
      }

      return this;
    }
    /**
     * Binds a listener for an InteractEvent, pointerEvent or DOM event.
     *
     * @param {string | array | object} types The types of events to listen
     * for
     * @param {function | array | object} [listener] The event listener function(s)
     * @param {object | boolean} [options] options object or useCapture flag for
     * addEventListener
     * @return {Interactable} This Interactable
     */

  }, {
    key: "on",
    value: function on(types, listener, options) {
      return this._onOff('on', types, listener, options);
    }
    /**
     * Removes an InteractEvent, pointerEvent or DOM event listener.
     *
     * @param {string | array | object} types The types of events that were
     * listened for
     * @param {function | array | object} [listener] The event listener function(s)
     * @param {object | boolean} [options] options object or useCapture flag for
     * removeEventListener
     * @return {Interactable} This Interactable
     */

  }, {
    key: "off",
    value: function off(types, listener, options) {
      return this._onOff('off', types, listener, options);
    }
    /**
     * Reset the options of this Interactable
     *
     * @param {object} options The new settings to apply
     * @return {object} This Interactable
     */

  }, {
    key: "set",
    value: function set(options) {
      var defaults = this._defaults;

      if (!__is_16.object(options)) {
        options = {};
      }

      this.options = (0, ___clone_16["default"])(defaults.base);

      for (var actionName in this._actions.methodDict) {
        var methodName = this._actions.methodDict[actionName];
        this.options[actionName] = {};
        this.setPerAction(actionName, (0, ___extend_16["default"])((0, ___extend_16["default"])({}, defaults.perAction), defaults.actions[actionName]));
        this[methodName](options[actionName]);
      }

      for (var setting in options) {
        if (__is_16.func(this[setting])) {
          this[setting](options[setting]);
        }
      }

      return this;
    }
    /**
     * Remove this interactable from the list of interactables and remove it's
     * action capabilities and event listeners
     *
     * @return {interact}
     */

  }, {
    key: "unset",
    value: function unset() {
      ___events_16["default"].remove(this.target, 'all');

      if (__is_16.string(this.target)) {
        // remove delegated events
        for (var type in ___events_16["default"].delegatedEvents) {
          var delegated = ___events_16["default"].delegatedEvents[type];

          if (delegated.selectors[0] === this.target && delegated.contexts[0] === this._context) {
            delegated.selectors.splice(0, 1);
            delegated.contexts.splice(0, 1);
            delegated.listeners.splice(0, 1); // remove the arrays if they are empty

            if (!delegated.selectors.length) {
              delegated[type] = null;
            }
          }

          ___events_16["default"].remove(this._context, type, ___events_16["default"].delegateListener);

          ___events_16["default"].remove(this._context, type, ___events_16["default"].delegateUseCapture, true);
        }
      } else {
        ___events_16["default"].remove(this.target, 'all');
      }
    }
  }, {
    key: "_defaults",
    get: function get() {
      return {
        base: {},
        perAction: {},
        actions: {}
      };
    }
  }]);

  return Interactable;
}();

_$Interactable_16.Interactable = Interactable;
var ___default_16 = Interactable;
_$Interactable_16["default"] = ___default_16;

var _$InteractableSet_17 = {};
"use strict";

Object.defineProperty(_$InteractableSet_17, "__esModule", {
  value: true
});
_$InteractableSet_17["default"] = void 0;

var __arr_17 = ___interopRequireWildcard_17(_$arr_47);

var __domUtils_17 = ___interopRequireWildcard_17(_$domUtils_51);

var ___extend_17 = ___interopRequireDefault_17(_$extend_53);

var __is_17 = ___interopRequireWildcard_17(_$is_57);

var ___Signals_17 = ___interopRequireDefault_17(_$Signals_46);

function ___interopRequireDefault_17(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_17(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___classCallCheck_17(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ___defineProperties_17(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ___createClass_17(Constructor, protoProps, staticProps) { if (protoProps) ___defineProperties_17(Constructor.prototype, protoProps); if (staticProps) ___defineProperties_17(Constructor, staticProps); return Constructor; }

var InteractableSet =
/*#__PURE__*/
function () {
  function InteractableSet(scope) {
    var _this = this;

    ___classCallCheck_17(this, InteractableSet);

    this.scope = scope;
    this.signals = new ___Signals_17["default"](); // all set interactables

    this.list = [];
    this.selectorMap = {};
    this.signals.on('unset', function (_ref) {
      var interactable = _ref.interactable;
      var target = interactable.target,
          context = interactable._context;
      var targetMappings = __is_17.string(target) ? _this.selectorMap[target] : target[_this.scope.id];
      var targetIndex = targetMappings.findIndex(function (m) {
        return m.context === context;
      });

      if (targetMappings[targetIndex]) {
        // Destroying mappingInfo's context and interactable
        targetMappings[targetIndex].context = null;
        targetMappings[targetIndex].interactable = null;
      }

      targetMappings.splice(targetIndex, 1);
    });
  }

  ___createClass_17(InteractableSet, [{
    key: "new",
    value: function _new(target, options) {
      options = (0, ___extend_17["default"])(options || {}, {
        actions: this.scope.actions
      });
      var interactable = new this.scope.Interactable(target, options, this.scope.document);
      var mappingInfo = {
        context: interactable._context,
        interactable: interactable
      };
      this.scope.addDocument(interactable._doc);
      this.list.push(interactable);

      if (__is_17.string(target)) {
        if (!this.selectorMap[target]) {
          this.selectorMap[target] = [];
        }

        this.selectorMap[target].push(mappingInfo);
      } else {
        if (!interactable.target[this.scope.id]) {
          Object.defineProperty(target, this.scope.id, {
            value: [],
            configurable: true
          });
        }

        target[this.scope.id].push(mappingInfo);
      }

      this.signals.fire('new', {
        target: target,
        options: options,
        interactable: interactable,
        win: this.scope._win
      });
      return interactable;
    }
  }, {
    key: "get",
    value: function get(target, options) {
      var context = options && options.context || this.scope.document;
      var isSelector = __is_17.string(target);
      var targetMappings = isSelector ? this.selectorMap[target] : target[this.scope.id];

      if (!targetMappings) {
        return null;
      }

      var found = __arr_17.find(targetMappings, function (m) {
        return m.context === context && (isSelector || m.interactable.inContext(target));
      });
      return found && found.interactable;
    }
  }, {
    key: "forEachMatch",
    value: function forEachMatch(node, callback) {
      for (var _i = 0; _i < this.list.length; _i++) {
        var _ref2;

        _ref2 = this.list[_i];
        var interactable = _ref2;
        var ret = void 0;

        if ((__is_17.string(interactable.target) // target is a selector and the element matches
        ? __is_17.element(node) && __domUtils_17.matchesSelector(node, interactable.target) : // target is the element
        node === interactable.target) && // the element is in context
        interactable.inContext(node)) {
          ret = callback(interactable);
        }

        if (ret !== undefined) {
          return ret;
        }
      }
    }
  }]);

  return InteractableSet;
}();

_$InteractableSet_17["default"] = InteractableSet;

var _$BaseEvent_13 = {};
"use strict";

Object.defineProperty(_$BaseEvent_13, "__esModule", {
  value: true
});
_$BaseEvent_13["default"] = _$BaseEvent_13.BaseEvent = _$BaseEvent_13.EventPhase = void 0;

function ___classCallCheck_13(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ___defineProperties_13(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ___createClass_13(Constructor, protoProps, staticProps) { if (protoProps) ___defineProperties_13(Constructor.prototype, protoProps); if (staticProps) ___defineProperties_13(Constructor, staticProps); return Constructor; }

var EventPhase;
_$BaseEvent_13.EventPhase = EventPhase;

(function (EventPhase) {
  EventPhase["Start"] = "start";
  EventPhase["Move"] = "move";
  EventPhase["End"] = "end";
  EventPhase["_NONE"] = "";
})(EventPhase || (_$BaseEvent_13.EventPhase = EventPhase = {}));

var BaseEvent =
/*#__PURE__*/
function () {
  function BaseEvent(interaction) {
    ___classCallCheck_13(this, BaseEvent);

    this.immediatePropagationStopped = false;
    this.propagationStopped = false;
    this._interaction = interaction;
  }

  ___createClass_13(BaseEvent, [{
    key: "preventDefault",
    value: function preventDefault() {}
    /**
     * Don't call any other listeners (even on the current target)
     */

  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this.propagationStopped = true;
    }
    /**
     * Don't call listeners on the remaining targets
     */

  }, {
    key: "stopImmediatePropagation",
    value: function stopImmediatePropagation() {
      this.immediatePropagationStopped = this.propagationStopped = true;
    }
  }, {
    key: "interaction",
    get: function get() {
      return this._interaction._proxy;
    }
  }]);

  return BaseEvent;
}();

_$BaseEvent_13.BaseEvent = BaseEvent;
var ___default_13 = BaseEvent;
_$BaseEvent_13["default"] = ___default_13;

var _$InteractEvent_15 = {};
"use strict";

Object.defineProperty(_$InteractEvent_15, "__esModule", {
  value: true
});
_$InteractEvent_15["default"] = _$InteractEvent_15.InteractEvent = _$InteractEvent_15.EventPhase = void 0;

var ___extend_15 = ___interopRequireDefault_15(_$extend_53);

var ___getOriginXY_15 = ___interopRequireDefault_15(_$getOriginXY_54);

var ___hypot_15 = ___interopRequireDefault_15(_$hypot_55);

var _BaseEvent2 = ___interopRequireDefault_15(_$BaseEvent_13);

var _defaultOptions = ___interopRequireDefault_15(_$defaultOptions_20);

function ___interopRequireDefault_15(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___typeof_15(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ___typeof_15 = function _typeof(obj) { return typeof obj; }; } else { ___typeof_15 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ___typeof_15(obj); }

function ___classCallCheck_15(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ___defineProperties_15(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ___createClass_15(Constructor, protoProps, staticProps) { if (protoProps) ___defineProperties_15(Constructor.prototype, protoProps); if (staticProps) ___defineProperties_15(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (___typeof_15(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var __EventPhase_15;
_$InteractEvent_15.EventPhase = __EventPhase_15;

(function (EventPhase) {
  EventPhase["Start"] = "start";
  EventPhase["Move"] = "move";
  EventPhase["End"] = "end";
  EventPhase["_NONE"] = "";
})(__EventPhase_15 || (_$InteractEvent_15.EventPhase = __EventPhase_15 = {}));

var InteractEvent =
/*#__PURE__*/
function (_BaseEvent) {
  _inherits(InteractEvent, _BaseEvent);

  /** */
  function InteractEvent(interaction, event, actionName, phase, element, related, preEnd, type) {
    var _this;

    ___classCallCheck_15(this, InteractEvent);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(InteractEvent).call(this, interaction));
    element = element || interaction.element;
    var target = interaction.interactable;
    var deltaSource = (target && target.options || _defaultOptions["default"]).deltaSource;
    var origin = (0, ___getOriginXY_15["default"])(target, element, actionName);
    var starting = phase === 'start';
    var ending = phase === 'end';
    var prevEvent = starting ? _assertThisInitialized(_this) : interaction.prevEvent;
    var coords = starting ? interaction.coords.start : ending ? {
      page: prevEvent.page,
      client: prevEvent.client,
      timeStamp: interaction.coords.cur.timeStamp
    } : interaction.coords.cur;
    _this.page = (0, ___extend_15["default"])({}, coords.page);
    _this.client = (0, ___extend_15["default"])({}, coords.client);
    _this.rect = (0, ___extend_15["default"])({}, interaction.rect);
    _this.timeStamp = coords.timeStamp;

    if (!ending) {
      _this.page.x -= origin.x;
      _this.page.y -= origin.y;
      _this.client.x -= origin.x;
      _this.client.y -= origin.y;
    }

    _this.ctrlKey = event.ctrlKey;
    _this.altKey = event.altKey;
    _this.shiftKey = event.shiftKey;
    _this.metaKey = event.metaKey;
    _this.button = event.button;
    _this.buttons = event.buttons;
    _this.target = element;
    _this.currentTarget = element;
    _this.relatedTarget = related || null;
    _this.preEnd = preEnd;
    _this.type = type || actionName + (phase || '');
    _this.interactable = target;
    _this.t0 = starting ? interaction.pointers[interaction.pointers.length - 1].downTime : prevEvent.t0;
    _this.x0 = interaction.coords.start.page.x - origin.x;
    _this.y0 = interaction.coords.start.page.y - origin.y;
    _this.clientX0 = interaction.coords.start.client.x - origin.x;
    _this.clientY0 = interaction.coords.start.client.y - origin.y;

    if (starting || ending) {
      _this.delta = {
        x: 0,
        y: 0
      };
    } else {
      _this.delta = {
        x: _this[deltaSource].x - prevEvent[deltaSource].x,
        y: _this[deltaSource].y - prevEvent[deltaSource].y
      };
    }

    _this.dt = interaction.coords.delta.timeStamp;
    _this.duration = _this.timeStamp - _this.t0; // velocity and speed in pixels per second

    _this.velocity = (0, ___extend_15["default"])({}, interaction.coords.velocity[deltaSource]);
    _this.speed = (0, ___hypot_15["default"])(_this.velocity.x, _this.velocity.y);
    _this.swipe = ending || phase === 'inertiastart' ? _this.getSwipe() : null;
    return _this;
  }

  ___createClass_15(InteractEvent, [{
    key: "getSwipe",
    value: function getSwipe() {
      var interaction = this._interaction;

      if (interaction.prevEvent.speed < 600 || this.timeStamp - interaction.prevEvent.timeStamp > 150) {
        return null;
      }

      var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI;
      var overlap = 22.5;

      if (angle < 0) {
        angle += 360;
      }

      var left = 135 - overlap <= angle && angle < 225 + overlap;
      var up = 225 - overlap <= angle && angle < 315 + overlap;
      var right = !left && (315 - overlap <= angle || angle < 45 + overlap);
      var down = !up && 45 - overlap <= angle && angle < 135 + overlap;
      return {
        up: up,
        down: down,
        left: left,
        right: right,
        angle: angle,
        speed: interaction.prevEvent.speed,
        velocity: {
          x: interaction.prevEvent.velocityX,
          y: interaction.prevEvent.velocityY
        }
      };
    }
  }, {
    key: "preventDefault",
    value: function preventDefault() {}
    /**
     * Don't call listeners on the remaining targets
     */

  }, {
    key: "stopImmediatePropagation",
    value: function stopImmediatePropagation() {
      this.immediatePropagationStopped = this.propagationStopped = true;
    }
    /**
     * Don't call any other listeners (even on the current target)
     */

  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this.propagationStopped = true;
    }
  }, {
    key: "pageX",
    get: function get() {
      return this.page.x;
    },
    set: function set(value) {
      this.page.x = value;
    }
  }, {
    key: "pageY",
    get: function get() {
      return this.page.y;
    },
    set: function set(value) {
      this.page.y = value;
    }
  }, {
    key: "clientX",
    get: function get() {
      return this.client.x;
    },
    set: function set(value) {
      this.client.x = value;
    }
  }, {
    key: "clientY",
    get: function get() {
      return this.client.y;
    },
    set: function set(value) {
      this.client.y = value;
    }
  }, {
    key: "dx",
    get: function get() {
      return this.delta.x;
    },
    set: function set(value) {
      this.delta.x = value;
    }
  }, {
    key: "dy",
    get: function get() {
      return this.delta.y;
    },
    set: function set(value) {
      this.delta.y = value;
    }
  }, {
    key: "velocityX",
    get: function get() {
      return this.velocity.x;
    },
    set: function set(value) {
      this.velocity.x = value;
    }
  }, {
    key: "velocityY",
    get: function get() {
      return this.velocity.y;
    },
    set: function set(value) {
      this.velocity.y = value;
    }
  }]);

  return InteractEvent;
}(_BaseEvent2["default"]);

_$InteractEvent_15.InteractEvent = InteractEvent;
var ___default_15 = InteractEvent;
_$InteractEvent_15["default"] = ___default_15;

var _$PointerInfo_19 = {};
"use strict";

Object.defineProperty(_$PointerInfo_19, "__esModule", {
  value: true
});
_$PointerInfo_19["default"] = _$PointerInfo_19.PointerInfo = void 0;

function ___classCallCheck_19(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint-disable @typescript-eslint/no-parameter-properties */
var PointerInfo = function PointerInfo(id, pointer, event, downTime, downTarget) {
  ___classCallCheck_19(this, PointerInfo);

  this.id = id;
  this.pointer = pointer;
  this.event = event;
  this.downTime = downTime;
  this.downTarget = downTarget;
};

_$PointerInfo_19.PointerInfo = PointerInfo;
var ___default_19 = PointerInfo;
_$PointerInfo_19["default"] = ___default_19;

var _$interactionFinder_22 = {};
"use strict";

Object.defineProperty(_$interactionFinder_22, "__esModule", {
  value: true
});
_$interactionFinder_22["default"] = void 0;

var __dom_22 = ___interopRequireWildcard_22(_$domUtils_51);

function ___interopRequireWildcard_22(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

var finder = {
  methodOrder: ['simulationResume', 'mouseOrPen', 'hasPointer', 'idle'],
  search: function search(details) {
    for (var _i = 0; _i < finder.methodOrder.length; _i++) {
      var _ref;

      _ref = finder.methodOrder[_i];
      var method = _ref;
      var interaction = finder[method](details);

      if (interaction) {
        return interaction;
      }
    }
  },
  // try to resume simulation with a new pointer
  simulationResume: function simulationResume(_ref2) {
    var pointerType = _ref2.pointerType,
        eventType = _ref2.eventType,
        eventTarget = _ref2.eventTarget,
        scope = _ref2.scope;

    if (!/down|start/i.test(eventType)) {
      return null;
    }

    for (var _i2 = 0; _i2 < scope.interactions.list.length; _i2++) {
      var _ref3;

      _ref3 = scope.interactions.list[_i2];
      var interaction = _ref3;
      var element = eventTarget;

      if (interaction.simulation && interaction.simulation.allowResume && interaction.pointerType === pointerType) {
        while (element) {
          // if the element is the interaction element
          if (element === interaction.element) {
            return interaction;
          }

          element = __dom_22.parentNode(element);
        }
      }
    }

    return null;
  },
  // if it's a mouse or pen interaction
  mouseOrPen: function mouseOrPen(_ref4) {
    var pointerId = _ref4.pointerId,
        pointerType = _ref4.pointerType,
        eventType = _ref4.eventType,
        scope = _ref4.scope;

    if (pointerType !== 'mouse' && pointerType !== 'pen') {
      return null;
    }

    var firstNonActive;

    for (var _i3 = 0; _i3 < scope.interactions.list.length; _i3++) {
      var _ref5;

      _ref5 = scope.interactions.list[_i3];
      var interaction = _ref5;

      if (interaction.pointerType === pointerType) {
        // if it's a down event, skip interactions with running simulations
        if (interaction.simulation && !hasPointerId(interaction, pointerId)) {
          continue;
        } // if the interaction is active, return it immediately


        if (interaction.interacting()) {
          return interaction;
        } // otherwise save it and look for another active interaction
        else if (!firstNonActive) {
            firstNonActive = interaction;
          }
      }
    } // if no active mouse interaction was found use the first inactive mouse
    // interaction


    if (firstNonActive) {
      return firstNonActive;
    } // find any mouse or pen interaction.
    // ignore the interaction if the eventType is a *down, and a simulation
    // is active


    for (var _i4 = 0; _i4 < scope.interactions.list.length; _i4++) {
      var _ref6;

      _ref6 = scope.interactions.list[_i4];
      var _interaction = _ref6;

      if (_interaction.pointerType === pointerType && !(/down/i.test(eventType) && _interaction.simulation)) {
        return _interaction;
      }
    }

    return null;
  },
  // get interaction that has this pointer
  hasPointer: function hasPointer(_ref7) {
    var pointerId = _ref7.pointerId,
        scope = _ref7.scope;

    for (var _i5 = 0; _i5 < scope.interactions.list.length; _i5++) {
      var _ref8;

      _ref8 = scope.interactions.list[_i5];
      var interaction = _ref8;

      if (hasPointerId(interaction, pointerId)) {
        return interaction;
      }
    }

    return null;
  },
  // get first idle interaction with a matching pointerType
  idle: function idle(_ref9) {
    var pointerType = _ref9.pointerType,
        scope = _ref9.scope;

    for (var _i6 = 0; _i6 < scope.interactions.list.length; _i6++) {
      var _ref10;

      _ref10 = scope.interactions.list[_i6];
      var interaction = _ref10;

      // if there's already a pointer held down
      if (interaction.pointers.length === 1) {
        var target = interaction.interactable; // don't add this pointer if there is a target interactable and it
        // isn't gesturable

        if (target && !(target.options.gesture && target.options.gesture.enabled)) {
          continue;
        }
      } // maximum of 2 pointers per interaction
      else if (interaction.pointers.length >= 2) {
          continue;
        }

      if (!interaction.interacting() && pointerType === interaction.pointerType) {
        return interaction;
      }
    }

    return null;
  }
};

function hasPointerId(interaction, pointerId) {
  return interaction.pointers.some(function (_ref11) {
    var id = _ref11.id;
    return id === pointerId;
  });
}

var ___default_22 = finder;
_$interactionFinder_22["default"] = ___default_22;

var _$drag_1 = {};
"use strict";

Object.defineProperty(_$drag_1, "__esModule", {
  value: true
});
_$drag_1["default"] = void 0;

var ___scope_1 = _$scope_24({});

var __arr_1 = ___interopRequireWildcard_1(_$arr_47);

var __is_1 = ___interopRequireWildcard_1(_$is_57);

function ___interopRequireWildcard_1(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

___scope_1.ActionName.Drag = 'drag';

function __install_1(scope) {
  var actions = scope.actions,
      Interactable = scope.Interactable,
      interactions = scope.interactions,
      defaults = scope.defaults;
  interactions.signals.on('before-action-move', beforeMove);
  interactions.signals.on('action-resume', beforeMove); // dragmove

  interactions.signals.on('action-move', move);
  Interactable.prototype.draggable = drag.draggable;
  actions[___scope_1.ActionName.Drag] = drag;
  actions.names.push(___scope_1.ActionName.Drag);
  __arr_1.merge(actions.eventTypes, ['dragstart', 'dragmove', 'draginertiastart', 'dragresume', 'dragend']);
  actions.methodDict.drag = 'draggable';
  defaults.actions.drag = drag.defaults;
}

function beforeMove(_ref) {
  var interaction = _ref.interaction;

  if (interaction.prepared.name !== 'drag') {
    return;
  }

  var axis = interaction.prepared.axis;

  if (axis === 'x') {
    interaction.coords.cur.page.y = interaction.coords.start.page.y;
    interaction.coords.cur.client.y = interaction.coords.start.client.y;
    interaction.coords.velocity.client.y = 0;
    interaction.coords.velocity.page.y = 0;
  } else if (axis === 'y') {
    interaction.coords.cur.page.x = interaction.coords.start.page.x;
    interaction.coords.cur.client.x = interaction.coords.start.client.x;
    interaction.coords.velocity.client.x = 0;
    interaction.coords.velocity.page.x = 0;
  }
}

function move(_ref2) {
  var iEvent = _ref2.iEvent,
      interaction = _ref2.interaction;

  if (interaction.prepared.name !== 'drag') {
    return;
  }

  var axis = interaction.prepared.axis;

  if (axis === 'x' || axis === 'y') {
    var opposite = axis === 'x' ? 'y' : 'x';
    iEvent.page[opposite] = interaction.coords.start.page[opposite];
    iEvent.client[opposite] = interaction.coords.start.client[opposite];
    iEvent.delta[opposite] = 0;
  }
}
/**
 * ```js
 * interact(element).draggable({
 *     onstart: function (event) {},
 *     onmove : function (event) {},
 *     onend  : function (event) {},
 *
 *     // the axis in which the first movement must be
 *     // for the drag sequence to start
 *     // 'xy' by default - any direction
 *     startAxis: 'x' || 'y' || 'xy',
 *
 *     // 'xy' by default - don't restrict to one axis (move in any direction)
 *     // 'x' or 'y' to restrict movement to either axis
 *     // 'start' to restrict movement to the axis the drag started in
 *     lockAxis: 'x' || 'y' || 'xy' || 'start',
 *
 *     // max number of drags that can happen concurrently
 *     // with elements of this Interactable. Infinity by default
 *     max: Infinity,
 *
 *     // max number of drags that can target the same element+Interactable
 *     // 1 by default
 *     maxPerElement: 2
 * })
 *
 * var isDraggable = interact('element').draggable(); // true
 * ```
 *
 * Get or set whether drag actions can be performed on the target
 *
 * @alias Interactable.prototype.draggable
 *
 * @param {boolean | object} [options] true/false or An object with event
 * listeners to be fired on drag events (object makes the Interactable
 * draggable)
 * @return {boolean | Interactable} boolean indicating if this can be the
 * target of drag events, or this Interctable
 */


var draggable = function draggable(options) {
  if (__is_1.object(options)) {
    this.options.drag.enabled = options.enabled !== false;
    this.setPerAction('drag', options);
    this.setOnEvents('drag', options);

    if (/^(xy|x|y|start)$/.test(options.lockAxis)) {
      this.options.drag.lockAxis = options.lockAxis;
    }

    if (/^(xy|x|y)$/.test(options.startAxis)) {
      this.options.drag.startAxis = options.startAxis;
    }

    return this;
  }

  if (__is_1.bool(options)) {
    this.options.drag.enabled = options;
    return this;
  }

  return this.options.drag;
};

var drag = {
  id: 'actions/drag',
  install: __install_1,
  draggable: draggable,
  beforeMove: beforeMove,
  move: move,
  defaults: {
    startAxis: 'xy',
    lockAxis: 'xy'
  },
  checker: function checker(_pointer, _event, interactable) {
    var dragOptions = interactable.options.drag;
    return dragOptions.enabled ? {
      name: 'drag',
      axis: dragOptions.lockAxis === 'start' ? dragOptions.startAxis : dragOptions.lockAxis
    } : null;
  },
  getCursor: function getCursor() {
    return 'move';
  }
};
var ___default_1 = drag;
_$drag_1["default"] = ___default_1;

var _$DropEvent_2 = {};
"use strict";

Object.defineProperty(_$DropEvent_2, "__esModule", {
  value: true
});
_$DropEvent_2["default"] = void 0;

var ___BaseEvent2_2 = ___interopRequireDefault_2(_$BaseEvent_13);

var __arr_2 = ___interopRequireWildcard_2(_$arr_47);

function ___interopRequireWildcard_2(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_2(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___typeof_2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ___typeof_2 = function _typeof(obj) { return typeof obj; }; } else { ___typeof_2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ___typeof_2(obj); }

function ___toConsumableArray_2(arr) { return ___arrayWithoutHoles_2(arr) || ___iterableToArray_2(arr) || ___nonIterableSpread_2(); }

function ___nonIterableSpread_2() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function ___iterableToArray_2(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function ___arrayWithoutHoles_2(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ___classCallCheck_2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ___defineProperties_2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ___createClass_2(Constructor, protoProps, staticProps) { if (protoProps) ___defineProperties_2(Constructor.prototype, protoProps); if (staticProps) ___defineProperties_2(Constructor, staticProps); return Constructor; }

function ___possibleConstructorReturn_2(self, call) { if (call && (___typeof_2(call) === "object" || typeof call === "function")) { return call; } return ___assertThisInitialized_2(self); }

function ___assertThisInitialized_2(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function ___getPrototypeOf_2(o) { ___getPrototypeOf_2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ___getPrototypeOf_2(o); }

function ___inherits_2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) ___setPrototypeOf_2(subClass, superClass); }

function ___setPrototypeOf_2(o, p) { ___setPrototypeOf_2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ___setPrototypeOf_2(o, p); }

var DropEvent =
/*#__PURE__*/
function (_BaseEvent) {
  ___inherits_2(DropEvent, _BaseEvent);

  /**
   * Class of events fired on dropzones during drags with acceptable targets.
   */
  function DropEvent(dropState, dragEvent, type) {
    var _this;

    ___classCallCheck_2(this, DropEvent);

    _this = ___possibleConstructorReturn_2(this, ___getPrototypeOf_2(DropEvent).call(this, dragEvent._interaction));
    _this.propagationStopped = false;
    _this.immediatePropagationStopped = false;

    var _ref = type === 'dragleave' ? dropState.prev : dropState.cur,
        element = _ref.element,
        dropzone = _ref.dropzone;

    _this.type = type;
    _this.target = element;
    _this.currentTarget = element;
    _this.dropzone = dropzone;
    _this.dragEvent = dragEvent;
    _this.relatedTarget = dragEvent.target;
    _this.draggable = dragEvent.interactable;
    _this.timeStamp = dragEvent.timeStamp;
    return _this;
  }
  /**
   * If this is a `dropactivate` event, the dropzone element will be
   * deactivated.
   *
   * If this is a `dragmove` or `dragenter`, a `dragleave` will be fired on the
   * dropzone element and more.
   */


  ___createClass_2(DropEvent, [{
    key: "reject",
    value: function reject() {
      var _this2 = this;

      var dropState = this._interaction.dropState;

      if (this.type !== 'dropactivate' && (!this.dropzone || dropState.cur.dropzone !== this.dropzone || dropState.cur.element !== this.target)) {
        return;
      }

      dropState.prev.dropzone = this.dropzone;
      dropState.prev.element = this.target;
      dropState.rejected = true;
      dropState.events.enter = null;
      this.stopImmediatePropagation();

      if (this.type === 'dropactivate') {
        var activeDrops = dropState.activeDrops;
        var index = __arr_2.findIndex(activeDrops, function (_ref2) {
          var dropzone = _ref2.dropzone,
              element = _ref2.element;
          return dropzone === _this2.dropzone && element === _this2.target;
        });
        dropState.activeDrops = [].concat(___toConsumableArray_2(activeDrops.slice(0, index)), ___toConsumableArray_2(activeDrops.slice(index + 1)));
        var deactivateEvent = new DropEvent(dropState, this.dragEvent, 'dropdeactivate');
        deactivateEvent.dropzone = this.dropzone;
        deactivateEvent.target = this.target;
        this.dropzone.fire(deactivateEvent);
      } else {
        this.dropzone.fire(new DropEvent(dropState, this.dragEvent, 'dragleave'));
      }
    }
  }, {
    key: "preventDefault",
    value: function preventDefault() {}
  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this.propagationStopped = true;
    }
  }, {
    key: "stopImmediatePropagation",
    value: function stopImmediatePropagation() {
      this.immediatePropagationStopped = this.propagationStopped = true;
    }
  }]);

  return DropEvent;
}(___BaseEvent2_2["default"]);

var ___default_2 = DropEvent;
_$DropEvent_2["default"] = ___default_2;

var _$drop_3 = {};
"use strict";

Object.defineProperty(_$drop_3, "__esModule", {
  value: true
});
_$drop_3["default"] = void 0;

var __utils_3 = ___interopRequireWildcard_3(_$utils_56);

var _drag = ___interopRequireDefault_3(_$drag_1);

var _DropEvent = ___interopRequireDefault_3(_$DropEvent_2);

function ___interopRequireDefault_3(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_3(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function __install_3(scope) {
  var actions = scope.actions,
      interact = scope.interact,
      Interactable = scope.Interactable,
      interactions = scope.interactions,
      defaults = scope.defaults;
  scope.usePlugin(_drag["default"]);
  interactions.signals.on('before-action-start', function (_ref) {
    var interaction = _ref.interaction;

    if (interaction.prepared.name !== 'drag') {
      return;
    }

    interaction.dropState = {
      cur: {
        dropzone: null,
        element: null
      },
      prev: {
        dropzone: null,
        element: null
      },
      rejected: null,
      events: null,
      activeDrops: null
    };
  });
  interactions.signals.on('after-action-start', function (_ref2) {
    var interaction = _ref2.interaction,
        event = _ref2.event,
        dragEvent = _ref2.iEvent;

    if (interaction.prepared.name !== 'drag') {
      return;
    }

    var dropState = interaction.dropState; // reset active dropzones

    dropState.activeDrops = null;
    dropState.events = null;
    dropState.activeDrops = getActiveDrops(scope, interaction.element);
    dropState.events = getDropEvents(interaction, event, dragEvent);

    if (dropState.events.activate) {
      fireActivationEvents(dropState.activeDrops, dropState.events.activate);
    }
  }); // FIXME proper signal types

  interactions.signals.on('action-move', function (arg) {
    return onEventCreated(arg, scope);
  });
  interactions.signals.on('action-end', function (arg) {
    return onEventCreated(arg, scope);
  });
  interactions.signals.on('after-action-move', function (_ref3) {
    var interaction = _ref3.interaction;

    if (interaction.prepared.name !== 'drag') {
      return;
    }

    fireDropEvents(interaction, interaction.dropState.events);
    interaction.dropState.events = {};
  });
  interactions.signals.on('after-action-end', function (_ref4) {
    var interaction = _ref4.interaction;

    if (interaction.prepared.name !== 'drag') {
      return;
    }

    fireDropEvents(interaction, interaction.dropState.events);
  });
  interactions.signals.on('stop', function (_ref5) {
    var interaction = _ref5.interaction;

    if (interaction.prepared.name !== 'drag') {
      return;
    }

    var dropState = interaction.dropState;

    if (dropState) {
      dropState.activeDrops = null;
      dropState.events = null;
      dropState.cur.dropzone = null;
      dropState.cur.element = null;
      dropState.prev.dropzone = null;
      dropState.prev.element = null;
      dropState.rejected = false;
    }
  });
  /**
   *
   * ```js
   * interact('.drop').dropzone({
   *   accept: '.can-drop' || document.getElementById('single-drop'),
   *   overlap: 'pointer' || 'center' || zeroToOne
   * }
   * ```
   *
   * Returns or sets whether draggables can be dropped onto this target to
   * trigger drop events
   *
   * Dropzones can receive the following events:
   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends
   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone
   *  - `dragmove` when a draggable that has entered the dropzone is moved
   *  - `drop` when a draggable is dropped into this dropzone
   *
   * Use the `accept` option to allow only elements that match the given CSS
   * selector or element. The value can be:
   *
   *  - **an Element** - only that element can be dropped into this dropzone.
   *  - **a string**, - the element being dragged must match it as a CSS selector.
   *  - **`null`** - accept options is cleared - it accepts any element.
   *
   * Use the `overlap` option to set how drops are checked for. The allowed
   * values are:
   *
   *   - `'pointer'`, the pointer must be over the dropzone (default)
   *   - `'center'`, the draggable element's center must be over the dropzone
   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.
   *   e.g. `0.5` for drop to happen when half of the area of the draggable is
   *   over the dropzone
   *
   * Use the `checker` option to specify a function to check if a dragged element
   * is over this Interactable.
   *
   * @param {boolean | object | null} [options] The new options to be set.
   * @return {boolean | Interactable} The current setting or this Interactable
   */

  Interactable.prototype.dropzone = function (options) {
    return dropzoneMethod(this, options);
  };
  /**
   * ```js
   * interact(target)
   * .dropChecker(function(dragEvent,         // related dragmove or dragend event
   *                       event,             // TouchEvent/PointerEvent/MouseEvent
   *                       dropped,           // bool result of the default checker
   *                       dropzone,          // dropzone Interactable
   *                       dropElement,       // dropzone elemnt
   *                       draggable,         // draggable Interactable
   *                       draggableElement) {// draggable element
   *
   *   return dropped && event.target.hasAttribute('allow-drop')
   * }
   * ```
   */


  Interactable.prototype.dropCheck = function (dragEvent, event, draggable, draggableElement, dropElement, rect) {
    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect);
  };
  /**
   * Returns or sets whether the dimensions of dropzone elements are calculated
   * on every dragmove or only on dragstart for the default dropChecker
   *
   * @param {boolean} [newValue] True to check on each move. False to check only
   * before start
   * @return {boolean | interact} The current setting or interact
   */


  interact.dynamicDrop = function (newValue) {
    if (__utils_3.is.bool(newValue)) {
      // if (dragging && scope.dynamicDrop !== newValue && !newValue) {
      //  calcRects(dropzones)
      // }
      scope.dynamicDrop = newValue;
      return interact;
    }

    return scope.dynamicDrop;
  };

  __utils_3.arr.merge(actions.eventTypes, ['dragenter', 'dragleave', 'dropactivate', 'dropdeactivate', 'dropmove', 'drop']);
  actions.methodDict.drop = 'dropzone';
  scope.dynamicDrop = false;
  defaults.actions.drop = drop.defaults;
}

function collectDrops(_ref6, draggableElement) {
  var interactables = _ref6.interactables;
  var drops = []; // collect all dropzones and their elements which qualify for a drop

  for (var _i = 0; _i < interactables.list.length; _i++) {
    var _ref7;

    _ref7 = interactables.list[_i];
    var dropzone = _ref7;

    if (!dropzone.options.drop.enabled) {
      continue;
    }

    var accept = dropzone.options.drop.accept; // test the draggable draggableElement against the dropzone's accept setting

    if (__utils_3.is.element(accept) && accept !== draggableElement || __utils_3.is.string(accept) && !__utils_3.dom.matchesSelector(draggableElement, accept) || __utils_3.is.func(accept) && !accept({
      dropzone: dropzone,
      draggableElement: draggableElement
    })) {
      continue;
    } // query for new elements if necessary


    var dropElements = __utils_3.is.string(dropzone.target) ? dropzone._context.querySelectorAll(dropzone.target) : __utils_3.is.array(dropzone.target) ? dropzone.target : [dropzone.target];

    for (var _i2 = 0; _i2 < dropElements.length; _i2++) {
      var _ref8;

      _ref8 = dropElements[_i2];
      var dropzoneElement = _ref8;

      if (dropzoneElement !== draggableElement) {
        drops.push({
          dropzone: dropzone,
          element: dropzoneElement
        });
      }
    }
  }

  return drops;
}

function fireActivationEvents(activeDrops, event) {
  // loop through all active dropzones and trigger event
  for (var _i3 = 0; _i3 < activeDrops.length; _i3++) {
    var _ref9;

    _ref9 = activeDrops[_i3];
    var _ref10 = _ref9,
        dropzone = _ref10.dropzone,
        element = _ref10.element;
    event.dropzone = dropzone; // set current element as event target

    event.target = element;
    dropzone.fire(event);
    event.propagationStopped = event.immediatePropagationStopped = false;
  }
} // return a new array of possible drops. getActiveDrops should always be
// called when a drag has just started or a drag event happens while
// dynamicDrop is true


function getActiveDrops(scope, dragElement) {
  // get dropzones and their elements that could receive the draggable
  var activeDrops = collectDrops(scope, dragElement);

  for (var _i4 = 0; _i4 < activeDrops.length; _i4++) {
    var _ref11;

    _ref11 = activeDrops[_i4];
    var activeDrop = _ref11;
    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element);
  }

  return activeDrops;
}

function getDrop(_ref12, dragEvent, pointerEvent) {
  var dropState = _ref12.dropState,
      draggable = _ref12.interactable,
      dragElement = _ref12.element;
  var validDrops = []; // collect all dropzones and their elements which qualify for a drop

  for (var _i5 = 0; _i5 < dropState.activeDrops.length; _i5++) {
    var _ref13;

    _ref13 = dropState.activeDrops[_i5];
    var _ref14 = _ref13,
        dropzone = _ref14.dropzone,
        dropzoneElement = _ref14.element,
        rect = _ref14.rect;
    validDrops.push(dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect) ? dropzoneElement : null);
  } // get the most appropriate dropzone based on DOM depth and order


  var dropIndex = __utils_3.dom.indexOfDeepestElement(validDrops);
  return dropState.activeDrops[dropIndex] || null;
}

function getDropEvents(interaction, _pointerEvent, dragEvent) {
  var dropState = interaction.dropState;
  var dropEvents = {
    enter: null,
    leave: null,
    activate: null,
    deactivate: null,
    move: null,
    drop: null
  };

  if (dragEvent.type === 'dragstart') {
    dropEvents.activate = new _DropEvent["default"](dropState, dragEvent, 'dropactivate');
    dropEvents.activate.target = null;
    dropEvents.activate.dropzone = null;
  }

  if (dragEvent.type === 'dragend') {
    dropEvents.deactivate = new _DropEvent["default"](dropState, dragEvent, 'dropdeactivate');
    dropEvents.deactivate.target = null;
    dropEvents.deactivate.dropzone = null;
  }

  if (dropState.rejected) {
    return dropEvents;
  }

  if (dropState.cur.element !== dropState.prev.element) {
    // if there was a previous dropzone, create a dragleave event
    if (dropState.prev.dropzone) {
      dropEvents.leave = new _DropEvent["default"](dropState, dragEvent, 'dragleave');
      dragEvent.dragLeave = dropEvents.leave.target = dropState.prev.element;
      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone;
    } // if dropzone is not null, create a dragenter event


    if (dropState.cur.dropzone) {
      dropEvents.enter = new _DropEvent["default"](dropState, dragEvent, 'dragenter');
      dragEvent.dragEnter = dropState.cur.element;
      dragEvent.dropzone = dropState.cur.dropzone;
    }
  }

  if (dragEvent.type === 'dragend' && dropState.cur.dropzone) {
    dropEvents.drop = new _DropEvent["default"](dropState, dragEvent, 'drop');
    dragEvent.dropzone = dropState.cur.dropzone;
    dragEvent.relatedTarget = dropState.cur.element;
  }

  if (dragEvent.type === 'dragmove' && dropState.cur.dropzone) {
    dropEvents.move = new _DropEvent["default"](dropState, dragEvent, 'dropmove');
    dropEvents.move.dragmove = dragEvent;
    dragEvent.dropzone = dropState.cur.dropzone;
  }

  return dropEvents;
}

function fireDropEvents(interaction, events) {
  var dropState = interaction.dropState;
  var activeDrops = dropState.activeDrops,
      cur = dropState.cur,
      prev = dropState.prev;

  if (events.leave) {
    prev.dropzone.fire(events.leave);
  }

  if (events.move) {
    cur.dropzone.fire(events.move);
  }

  if (events.enter) {
    cur.dropzone.fire(events.enter);
  }

  if (events.drop) {
    cur.dropzone.fire(events.drop);
  }

  if (events.deactivate) {
    fireActivationEvents(activeDrops, events.deactivate);
  }

  dropState.prev.dropzone = cur.dropzone;
  dropState.prev.element = cur.element;
}

function onEventCreated(_ref15, scope) {
  var interaction = _ref15.interaction,
      iEvent = _ref15.iEvent,
      event = _ref15.event;

  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') {
    return;
  }

  var dropState = interaction.dropState;

  if (scope.dynamicDrop) {
    dropState.activeDrops = getActiveDrops(scope, interaction.element);
  }

  var dragEvent = iEvent;
  var dropResult = getDrop(interaction, dragEvent, event); // update rejected status

  dropState.rejected = dropState.rejected && !!dropResult && dropResult.dropzone === dropState.cur.dropzone && dropResult.element === dropState.cur.element;
  dropState.cur.dropzone = dropResult && dropResult.dropzone;
  dropState.cur.element = dropResult && dropResult.element;
  dropState.events = getDropEvents(interaction, event, dragEvent);
}

function dropzoneMethod(interactable, options) {
  if (__utils_3.is.object(options)) {
    interactable.options.drop.enabled = options.enabled !== false;

    if (options.listeners) {
      var normalized = __utils_3.normalizeListeners(options.listeners); // rename 'drop' to '' as it will be prefixed with 'drop'

      var corrected = Object.keys(normalized).reduce(function (acc, type) {
        var correctedType = /^(enter|leave)/.test(type) ? "drag".concat(type) : /^(activate|deactivate|move)/.test(type) ? "drop".concat(type) : type;
        acc[correctedType] = normalized[type];
        return acc;
      }, {});
      interactable.off(interactable.options.drop.listeners);
      interactable.on(corrected);
      interactable.options.drop.listeners = corrected;
    }

    if (__utils_3.is.func(options.ondrop)) {
      interactable.on('drop', options.ondrop);
    }

    if (__utils_3.is.func(options.ondropactivate)) {
      interactable.on('dropactivate', options.ondropactivate);
    }

    if (__utils_3.is.func(options.ondropdeactivate)) {
      interactable.on('dropdeactivate', options.ondropdeactivate);
    }

    if (__utils_3.is.func(options.ondragenter)) {
      interactable.on('dragenter', options.ondragenter);
    }

    if (__utils_3.is.func(options.ondragleave)) {
      interactable.on('dragleave', options.ondragleave);
    }

    if (__utils_3.is.func(options.ondropmove)) {
      interactable.on('dropmove', options.ondropmove);
    }

    if (/^(pointer|center)$/.test(options.overlap)) {
      interactable.options.drop.overlap = options.overlap;
    } else if (__utils_3.is.number(options.overlap)) {
      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);
    }

    if ('accept' in options) {
      interactable.options.drop.accept = options.accept;
    }

    if ('checker' in options) {
      interactable.options.drop.checker = options.checker;
    }

    return interactable;
  }

  if (__utils_3.is.bool(options)) {
    interactable.options.drop.enabled = options;
    return interactable;
  }

  return interactable.options.drop;
}

function dropCheckMethod(interactable, dragEvent, event, draggable, draggableElement, dropElement, rect) {
  var dropped = false; // if the dropzone has no rect (eg. display: none)
  // call the custom dropChecker or just return false

  if (!(rect = rect || interactable.getRect(dropElement))) {
    return interactable.options.drop.checker ? interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement) : false;
  }

  var dropOverlap = interactable.options.drop.overlap;

  if (dropOverlap === 'pointer') {
    var origin = __utils_3.getOriginXY(draggable, draggableElement, 'drag');
    var page = __utils_3.pointer.getPageXY(dragEvent);
    page.x += origin.x;
    page.y += origin.y;
    var horizontal = page.x > rect.left && page.x < rect.right;
    var vertical = page.y > rect.top && page.y < rect.bottom;
    dropped = horizontal && vertical;
  }

  var dragRect = draggable.getRect(draggableElement);

  if (dragRect && dropOverlap === 'center') {
    var cx = dragRect.left + dragRect.width / 2;
    var cy = dragRect.top + dragRect.height / 2;
    dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;
  }

  if (dragRect && __utils_3.is.number(dropOverlap)) {
    var overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top));
    var overlapRatio = overlapArea / (dragRect.width * dragRect.height);
    dropped = overlapRatio >= dropOverlap;
  }

  if (interactable.options.drop.checker) {
    dropped = interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement);
  }

  return dropped;
}

var drop = {
  id: 'actions/drop',
  install: __install_3,
  getActiveDrops: getActiveDrops,
  getDrop: getDrop,
  getDropEvents: getDropEvents,
  fireDropEvents: fireDropEvents,
  defaults: {
    enabled: false,
    accept: null,
    overlap: 'pointer'
  }
};
var ___default_3 = drop;
_$drop_3["default"] = ___default_3;

var _$gesture_4 = {};
"use strict";

Object.defineProperty(_$gesture_4, "__esModule", {
  value: true
});
_$gesture_4["default"] = void 0;

var ___InteractEvent_4 = ___interopRequireDefault_4(_$InteractEvent_15);

var ___scope_4 = _$scope_24({});

var __utils_4 = ___interopRequireWildcard_4(_$utils_56);

function ___interopRequireWildcard_4(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_4(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

___scope_4.ActionName.Gesture = 'gesture';

function __install_4(scope) {
  var actions = scope.actions,
      Interactable = scope.Interactable,
      interactions = scope.interactions,
      defaults = scope.defaults;
  /**
   * ```js
   * interact(element).gesturable({
   *     onstart: function (event) {},
   *     onmove : function (event) {},
   *     onend  : function (event) {},
   *
   *     // limit multiple gestures.
   *     // See the explanation in {@link Interactable.draggable} example
   *     max: Infinity,
   *     maxPerElement: 1,
   * })
   *
   * var isGestureable = interact(element).gesturable()
   * ```
   *
   * Gets or sets whether multitouch gestures can be performed on the target
   *
   * @param {boolean | object} [options] true/false or An object with event
   * listeners to be fired on gesture events (makes the Interactable gesturable)
   * @return {boolean | Interactable} A boolean indicating if this can be the
   * target of gesture events, or this Interactable
   */

  Interactable.prototype.gesturable = function (options) {
    if (__utils_4.is.object(options)) {
      this.options.gesture.enabled = options.enabled !== false;
      this.setPerAction('gesture', options);
      this.setOnEvents('gesture', options);
      return this;
    }

    if (__utils_4.is.bool(options)) {
      this.options.gesture.enabled = options;
      return this;
    }

    return this.options.gesture;
  };

  interactions.signals.on('action-start', updateGestureProps);
  interactions.signals.on('action-move', updateGestureProps);
  interactions.signals.on('action-end', updateGestureProps);
  interactions.signals.on('new', function (_ref) {
    var interaction = _ref.interaction;
    interaction.gesture = {
      angle: 0,
      distance: 0,
      scale: 1,
      startAngle: 0,
      startDistance: 0
    };
  });
  actions[___scope_4.ActionName.Gesture] = gesture;
  actions.names.push(___scope_4.ActionName.Gesture);
  __utils_4.arr.merge(actions.eventTypes, ['gesturestart', 'gesturemove', 'gestureend']);
  actions.methodDict.gesture = 'gesturable';
  defaults.actions.gesture = gesture.defaults;
}

var gesture = {
  id: 'actions/gesture',
  install: __install_4,
  defaults: {},
  checker: function checker(_pointer, _event, _interactable, _element, interaction) {
    if (interaction.pointers.length >= 2) {
      return {
        name: 'gesture'
      };
    }

    return null;
  },
  getCursor: function getCursor() {
    return '';
  }
};

function updateGestureProps(_ref2) {
  var interaction = _ref2.interaction,
      iEvent = _ref2.iEvent,
      event = _ref2.event,
      phase = _ref2.phase;

  if (interaction.prepared.name !== 'gesture') {
    return;
  }

  var pointers = interaction.pointers.map(function (p) {
    return p.pointer;
  });
  var starting = phase === 'start';
  var ending = phase === 'end';
  var deltaSource = interaction.interactable.options.deltaSource;
  iEvent.touches = [pointers[0], pointers[1]];

  if (starting) {
    iEvent.distance = __utils_4.pointer.touchDistance(pointers, deltaSource);
    iEvent.box = __utils_4.pointer.touchBBox(pointers);
    iEvent.scale = 1;
    iEvent.ds = 0;
    iEvent.angle = __utils_4.pointer.touchAngle(pointers, deltaSource);
    iEvent.da = 0;
    interaction.gesture.startDistance = iEvent.distance;
    interaction.gesture.startAngle = iEvent.angle;
  } else if (ending || event instanceof ___InteractEvent_4["default"]) {
    var prevEvent = interaction.prevEvent;
    iEvent.distance = prevEvent.distance;
    iEvent.box = prevEvent.box;
    iEvent.scale = prevEvent.scale;
    iEvent.ds = 0;
    iEvent.angle = prevEvent.angle;
    iEvent.da = 0;
  } else {
    iEvent.distance = __utils_4.pointer.touchDistance(pointers, deltaSource);
    iEvent.box = __utils_4.pointer.touchBBox(pointers);
    iEvent.scale = iEvent.distance / interaction.gesture.startDistance;
    iEvent.angle = __utils_4.pointer.touchAngle(pointers, deltaSource);
    iEvent.ds = iEvent.scale - interaction.gesture.scale;
    iEvent.da = iEvent.angle - interaction.gesture.angle;
  }

  interaction.gesture.distance = iEvent.distance;
  interaction.gesture.angle = iEvent.angle;

  if (__utils_4.is.number(iEvent.scale) && iEvent.scale !== Infinity && !isNaN(iEvent.scale)) {
    interaction.gesture.scale = iEvent.scale;
  }
}

var ___default_4 = gesture;
_$gesture_4["default"] = ___default_4;

var _$resize_6 = {};
"use strict";

Object.defineProperty(_$resize_6, "__esModule", {
  value: true
});
_$resize_6["default"] = void 0;

var ___scope_6 = _$scope_24({});

var __arr_6 = ___interopRequireWildcard_6(_$arr_47);

var __dom_6 = ___interopRequireWildcard_6(_$domUtils_51);

var ___extend_6 = ___interopRequireDefault_6(_$extend_53);

var __is_6 = ___interopRequireWildcard_6(_$is_57);

function ___interopRequireDefault_6(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_6(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

___scope_6.ActionName.Resize = 'resize';

function __install_6(scope) {
  var actions = scope.actions,
      browser = scope.browser,
      Interactable = scope.Interactable,
      interactions = scope.interactions,
      defaults = scope.defaults; // Less Precision with touch input

  interactions.signals.on('new', function (interaction) {
    interaction.resizeAxes = 'xy';
  });
  interactions.signals.on('action-start', start);
  interactions.signals.on('action-move', __move_6);
  interactions.signals.on('action-start', updateEventAxes);
  interactions.signals.on('action-move', updateEventAxes);
  resize.cursors = initCursors(browser);
  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10;
  /**
   * ```js
   * interact(element).resizable({
   *   onstart: function (event) {},
   *   onmove : function (event) {},
   *   onend  : function (event) {},
   *
   *   edges: {
   *     top   : true,       // Use pointer coords to check for resize.
   *     left  : false,      // Disable resizing from left edge.
   *     bottom: '.resize-s',// Resize if pointer target matches selector
   *     right : handleEl    // Resize if pointer target is the given Element
   *   },
   *
   *     // Width and height can be adjusted independently. When `true`, width and
   *     // height are adjusted at a 1:1 ratio.
   *     square: false,
   *
   *     // Width and height can be adjusted independently. When `true`, width and
   *     // height maintain the aspect ratio they had when resizing started.
   *     preserveAspectRatio: false,
   *
   *   // a value of 'none' will limit the resize rect to a minimum of 0x0
   *   // 'negate' will allow the rect to have negative width/height
   *   // 'reposition' will keep the width/height positive by swapping
   *   // the top and bottom edges and/or swapping the left and right edges
   *   invert: 'none' || 'negate' || 'reposition'
   *
   *   // limit multiple resizes.
   *   // See the explanation in the {@link Interactable.draggable} example
   *   max: Infinity,
   *   maxPerElement: 1,
   * })
   *
   * var isResizeable = interact(element).resizable()
   * ```
   *
   * Gets or sets whether resize actions can be performed on the target
   *
   * @param {boolean | object} [options] true/false or An object with event
   * listeners to be fired on resize events (object makes the Interactable
   * resizable)
   * @return {boolean | Interactable} A boolean indicating if this can be the
   * target of resize elements, or this Interactable
   */

  Interactable.prototype.resizable = function (options) {
    return resizable(this, options, scope);
  };

  actions[___scope_6.ActionName.Resize] = resize;
  actions.names.push(___scope_6.ActionName.Resize);
  __arr_6.merge(actions.eventTypes, ['resizestart', 'resizemove', 'resizeinertiastart', 'resizeresume', 'resizeend']);
  actions.methodDict.resize = 'resizable';
  defaults.actions.resize = resize.defaults;
}

var resize = {
  id: 'actions/resize',
  install: __install_6,
  defaults: {
    square: false,
    preserveAspectRatio: false,
    axis: 'xy',
    // use default margin
    margin: NaN,
    // object with props left, right, top, bottom which are
    // true/false values to resize when the pointer is over that edge,
    // CSS selectors to match the handles for each direction
    // or the Elements for each handle
    edges: null,
    // a value of 'none' will limit the resize rect to a minimum of 0x0
    // 'negate' will alow the rect to have negative width/height
    // 'reposition' will keep the width/height positive by swapping
    // the top and bottom edges and/or swapping the left and right edges
    invert: 'none'
  },
  checker: function checker(_pointer, _event, interactable, element, interaction, rect) {
    if (!rect) {
      return null;
    }

    var page = (0, ___extend_6["default"])({}, interaction.coords.cur.page);
    var options = interactable.options;

    if (options.resize.enabled) {
      var resizeOptions = options.resize;
      var resizeEdges = {
        left: false,
        right: false,
        top: false,
        bottom: false
      }; // if using resize.edges

      if (__is_6.object(resizeOptions.edges)) {
        for (var edge in resizeEdges) {
          resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._latestPointer.eventTarget, element, rect, resizeOptions.margin || this.defaultMargin);
        }

        resizeEdges.left = resizeEdges.left && !resizeEdges.right;
        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;

        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {
          return {
            name: 'resize',
            edges: resizeEdges
          };
        }
      } else {
        var right = options.resize.axis !== 'y' && page.x > rect.right - this.defaultMargin;
        var bottom = options.resize.axis !== 'x' && page.y > rect.bottom - this.defaultMargin;

        if (right || bottom) {
          return {
            name: 'resize',
            axes: (right ? 'x' : '') + (bottom ? 'y' : '')
          };
        }
      }
    }

    return null;
  },
  cursors: null,
  getCursor: function getCursor(_ref) {
    var edges = _ref.edges,
        axis = _ref.axis,
        name = _ref.name;
    var cursors = resize.cursors;
    var result = null;

    if (axis) {
      result = cursors[name + axis];
    } else if (edges) {
      var cursorKey = '';
      var _arr = ['top', 'bottom', 'left', 'right'];

      for (var _i = 0; _i < _arr.length; _i++) {
        var edge = _arr[_i];

        if (edges[edge]) {
          cursorKey += edge;
        }
      }

      result = cursors[cursorKey];
    }

    return result;
  },
  defaultMargin: null
};

function resizable(interactable, options, scope) {
  if (__is_6.object(options)) {
    interactable.options.resize.enabled = options.enabled !== false;
    interactable.setPerAction('resize', options);
    interactable.setOnEvents('resize', options);

    if (__is_6.string(options.axis) && /^x$|^y$|^xy$/.test(options.axis)) {
      interactable.options.resize.axis = options.axis;
    } else if (options.axis === null) {
      interactable.options.resize.axis = scope.defaults.actions.resize.axis;
    }

    if (__is_6.bool(options.preserveAspectRatio)) {
      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio;
    } else if (__is_6.bool(options.square)) {
      interactable.options.resize.square = options.square;
    }

    return interactable;
  }

  if (__is_6.bool(options)) {
    interactable.options.resize.enabled = options;
    return interactable;
  }

  return interactable.options.resize;
}

function checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {
  // false, '', undefined, null
  if (!value) {
    return false;
  } // true value, use pointer coords and element rect


  if (value === true) {
    // if dimensions are negative, "switch" edges
    var width = __is_6.number(rect.width) ? rect.width : rect.right - rect.left;
    var height = __is_6.number(rect.height) ? rect.height : rect.bottom - rect.top; // don't use margin greater than half the relevent dimension

    margin = Math.min(margin, (name === 'left' || name === 'right' ? width : height) / 2);

    if (width < 0) {
      if (name === 'left') {
        name = 'right';
      } else if (name === 'right') {
        name = 'left';
      }
    }

    if (height < 0) {
      if (name === 'top') {
        name = 'bottom';
      } else if (name === 'bottom') {
        name = 'top';
      }
    }

    if (name === 'left') {
      return page.x < (width >= 0 ? rect.left : rect.right) + margin;
    }

    if (name === 'top') {
      return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;
    }

    if (name === 'right') {
      return page.x > (width >= 0 ? rect.right : rect.left) - margin;
    }

    if (name === 'bottom') {
      return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;
    }
  } // the remaining checks require an element


  if (!__is_6.element(element)) {
    return false;
  }

  return __is_6.element(value) // the value is an element to use as a resize handle
  ? value === element // otherwise check if element matches value as selector
  : __dom_6.matchesUpTo(element, value, interactableElement);
}

function initCursors(browser) {
  return browser.isIe9 ? {
    x: 'e-resize',
    y: 's-resize',
    xy: 'se-resize',
    top: 'n-resize',
    left: 'w-resize',
    bottom: 's-resize',
    right: 'e-resize',
    topleft: 'se-resize',
    bottomright: 'se-resize',
    topright: 'ne-resize',
    bottomleft: 'ne-resize'
  } : {
    x: 'ew-resize',
    y: 'ns-resize',
    xy: 'nwse-resize',
    top: 'ns-resize',
    left: 'ew-resize',
    bottom: 'ns-resize',
    right: 'ew-resize',
    topleft: 'nwse-resize',
    bottomright: 'nwse-resize',
    topright: 'nesw-resize',
    bottomleft: 'nesw-resize'
  };
}

function start(_ref2) {
  var iEvent = _ref2.iEvent,
      interaction = _ref2.interaction;

  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {
    return;
  }

  var startRect = interaction.rect;
  var resizeOptions = interaction.interactable.options.resize;
  /*
   * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge
   * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make
   * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend
   * on the active edges and the edge being interacted with.
   */

  if (resizeOptions.square || resizeOptions.preserveAspectRatio) {
    var linkedEdges = (0, ___extend_6["default"])({}, interaction.prepared.edges);
    linkedEdges.top = linkedEdges.top || linkedEdges.left && !linkedEdges.bottom;
    linkedEdges.left = linkedEdges.left || linkedEdges.top && !linkedEdges.right;
    linkedEdges.bottom = linkedEdges.bottom || linkedEdges.right && !linkedEdges.top;
    linkedEdges.right = linkedEdges.right || linkedEdges.bottom && !linkedEdges.left;
    interaction.prepared._linkedEdges = linkedEdges;
  } else {
    interaction.prepared._linkedEdges = null;
  } // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize


  if (resizeOptions.preserveAspectRatio) {
    interaction.resizeStartAspectRatio = startRect.width / startRect.height;
  }

  interaction.resizeRects = {
    start: startRect,
    current: (0, ___extend_6["default"])({}, startRect),
    inverted: (0, ___extend_6["default"])({}, startRect),
    previous: (0, ___extend_6["default"])({}, startRect),
    delta: {
      left: 0,
      right: 0,
      width: 0,
      top: 0,
      bottom: 0,
      height: 0
    }
  };
  iEvent.rect = interaction.resizeRects.inverted;
  iEvent.deltaRect = interaction.resizeRects.delta;
}

function __move_6(_ref3) {
  var iEvent = _ref3.iEvent,
      interaction = _ref3.interaction;

  if (interaction.prepared.name !== 'resize' || !interaction.prepared.edges) {
    return;
  }

  var resizeOptions = interaction.interactable.options.resize;
  var invert = resizeOptions.invert;
  var invertible = invert === 'reposition' || invert === 'negate';
  var edges = interaction.prepared.edges; // eslint-disable-next-line no-shadow

  var start = interaction.resizeRects.start;
  var current = interaction.resizeRects.current;
  var inverted = interaction.resizeRects.inverted;
  var deltaRect = interaction.resizeRects.delta;
  var previous = (0, ___extend_6["default"])(interaction.resizeRects.previous, inverted);
  var originalEdges = edges;
  var eventDelta = (0, ___extend_6["default"])({}, iEvent.delta);

  if (resizeOptions.preserveAspectRatio || resizeOptions.square) {
    // `resize.preserveAspectRatio` takes precedence over `resize.square`
    var startAspectRatio = resizeOptions.preserveAspectRatio ? interaction.resizeStartAspectRatio : 1;
    edges = interaction.prepared._linkedEdges;

    if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {
      eventDelta.y = -eventDelta.x / startAspectRatio;
    } else if (originalEdges.left || originalEdges.right) {
      eventDelta.y = eventDelta.x / startAspectRatio;
    } else if (originalEdges.top || originalEdges.bottom) {
      eventDelta.x = eventDelta.y * startAspectRatio;
    }
  } // update the 'current' rect without modifications


  if (edges.top) {
    current.top += eventDelta.y;
  }

  if (edges.bottom) {
    current.bottom += eventDelta.y;
  }

  if (edges.left) {
    current.left += eventDelta.x;
  }

  if (edges.right) {
    current.right += eventDelta.x;
  }

  if (invertible) {
    // if invertible, copy the current rect
    (0, ___extend_6["default"])(inverted, current);

    if (invert === 'reposition') {
      // swap edge values if necessary to keep width/height positive
      var swap;

      if (inverted.top > inverted.bottom) {
        swap = inverted.top;
        inverted.top = inverted.bottom;
        inverted.bottom = swap;
      }

      if (inverted.left > inverted.right) {
        swap = inverted.left;
        inverted.left = inverted.right;
        inverted.right = swap;
      }
    }
  } else {
    // if not invertible, restrict to minimum of 0x0 rect
    inverted.top = Math.min(current.top, start.bottom);
    inverted.bottom = Math.max(current.bottom, start.top);
    inverted.left = Math.min(current.left, start.right);
    inverted.right = Math.max(current.right, start.left);
  }

  inverted.width = inverted.right - inverted.left;
  inverted.height = inverted.bottom - inverted.top;

  for (var edge in inverted) {
    deltaRect[edge] = inverted[edge] - previous[edge];
  }

  iEvent.edges = interaction.prepared.edges;
  iEvent.rect = inverted;
  iEvent.deltaRect = deltaRect;
}

function updateEventAxes(_ref4) {
  var interaction = _ref4.interaction,
      iEvent = _ref4.iEvent,
      action = _ref4.action;

  if (action !== 'resize' || !interaction.resizeAxes) {
    return;
  }

  var options = interaction.interactable.options;

  if (options.resize.square) {
    if (interaction.resizeAxes === 'y') {
      iEvent.delta.x = iEvent.delta.y;
    } else {
      iEvent.delta.y = iEvent.delta.x;
    }

    iEvent.axes = 'xy';
  } else {
    iEvent.axes = interaction.resizeAxes;

    if (interaction.resizeAxes === 'x') {
      iEvent.delta.y = 0;
    } else if (interaction.resizeAxes === 'y') {
      iEvent.delta.x = 0;
    }
  }
}

var ___default_6 = resize;
_$resize_6["default"] = ___default_6;

var _$actions_5 = {};
"use strict";

Object.defineProperty(_$actions_5, "__esModule", {
  value: true
});
_$actions_5.install = __install_5;
Object.defineProperty(_$actions_5, "drag", {
  enumerable: true,
  get: function get() {
    return ___drag_5["default"];
  }
});
Object.defineProperty(_$actions_5, "drop", {
  enumerable: true,
  get: function get() {
    return _drop["default"];
  }
});
Object.defineProperty(_$actions_5, "gesture", {
  enumerable: true,
  get: function get() {
    return _gesture["default"];
  }
});
Object.defineProperty(_$actions_5, "resize", {
  enumerable: true,
  get: function get() {
    return _resize["default"];
  }
});
_$actions_5.id = void 0;

var ___drag_5 = ___interopRequireDefault_5(_$drag_1);

var _drop = ___interopRequireDefault_5(_$drop_3);

var _gesture = ___interopRequireDefault_5(_$gesture_4);

var _resize = ___interopRequireDefault_5(_$resize_6);

function ___interopRequireDefault_5(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function __install_5(scope) {
  scope.usePlugin(_gesture["default"]);
  scope.usePlugin(_resize["default"]);
  scope.usePlugin(___drag_5["default"]);
  scope.usePlugin(_drop["default"]);
}

var id = 'actions';
_$actions_5.id = id;

var _$autoScroll_7 = {};
"use strict";

Object.defineProperty(_$autoScroll_7, "__esModule", {
  value: true
});
_$autoScroll_7.getContainer = getContainer;
_$autoScroll_7.getScroll = getScroll;
_$autoScroll_7.getScrollSize = getScrollSize;
_$autoScroll_7.getScrollSizeDelta = getScrollSizeDelta;
_$autoScroll_7["default"] = void 0;

var __domUtils_7 = ___interopRequireWildcard_7(_$domUtils_51);

var __is_7 = ___interopRequireWildcard_7(_$is_57);

var ___raf_7 = ___interopRequireDefault_7(_$raf_62);

/* removed: var _$rect_63 = require("@interactjs/utils/rect"); */;

/* removed: var _$window_66 = require("@interactjs/utils/window"); */;

function ___interopRequireDefault_7(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_7(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function __install_7(scope) {
  var interactions = scope.interactions,
      defaults = scope.defaults,
      actions = scope.actions;
  scope.autoScroll = autoScroll;

  autoScroll.now = function () {
    return scope.now();
  };

  interactions.signals.on('new', function (_ref) {
    var interaction = _ref.interaction;
    interaction.autoScroll = null;
  });
  interactions.signals.on('destroy', function (_ref2) {
    var interaction = _ref2.interaction;
    interaction.autoScroll = null;
    autoScroll.stop();

    if (autoScroll.interaction) {
      autoScroll.interaction = null;
    }
  });
  interactions.signals.on('stop', autoScroll.stop);
  interactions.signals.on('action-move', function (arg) {
    return autoScroll.onInteractionMove(arg);
  });
  actions.eventTypes.push('autoscroll');
  defaults.perAction.autoScroll = autoScroll.defaults;
}

var autoScroll = {
  defaults: {
    enabled: false,
    margin: 60,
    // the item that is scrolled (Window or HTMLElement)
    container: null,
    // the scroll speed in pixels per second
    speed: 300
  },
  now: Date.now,
  interaction: null,
  i: null,
  x: 0,
  y: 0,
  isScrolling: false,
  prevTime: 0,
  margin: 0,
  speed: 0,
  start: function start(interaction) {
    autoScroll.isScrolling = true;

    ___raf_7["default"].cancel(autoScroll.i);

    interaction.autoScroll = autoScroll;
    autoScroll.interaction = interaction;
    autoScroll.prevTime = autoScroll.now();
    autoScroll.i = ___raf_7["default"].request(autoScroll.scroll);
  },
  stop: function stop() {
    autoScroll.isScrolling = false;

    if (autoScroll.interaction) {
      autoScroll.interaction.autoScroll = null;
    }

    ___raf_7["default"].cancel(autoScroll.i);
  },
  // scroll the window by the values in scroll.x/y
  scroll: function scroll() {
    var interaction = autoScroll.interaction;
    var interactable = interaction.interactable,
        element = interaction.element;
    var options = interactable.options[autoScroll.interaction.prepared.name].autoScroll;
    var container = getContainer(options.container, interactable, element);
    var now = autoScroll.now(); // change in time in seconds

    var dt = (now - autoScroll.prevTime) / 1000; // displacement

    var s = options.speed * dt;

    if (s >= 1) {
      var scrollBy = {
        x: autoScroll.x * s,
        y: autoScroll.y * s
      };

      if (scrollBy.x || scrollBy.y) {
        var prevScroll = getScroll(container);

        if (__is_7.window(container)) {
          container.scrollBy(scrollBy.x, scrollBy.y);
        } else if (container) {
          container.scrollLeft += scrollBy.x;
          container.scrollTop += scrollBy.y;
        }

        var curScroll = getScroll(container);
        var delta = {
          x: curScroll.x - prevScroll.x,
          y: curScroll.y - prevScroll.y
        };

        if (delta.x || delta.y) {
          interactable.fire({
            type: 'autoscroll',
            target: element,
            interactable: interactable,
            delta: delta,
            interaction: interaction,
            container: container
          });
        }
      }

      autoScroll.prevTime = now;
    }

    if (autoScroll.isScrolling) {
      ___raf_7["default"].cancel(autoScroll.i);

      autoScroll.i = ___raf_7["default"].request(autoScroll.scroll);
    }
  },
  check: function check(interactable, actionName) {
    var options = interactable.options;
    return options[actionName].autoScroll && options[actionName].autoScroll.enabled;
  },
  onInteractionMove: function onInteractionMove(_ref3) {
    var interaction = _ref3.interaction,
        pointer = _ref3.pointer;

    if (!(interaction.interacting() && autoScroll.check(interaction.interactable, interaction.prepared.name))) {
      return;
    }

    if (interaction.simulation) {
      autoScroll.x = autoScroll.y = 0;
      return;
    }

    var top;
    var right;
    var bottom;
    var left;
    var interactable = interaction.interactable,
        element = interaction.element;
    var options = interactable.options[interaction.prepared.name].autoScroll;
    var container = getContainer(options.container, interactable, element);

    if (__is_7.window(container)) {
      left = pointer.clientX < autoScroll.margin;
      top = pointer.clientY < autoScroll.margin;
      right = pointer.clientX > container.innerWidth - autoScroll.margin;
      bottom = pointer.clientY > container.innerHeight - autoScroll.margin;
    } else {
      var rect = __domUtils_7.getElementClientRect(container);
      left = pointer.clientX < rect.left + autoScroll.margin;
      top = pointer.clientY < rect.top + autoScroll.margin;
      right = pointer.clientX > rect.right - autoScroll.margin;
      bottom = pointer.clientY > rect.bottom - autoScroll.margin;
    }

    autoScroll.x = right ? 1 : left ? -1 : 0;
    autoScroll.y = bottom ? 1 : top ? -1 : 0;

    if (!autoScroll.isScrolling) {
      // set the autoScroll properties to those of the target
      autoScroll.margin = options.margin;
      autoScroll.speed = options.speed;
      autoScroll.start(interaction);
    }
  }
};

function getContainer(value, interactable, element) {
  return (__is_7.string(value) ? (0, _$rect_63.getStringOptionResult)(value, interactable, element) : value) || (0, _$window_66.getWindow)(element);
}

function getScroll(container) {
  if (__is_7.window(container)) {
    container = window.document.body;
  }

  return {
    x: container.scrollLeft,
    y: container.scrollTop
  };
}

function getScrollSize(container) {
  if (__is_7.window(container)) {
    container = window.document.body;
  }

  return {
    x: container.scrollWidth,
    y: container.scrollHeight
  };
}

function getScrollSizeDelta(_ref4, func) {
  var interaction = _ref4.interaction,
      element = _ref4.element;
  var scrollOptions = interaction && interaction.interactable.options[interaction.prepared.name].autoScroll;

  if (!scrollOptions || !scrollOptions.enabled) {
    func();
    return {
      x: 0,
      y: 0
    };
  }

  var scrollContainer = getContainer(scrollOptions.container, interaction.interactable, element);
  var prevSize = getScroll(scrollContainer);
  func();
  var curSize = getScroll(scrollContainer);
  return {
    x: curSize.x - prevSize.x,
    y: curSize.y - prevSize.y
  };
}

var ___default_7 = {
  id: 'auto-scroll',
  install: __install_7
};
_$autoScroll_7["default"] = ___default_7;

var _$InteractableMethods_8 = {};
"use strict";

Object.defineProperty(_$InteractableMethods_8, "__esModule", {
  value: true
});
_$InteractableMethods_8["default"] = void 0;

/* removed: var _$utils_56 = require("@interactjs/utils"); */;

var __is_8 = ___interopRequireWildcard_8(_$is_57);

function ___interopRequireWildcard_8(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function __install_8(scope) {
  var Interactable = scope.Interactable,
      actions = scope.actions;
  Interactable.prototype.getAction = getAction;
  /**
   * ```js
   * interact(element, { ignoreFrom: document.getElementById('no-action') })
   * // or
   * interact(element).ignoreFrom('input, textarea, a')
   * ```
   * @deprecated
   * If the target of the `mousedown`, `pointerdown` or `touchstart` event or any
   * of it's parents match the given CSS selector or Element, no
   * drag/resize/gesture is started.
   *
   * Don't use this method. Instead set the `ignoreFrom` option for each action
   * or for `pointerEvents`
   *
   * @example
   * interact(targett)
   *   .draggable({
   *     ignoreFrom: 'input, textarea, a[href]'',
   *   })
   *   .pointerEvents({
   *     ignoreFrom: '[no-pointer]',
   *   })
   *
   * @param {string | Element | null} [newValue] a CSS selector string, an
   * Element or `null` to not ignore any elements
   * @return {string | Element | object} The current ignoreFrom value or this
   * Interactable
   */

  Interactable.prototype.ignoreFrom = (0, _$utils_56.warnOnce)(function (newValue) {
    return this._backCompatOption('ignoreFrom', newValue);
  }, 'Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue}).');
  /**
   * @deprecated
   *
   * A drag/resize/gesture is started only If the target of the `mousedown`,
   * `pointerdown` or `touchstart` event or any of it's parents match the given
   * CSS selector or Element.
   *
   * Don't use this method. Instead set the `allowFrom` option for each action
   * or for `pointerEvents`
   *
   * @example
   * interact(targett)
   *   .resizable({
   *     allowFrom: '.resize-handle',
   *   .pointerEvents({
   *     allowFrom: '.handle',,
   *   })
   *
   * @param {string | Element | null} [newValue] a CSS selector string, an
   * Element or `null` to allow from any element
   * @return {string | Element | object} The current allowFrom value or this
   * Interactable
   */

  Interactable.prototype.allowFrom = (0, _$utils_56.warnOnce)(function (newValue) {
    return this._backCompatOption('allowFrom', newValue);
  }, 'Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue}).');
  /**
   * ```js
   * interact('.resize-drag')
   *   .resizable(true)
   *   .draggable(true)
   *   .actionChecker(function (pointer, event, action, interactable, element, interaction) {
   *
   *   if (interact.matchesSelector(event.target, '.drag-handle')) {
   *     // force drag with handle target
   *     action.name = drag
   *   }
   *   else {
   *     // resize from the top and right edges
   *     action.name  = 'resize'
   *     action.edges = { top: true, right: true }
   *   }
   *
   *   return action
   * })
   * ```
   *
   * Returns or sets the function used to check action to be performed on
   * pointerDown
   *
   * @param {function | null} [checker] A function which takes a pointer event,
   * defaultAction string, interactable, element and interaction as parameters
   * and returns an object with name property 'drag' 'resize' or 'gesture' and
   * optionally an `edges` object with boolean 'top', 'left', 'bottom' and right
   * props.
   * @return {Function | Interactable} The checker function or this Interactable
   */

  Interactable.prototype.actionChecker = actionChecker;
  /**
   * Returns or sets whether the the cursor should be changed depending on the
   * action that would be performed if the mouse were pressed and dragged.
   *
   * @param {boolean} [newValue]
   * @return {boolean | Interactable} The current setting or this Interactable
   */

  Interactable.prototype.styleCursor = styleCursor;

  Interactable.prototype.defaultActionChecker = function (pointer, event, interaction, element) {
    return defaultActionChecker(this, pointer, event, interaction, element, actions);
  };
}

function getAction(pointer, event, interaction, element) {
  var action = this.defaultActionChecker(pointer, event, interaction, element);

  if (this.options.actionChecker) {
    return this.options.actionChecker(pointer, event, action, this, element, interaction);
  }

  return action;
}

function defaultActionChecker(interactable, pointer, event, interaction, element, actions) {
  var rect = interactable.getRect(element);
  var buttons = event.buttons || {
    0: 1,
    1: 4,
    3: 8,
    4: 16
  }[event.button];
  var action = null;

  for (var _i = 0; _i < actions.names.length; _i++) {
    var _ref;

    _ref = actions.names[_i];
    var actionName = _ref;

    // check mouseButton setting if the pointer is down
    if (interaction.pointerIsDown && /mouse|pointer/.test(interaction.pointerType) && (buttons & interactable.options[actionName].mouseButtons) === 0) {
      continue;
    }

    action = actions[actionName].checker(pointer, event, interactable, element, interaction, rect);

    if (action) {
      return action;
    }
  }
}

function styleCursor(newValue) {
  if (__is_8.bool(newValue)) {
    this.options.styleCursor = newValue;
    return this;
  }

  if (newValue === null) {
    delete this.options.styleCursor;
    return this;
  }

  return this.options.styleCursor;
}

function actionChecker(checker) {
  if (__is_8.func(checker)) {
    this.options.actionChecker = checker;
    return this;
  }

  if (checker === null) {
    delete this.options.actionChecker;
    return this;
  }

  return this.options.actionChecker;
}

var ___default_8 = {
  id: 'auto-start/interactableMethods',
  install: __install_8
};
_$InteractableMethods_8["default"] = ___default_8;

var _$base_9 = {};
"use strict";

Object.defineProperty(_$base_9, "__esModule", {
  value: true
});
_$base_9["default"] = void 0;

var __utils_9 = ___interopRequireWildcard_9(_$utils_56);

var _InteractableMethods = ___interopRequireDefault_9(_$InteractableMethods_8);

function ___interopRequireDefault_9(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_9(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function __install_9(scope) {
  var interact = scope.interact,
      interactions = scope.interactions,
      defaults = scope.defaults;
  scope.usePlugin(_InteractableMethods["default"]); // set cursor style on mousedown

  interactions.signals.on('down', function (_ref) {
    var interaction = _ref.interaction,
        pointer = _ref.pointer,
        event = _ref.event,
        eventTarget = _ref.eventTarget;

    if (interaction.interacting()) {
      return;
    }

    var actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope);
    prepare(interaction, actionInfo, scope);
  }); // set cursor style on mousemove

  interactions.signals.on('move', function (_ref2) {
    var interaction = _ref2.interaction,
        pointer = _ref2.pointer,
        event = _ref2.event,
        eventTarget = _ref2.eventTarget;

    if (interaction.pointerType !== 'mouse' || interaction.pointerIsDown || interaction.interacting()) {
      return;
    }

    var actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope);
    prepare(interaction, actionInfo, scope);
  });
  interactions.signals.on('move', function (arg) {
    var interaction = arg.interaction;

    if (!interaction.pointerIsDown || interaction.interacting() || !interaction.pointerWasMoved || !interaction.prepared.name) {
      return;
    }

    scope.autoStart.signals.fire('before-start', arg);
    var interactable = interaction.interactable;

    if (interaction.prepared.name && interactable) {
      // check manualStart and interaction limit
      if (interactable.options[interaction.prepared.name].manualStart || !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)) {
        interaction.stop();
      } else {
        interaction.start(interaction.prepared, interactable, interaction.element);
      }
    }
  });
  interactions.signals.on('stop', function (_ref3) {
    var interaction = _ref3.interaction;
    var interactable = interaction.interactable;

    if (interactable && interactable.options.styleCursor) {
      setCursor(interaction.element, '', scope);
    }
  });
  defaults.base.actionChecker = null;
  defaults.base.styleCursor = true;
  __utils_9.extend(defaults.perAction, {
    manualStart: false,
    max: Infinity,
    maxPerElement: 1,
    allowFrom: null,
    ignoreFrom: null,
    // only allow left button by default
    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value
    mouseButtons: 1
  });
  /**
   * Returns or sets the maximum number of concurrent interactions allowed.  By
   * default only 1 interaction is allowed at a time (for backwards
   * compatibility). To allow multiple interactions on the same Interactables and
   * elements, you need to enable it in the draggable, resizable and gesturable
   * `'max'` and `'maxPerElement'` options.
   *
   * @alias module:interact.maxInteractions
   *
   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.
   */

  interact.maxInteractions = function (newValue) {
    return maxInteractions(newValue, scope);
  };

  scope.autoStart = {
    // Allow this many interactions to happen simultaneously
    maxInteractions: Infinity,
    withinInteractionLimit: withinInteractionLimit,
    cursorElement: null,
    signals: new __utils_9.Signals()
  };
} // Check if the current interactable supports the action.
// If so, return the validated action. Otherwise, return null


function validateAction(action, interactable, element, eventTarget, scope) {
  if (interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) && interactable.options[action.name].enabled && withinInteractionLimit(interactable, element, action, scope)) {
    return action;
  }

  return null;
}

function validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope) {
  for (var i = 0, len = matches.length; i < len; i++) {
    var match = matches[i];
    var matchElement = matchElements[i];
    var matchAction = match.getAction(pointer, event, interaction, matchElement);

    if (!matchAction) {
      continue;
    }

    var action = validateAction(matchAction, match, matchElement, eventTarget, scope);

    if (action) {
      return {
        action: action,
        interactable: match,
        element: matchElement
      };
    }
  }

  return {
    action: null,
    interactable: null,
    element: null
  };
}

function getActionInfo(interaction, pointer, event, eventTarget, scope) {
  var matches = [];
  var matchElements = [];
  var element = eventTarget;

  function pushMatches(interactable) {
    matches.push(interactable);
    matchElements.push(element);
  }

  while (__utils_9.is.element(element)) {
    matches = [];
    matchElements = [];
    scope.interactables.forEachMatch(element, pushMatches);
    var actionInfo = validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope);

    if (actionInfo.action && !actionInfo.interactable.options[actionInfo.action.name].manualStart) {
      return actionInfo;
    }

    element = __utils_9.dom.parentNode(element);
  }

  return {
    action: null,
    interactable: null,
    element: null
  };
}

function prepare(interaction, _ref4, scope) {
  var action = _ref4.action,
      interactable = _ref4.interactable,
      element = _ref4.element;
  action = action || {};

  if (interaction.interactable && interaction.interactable.options.styleCursor) {
    setCursor(interaction.element, '', scope);
  }

  interaction.interactable = interactable;
  interaction.element = element;
  __utils_9.copyAction(interaction.prepared, action);
  interaction.rect = interactable && action.name ? interactable.getRect(element) : null;

  if (interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor) {
    var cursor = '';

    if (action) {
      var cursorChecker = interactable.options[action.name].cursorChecker;

      if (__utils_9.is.func(cursorChecker)) {
        cursor = cursorChecker(action, interactable, element);
      } else {
        cursor = scope.actions[action.name].getCursor(action);
      }
    }

    setCursor(interaction.element, cursor || '', scope);
  }

  scope.autoStart.signals.fire('prepared', {
    interaction: interaction
  });
}

function withinInteractionLimit(interactable, element, action, scope) {
  var options = interactable.options;
  var maxActions = options[action.name].max;
  var maxPerElement = options[action.name].maxPerElement;
  var autoStartMax = scope.autoStart.maxInteractions;
  var activeInteractions = 0;
  var interactableCount = 0;
  var elementCount = 0; // no actions if any of these values == 0

  if (!(maxActions && maxPerElement && autoStartMax)) {
    return false;
  }

  for (var _i = 0; _i < scope.interactions.list.length; _i++) {
    var _ref5;

    _ref5 = scope.interactions.list[_i];
    var interaction = _ref5;
    var otherAction = interaction.prepared.name;

    if (!interaction.interacting()) {
      continue;
    }

    activeInteractions++;

    if (activeInteractions >= autoStartMax) {
      return false;
    }

    if (interaction.interactable !== interactable) {
      continue;
    }

    interactableCount += otherAction === action.name ? 1 : 0;

    if (interactableCount >= maxActions) {
      return false;
    }

    if (interaction.element === element) {
      elementCount++;

      if (otherAction === action.name && elementCount >= maxPerElement) {
        return false;
      }
    }
  }

  return autoStartMax > 0;
}

function maxInteractions(newValue, scope) {
  if (__utils_9.is.number(newValue)) {
    scope.autoStart.maxInteractions = newValue;
    return this;
  }

  return scope.autoStart.maxInteractions;
}

function setCursor(element, cursor, scope) {
  if (scope.autoStart.cursorElement) {
    scope.autoStart.cursorElement.style.cursor = '';
  }

  element.ownerDocument.documentElement.style.cursor = cursor;
  element.style.cursor = cursor;
  scope.autoStart.cursorElement = cursor ? element : null;
}

var ___default_9 = {
  id: 'auto-start/base',
  install: __install_9,
  maxInteractions: maxInteractions,
  withinInteractionLimit: withinInteractionLimit,
  validateAction: validateAction
};
_$base_9["default"] = ___default_9;

var _$dragAxis_10 = {};
"use strict";

Object.defineProperty(_$dragAxis_10, "__esModule", {
  value: true
});
_$dragAxis_10["default"] = void 0;

var ___scope_10 = _$scope_24({});

/* removed: var _$domUtils_51 = require("@interactjs/utils/domUtils"); */;

var __is_10 = ___interopRequireWildcard_10(_$is_57);

var _base = ___interopRequireDefault_10(_$base_9);

function ___interopRequireDefault_10(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_10(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function __install_10(scope) {
  scope.autoStart.signals.on('before-start', function (_ref) {
    var interaction = _ref.interaction,
        eventTarget = _ref.eventTarget,
        dx = _ref.dx,
        dy = _ref.dy;

    if (interaction.prepared.name !== 'drag') {
      return;
    } // check if a drag is in the correct axis


    var absX = Math.abs(dx);
    var absY = Math.abs(dy);
    var targetOptions = interaction.interactable.options.drag;
    var startAxis = targetOptions.startAxis;
    var currentAxis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy';
    interaction.prepared.axis = targetOptions.lockAxis === 'start' ? currentAxis[0] // always lock to one axis even if currentAxis === 'xy'
    : targetOptions.lockAxis; // if the movement isn't in the startAxis of the interactable

    if (currentAxis !== 'xy' && startAxis !== 'xy' && startAxis !== currentAxis) {
      // cancel the prepared action
      interaction.prepared.name = null; // then try to get a drag from another ineractable

      var element = eventTarget;

      var getDraggable = function getDraggable(interactable) {
        if (interactable === interaction.interactable) {
          return;
        }

        var options = interaction.interactable.options.drag;

        if (!options.manualStart && interactable.testIgnoreAllow(options, element, eventTarget)) {
          var action = interactable.getAction(interaction.downPointer, interaction.downEvent, interaction, element);

          if (action && action.name === ___scope_10.ActionName.Drag && checkStartAxis(currentAxis, interactable) && _base["default"].validateAction(action, interactable, element, eventTarget, scope)) {
            return interactable;
          }
        }
      }; // check all interactables


      while (__is_10.element(element)) {
        var interactable = scope.interactables.forEachMatch(element, getDraggable);

        if (interactable) {
          interaction.prepared.name = ___scope_10.ActionName.Drag;
          interaction.interactable = interactable;
          interaction.element = element;
          break;
        }

        element = (0, _$domUtils_51.parentNode)(element);
      }
    }
  });

  function checkStartAxis(startAxis, interactable) {
    if (!interactable) {
      return false;
    }

    var thisAxis = interactable.options[___scope_10.ActionName.Drag].startAxis;
    return startAxis === 'xy' || thisAxis === 'xy' || thisAxis === startAxis;
  }
}

var ___default_10 = {
  id: 'auto-start/dragAxis',
  install: __install_10
};
_$dragAxis_10["default"] = ___default_10;

var _$hold_11 = {};
"use strict";

Object.defineProperty(_$hold_11, "__esModule", {
  value: true
});
_$hold_11["default"] = void 0;

var ___base_11 = ___interopRequireDefault_11(_$base_9);

function ___interopRequireDefault_11(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function __install_11(scope) {
  var autoStart = scope.autoStart,
      interactions = scope.interactions,
      defaults = scope.defaults;
  scope.usePlugin(___base_11["default"]);
  defaults.perAction.hold = 0;
  defaults.perAction.delay = 0;
  interactions.signals.on('new', function (interaction) {
    interaction.autoStartHoldTimer = null;
  });
  autoStart.signals.on('prepared', function (_ref) {
    var interaction = _ref.interaction;
    var hold = getHoldDuration(interaction);

    if (hold > 0) {
      interaction.autoStartHoldTimer = setTimeout(function () {
        interaction.start(interaction.prepared, interaction.interactable, interaction.element);
      }, hold);
    }
  });
  interactions.signals.on('move', function (_ref2) {
    var interaction = _ref2.interaction,
        duplicate = _ref2.duplicate;

    if (interaction.pointerWasMoved && !duplicate) {
      clearTimeout(interaction.autoStartHoldTimer);
    }
  }); // prevent regular down->move autoStart

  autoStart.signals.on('before-start', function (_ref3) {
    var interaction = _ref3.interaction;
    var hold = getHoldDuration(interaction);

    if (hold > 0) {
      interaction.prepared.name = null;
    }
  });
}

function getHoldDuration(interaction) {
  var actionName = interaction.prepared && interaction.prepared.name;

  if (!actionName) {
    return null;
  }

  var options = interaction.interactable.options;
  return options[actionName].hold || options[actionName].delay;
}

var ___default_11 = {
  id: 'auto-start/hold',
  install: __install_11,
  getHoldDuration: getHoldDuration
};
_$hold_11["default"] = ___default_11;

var _$autoStart_12 = {};
"use strict";

Object.defineProperty(_$autoStart_12, "__esModule", {
  value: true
});
_$autoStart_12.install = __install_12;
Object.defineProperty(_$autoStart_12, "autoStart", {
  enumerable: true,
  get: function get() {
    return ___base_12["default"];
  }
});
Object.defineProperty(_$autoStart_12, "dragAxis", {
  enumerable: true,
  get: function get() {
    return _dragAxis["default"];
  }
});
Object.defineProperty(_$autoStart_12, "hold", {
  enumerable: true,
  get: function get() {
    return _hold["default"];
  }
});
_$autoStart_12.id = void 0;

var ___base_12 = ___interopRequireDefault_12(_$base_9);

var _dragAxis = ___interopRequireDefault_12(_$dragAxis_10);

var _hold = ___interopRequireDefault_12(_$hold_11);

function ___interopRequireDefault_12(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function __install_12(scope) {
  scope.usePlugin(___base_12["default"]);
  scope.usePlugin(_hold["default"]);
  scope.usePlugin(_dragAxis["default"]);
}

var __id_12 = 'auto-start';
_$autoStart_12.id = __id_12;

var _$interactablePreventDefault_21 = {};
"use strict";

Object.defineProperty(_$interactablePreventDefault_21, "__esModule", {
  value: true
});
_$interactablePreventDefault_21.install = __install_21;
_$interactablePreventDefault_21["default"] = void 0;

/* removed: var _$domUtils_51 = require("@interactjs/utils/domUtils"); */;

var ___events_21 = ___interopRequireDefault_21(_$events_52);

var __is_21 = ___interopRequireWildcard_21(_$is_57);

/* removed: var _$window_66 = require("@interactjs/utils/window"); */;

function ___interopRequireWildcard_21(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_21(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function preventDefault(newValue) {
  if (/^(always|never|auto)$/.test(newValue)) {
    this.options.preventDefault = newValue;
    return this;
  }

  if (__is_21.bool(newValue)) {
    this.options.preventDefault = newValue ? 'always' : 'never';
    return this;
  }

  return this.options.preventDefault;
}

function checkAndPreventDefault(interactable, scope, event) {
  var setting = interactable.options.preventDefault;

  if (setting === 'never') {
    return;
  }

  if (setting === 'always') {
    event.preventDefault();
    return;
  } // setting === 'auto'
  // if the browser supports passive event listeners and isn't running on iOS,
  // don't preventDefault of touch{start,move} events. CSS touch-action and
  // user-select should be used instead of calling event.preventDefault().


  if (___events_21["default"].supportsPassive && /^touch(start|move)$/.test(event.type)) {
    var doc = (0, _$window_66.getWindow)(event.target).document;
    var docOptions = scope.getDocOptions(doc);

    if (!(docOptions && docOptions.events) || docOptions.events.passive !== false) {
      return;
    }
  } // don't preventDefault of pointerdown events


  if (/^(mouse|pointer|touch)*(down|start)/i.test(event.type)) {
    return;
  } // don't preventDefault on editable elements


  if (__is_21.element(event.target) && (0, _$domUtils_51.matchesSelector)(event.target, 'input,select,textarea,[contenteditable=true],[contenteditable=true] *')) {
    return;
  }

  event.preventDefault();
}

function onInteractionEvent(_ref) {
  var interaction = _ref.interaction,
      event = _ref.event;

  if (interaction.interactable) {
    interaction.interactable.checkAndPreventDefault(event);
  }
}

function __install_21(scope) {
  /** @lends Interactable */
  var Interactable = scope.Interactable;
  /**
   * Returns or sets whether to prevent the browser's default behaviour in
   * response to pointer events. Can be set to:
   *  - `'always'` to always prevent
   *  - `'never'` to never prevent
   *  - `'auto'` to let interact.js try to determine what would be best
   *
   * @param {string} [newValue] `'always'`, `'never'` or `'auto'`
   * @return {string | Interactable} The current setting or this Interactable
   */

  Interactable.prototype.preventDefault = preventDefault;

  Interactable.prototype.checkAndPreventDefault = function (event) {
    return checkAndPreventDefault(this, scope, event);
  };

  var _arr = ['down', 'move', 'up', 'cancel'];

  for (var _i = 0; _i < _arr.length; _i++) {
    var eventSignal = _arr[_i];
    scope.interactions.signals.on(eventSignal, onInteractionEvent);
  } // prevent native HTML5 drag on interact.js target elements


  scope.interactions.docEvents.push({
    type: 'dragstart',
    listener: function listener(event) {
      for (var _i2 = 0; _i2 < scope.interactions.list.length; _i2++) {
        var _ref2;

        _ref2 = scope.interactions.list[_i2];
        var interaction = _ref2;

        if (interaction.element && (interaction.element === event.target || (0, _$domUtils_51.nodeContains)(interaction.element, event.target))) {
          interaction.interactable.checkAndPreventDefault(event);
          return;
        }
      }
    }
  });
}

var ___default_21 = {
  id: 'core/interactablePreventDefault',
  install: __install_21
};
_$interactablePreventDefault_21["default"] = ___default_21;

var _$devTools_25 = {};
"use strict";

Object.defineProperty(_$devTools_25, "__esModule", {
  value: true
});
_$devTools_25["default"] = void 0;

var ___domObjects_25 = ___interopRequireDefault_25(_$domObjects_50);

/* removed: var _$domUtils_51 = require("@interactjs/utils/domUtils"); */;

var ___extend_25 = ___interopRequireDefault_25(_$extend_53);

var __is_25 = ___interopRequireWildcard_25(_$is_57);

var ___window_25 = ___interopRequireDefault_25(_$window_66);

function ___interopRequireWildcard_25(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_25(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___toConsumableArray_25(arr) { return ___arrayWithoutHoles_25(arr) || ___iterableToArray_25(arr) || ___nonIterableSpread_25(); }

function ___nonIterableSpread_25() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function ___iterableToArray_25(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function ___arrayWithoutHoles_25(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var CheckName;

(function (CheckName) {
  CheckName["touchAction"] = "";
  CheckName["boxSizing"] = "";
  CheckName["noListeners"] = "";
})(CheckName || (CheckName = {}));

var prefix = '[interact.js] ';
var links = {
  touchAction: 'https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action',
  boxSizing: 'https://developer.mozilla.org/en-US/docs/Web/CSS/box-sizing'
};
var isProduction = "production" === 'production'; // eslint-disable-next-line no-restricted-syntax

function __install_25(scope) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      logger = _ref.logger;

  var interactions = scope.interactions,
      Interactable = scope.Interactable,
      defaults = scope.defaults;
  logger = logger || console;
  interactions.signals.on('action-start', function (_ref2) {
    var interaction = _ref2.interaction;

    for (var _i = 0; _i < checks.length; _i++) {
      var _ref3;

      _ref3 = checks[_i];
      var check = _ref3;
      var options = interaction.interactable && interaction.interactable.options[interaction.prepared.name];

      if (!(options && options.devTools && options.devTools.ignore[check.name]) && check.perform(interaction)) {
        var _logger;

        (_logger = logger).warn.apply(_logger, [prefix + check.text].concat(___toConsumableArray_25(check.getInfo(interaction))));
      }
    }
  });
  defaults.base.devTools = {
    ignore: {}
  };

  Interactable.prototype.devTools = function (options) {
    if (options) {
      (0, ___extend_25["default"])(this.options.devTools, options);
      return this;
    }

    return this.options.devTools;
  };
}

var checks = [{
  name: 'touchAction',
  perform: function perform(_ref4) {
    var element = _ref4.element;
    return !parentHasStyle(element, 'touchAction', /pan-|pinch|none/);
  },
  getInfo: function getInfo(_ref5) {
    var element = _ref5.element;
    return [element, links.touchAction];
  },
  text: 'Consider adding CSS "touch-action: none" to this element\n'
}, {
  name: 'boxSizing',
  perform: function perform(interaction) {
    var element = interaction.element;
    return interaction.prepared.name === 'resize' && element instanceof ___domObjects_25["default"].HTMLElement && !hasStyle(element, 'boxSizing', /border-box/);
  },
  text: 'Consider adding CSS "box-sizing: border-box" to this resizable element',
  getInfo: function getInfo(_ref6) {
    var element = _ref6.element;
    return [element, links.boxSizing];
  }
}, {
  name: 'noListeners',
  perform: function perform(interaction) {
    var actionName = interaction.prepared.name;
    var moveListeners = interaction.interactable.events.types["".concat(actionName, "move")] || [];
    return !moveListeners.length;
  },
  getInfo: function getInfo(interaction) {
    return [interaction.prepared.name, interaction.interactable];
  },
  text: 'There are no listeners set for this action'
}];

function hasStyle(element, prop, styleRe) {
  return styleRe.test(element.style[prop] || ___window_25["default"].window.getComputedStyle(element)[prop]);
}

function parentHasStyle(element, prop, styleRe) {
  var parent = element;

  while (__is_25.element(parent)) {
    if (hasStyle(parent, prop, styleRe)) {
      return true;
    }

    parent = (0, _$domUtils_51.parentNode)(parent);
  }

  return false;
}

var __id_25 = 'dev-tools';
var defaultExport = isProduction ? {
  id: __id_25,
  install: function install() {}
} : {
  id: __id_25,
  install: __install_25,
  checks: checks,
  CheckName: CheckName,
  links: links,
  prefix: prefix
};
var ___default_25 = defaultExport;
_$devTools_25["default"] = ___default_25;

var _$base_30 = {};
"use strict";

Object.defineProperty(_$base_30, "__esModule", {
  value: true
});
_$base_30.startAll = startAll;
_$base_30.setAll = setAll;
_$base_30.prepareStates = prepareStates;
_$base_30.makeModifier = makeModifier;
_$base_30["default"] = void 0;

var ___extend_30 = ___interopRequireDefault_30(_$extend_53);

function ___interopRequireDefault_30(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___slicedToArray_30(arr, i) { return ___arrayWithHoles_30(arr) || ___iterableToArrayLimit_30(arr, i) || ___nonIterableRest_30(); }

function ___nonIterableRest_30() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function ___iterableToArrayLimit_30(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function ___arrayWithHoles_30(arr) { if (Array.isArray(arr)) return arr; }

function __install_30(scope) {
  var interactions = scope.interactions;
  scope.defaults.perAction.modifiers = [];
  interactions.signals.on('new', function (_ref) {
    var interaction = _ref.interaction;
    interaction.modifiers = {
      startOffset: {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      },
      offsets: {},
      states: null,
      result: null,
      endPrevented: false,
      startDelta: null
    };
  });
  interactions.signals.on('before-action-start', function (arg) {
    __start_30(arg, arg.interaction.coords.start.page);
  });
  interactions.signals.on('action-resume', function (arg) {
    stop(arg);
    __start_30(arg, arg.interaction.coords.cur.page);
    __beforeMove_30(arg);
  });
  interactions.signals.on('after-action-move', restoreCoords);
  interactions.signals.on('before-action-move', __beforeMove_30);
  interactions.signals.on('before-action-start', setCoords);
  interactions.signals.on('after-action-start', restoreCoords);
  interactions.signals.on('before-action-end', beforeEnd);
  interactions.signals.on('stop', stop);
}

function __start_30(_ref2, pageCoords) {
  var interaction = _ref2.interaction,
      phase = _ref2.phase;
  var interactable = interaction.interactable,
      element = interaction.element;
  var modifierList = getModifierList(interaction);
  var states = prepareStates(modifierList);
  var rect = (0, ___extend_30["default"])({}, interaction.rect);

  if (!('width' in rect)) {
    rect.width = rect.right - rect.left;
  }

  if (!('height' in rect)) {
    rect.height = rect.bottom - rect.top;
  }

  var startOffset = getRectOffset(rect, pageCoords);
  interaction.modifiers.startOffset = startOffset;
  interaction.modifiers.startDelta = {
    x: 0,
    y: 0
  };
  var arg = {
    interaction: interaction,
    interactable: interactable,
    element: element,
    pageCoords: pageCoords,
    phase: phase,
    rect: rect,
    startOffset: startOffset,
    states: states,
    preEnd: false,
    requireEndOnly: false
  };
  interaction.modifiers.states = states;
  interaction.modifiers.result = null;
  startAll(arg);
  arg.pageCoords = (0, ___extend_30["default"])({}, interaction.coords.start.page);
  var result = interaction.modifiers.result = setAll(arg);
  return result;
}

function startAll(arg) {
  var states = arg.states;

  for (var _i = 0; _i < states.length; _i++) {
    var _ref3;

    _ref3 = states[_i];
    var state = _ref3;

    if (state.methods.start) {
      arg.state = state;
      state.methods.start(arg);
    }
  }
}

function setAll(arg) {
  var interaction = arg.interaction,
      _arg$modifiersState = arg.modifiersState,
      modifiersState = _arg$modifiersState === void 0 ? interaction.modifiers : _arg$modifiersState,
      _arg$prevCoords = arg.prevCoords,
      prevCoords = _arg$prevCoords === void 0 ? modifiersState.result ? modifiersState.result.coords : interaction.coords.prev.page : _arg$prevCoords,
      phase = arg.phase,
      preEnd = arg.preEnd,
      requireEndOnly = arg.requireEndOnly,
      rect = arg.rect,
      skipModifiers = arg.skipModifiers;
  var states = skipModifiers ? arg.states.slice(skipModifiers) : arg.states;
  arg.coords = (0, ___extend_30["default"])({}, arg.pageCoords);
  arg.rect = (0, ___extend_30["default"])({}, rect);
  var result = {
    delta: {
      x: 0,
      y: 0
    },
    rectDelta: {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    coords: arg.coords,
    changed: true
  };

  for (var _i2 = 0; _i2 < states.length; _i2++) {
    var _ref4;

    _ref4 = states[_i2];
    var state = _ref4;
    var options = state.options;

    if (!state.methods.set || !shouldDo(options, preEnd, requireEndOnly, phase)) {
      continue;
    }

    arg.state = state;
    state.methods.set(arg);
  }

  result.delta.x = arg.coords.x - arg.pageCoords.x;
  result.delta.y = arg.coords.y - arg.pageCoords.y;
  var rectChanged = false;

  if (rect) {
    result.rectDelta.left = arg.rect.left - rect.left;
    result.rectDelta.right = arg.rect.right - rect.right;
    result.rectDelta.top = arg.rect.top - rect.top;
    result.rectDelta.bottom = arg.rect.bottom - rect.bottom;
    rectChanged = result.rectDelta.left !== 0 || result.rectDelta.right !== 0 || result.rectDelta.top !== 0 || result.rectDelta.bottom !== 0;
  }

  result.changed = prevCoords.x !== result.coords.x || prevCoords.y !== result.coords.y || rectChanged;
  return result;
}

function __beforeMove_30(arg) {
  var interaction = arg.interaction,
      phase = arg.phase,
      preEnd = arg.preEnd,
      skipModifiers = arg.skipModifiers;
  var interactable = interaction.interactable,
      element = interaction.element;
  var modifierResult = setAll({
    interaction: interaction,
    interactable: interactable,
    element: element,
    preEnd: preEnd,
    phase: phase,
    pageCoords: interaction.coords.cur.page,
    rect: interaction.rect,
    states: interaction.modifiers.states,
    requireEndOnly: false,
    skipModifiers: skipModifiers
  });
  interaction.modifiers.result = modifierResult; // don't fire an action move if a modifier would keep the event in the same
  // cordinates as before

  if (!modifierResult.changed && interaction.interacting()) {
    return false;
  }

  setCoords(arg);
}

function beforeEnd(arg) {
  var interaction = arg.interaction,
      event = arg.event,
      noPreEnd = arg.noPreEnd;
  var states = interaction.modifiers.states;

  if (noPreEnd || !states || !states.length) {
    return;
  }

  var didPreEnd = false;

  for (var _i3 = 0; _i3 < states.length; _i3++) {
    var _ref5;

    _ref5 = states[_i3];
    var state = _ref5;
    arg.state = state;
    var options = state.options,
        methods = state.methods;
    var endResult = methods.beforeEnd && methods.beforeEnd(arg);

    if (endResult === false) {
      interaction.modifiers.endPrevented = true;
      return false;
    } // if the endOnly option is true for any modifier


    if (!didPreEnd && shouldDo(options, true, true)) {
      // fire a move event at the modified coordinates
      interaction.move({
        event: event,
        preEnd: true
      });
      didPreEnd = true;
    }
  }
}

function stop(arg) {
  var interaction = arg.interaction;
  var states = interaction.modifiers.states;

  if (!states || !states.length) {
    return;
  }

  var modifierArg = (0, ___extend_30["default"])({
    states: states,
    interactable: interaction.interactable,
    element: interaction.element
  }, arg);
  restoreCoords(arg);

  for (var _i4 = 0; _i4 < states.length; _i4++) {
    var _ref6;

    _ref6 = states[_i4];
    var state = _ref6;
    modifierArg.state = state;

    if (state.methods.stop) {
      state.methods.stop(modifierArg);
    }
  }

  arg.interaction.modifiers.states = null;
  arg.interaction.modifiers.endPrevented = false;
}

function getModifierList(interaction) {
  var actionOptions = interaction.interactable.options[interaction.prepared.name];
  var actionModifiers = actionOptions.modifiers;

  if (actionModifiers && actionModifiers.length) {
    return actionModifiers.filter(function (modifier) {
      return !modifier.options || modifier.options.enabled !== false;
    });
  }

  return ['snap', 'snapSize', 'snapEdges', 'restrict', 'restrictEdges', 'restrictSize'].map(function (type) {
    var options = actionOptions[type];
    return options && options.enabled && {
      options: options,
      methods: options._methods
    };
  }).filter(function (m) {
    return !!m;
  });
}

function prepareStates(modifierList) {
  var states = [];

  for (var index = 0; index < modifierList.length; index++) {
    var _modifierList$index = modifierList[index],
        options = _modifierList$index.options,
        methods = _modifierList$index.methods,
        name = _modifierList$index.name;

    if (options && options.enabled === false) {
      continue;
    }

    states.push({
      options: options,
      methods: methods,
      index: index,
      name: name
    });
  }

  return states;
}

function setCoords(arg) {
  var interaction = arg.interaction,
      phase = arg.phase;
  var curCoords = arg.curCoords || interaction.coords.cur;
  var startCoords = arg.startCoords || interaction.coords.start;
  var _interaction$modifier = interaction.modifiers,
      result = _interaction$modifier.result,
      startDelta = _interaction$modifier.startDelta;
  var curDelta = result.delta;

  if (phase === 'start') {
    (0, ___extend_30["default"])(interaction.modifiers.startDelta, result.delta);
  }

  var _arr = [[startCoords, startDelta], [curCoords, curDelta]];

  for (var _i5 = 0; _i5 < _arr.length; _i5++) {
    var _arr$_i = ___slicedToArray_30(_arr[_i5], 2),
        coordsSet = _arr$_i[0],
        delta = _arr$_i[1];

    coordsSet.page.x += delta.x;
    coordsSet.page.y += delta.y;
    coordsSet.client.x += delta.x;
    coordsSet.client.y += delta.y;
  }

  var rectDelta = interaction.modifiers.result.rectDelta;
  var rect = arg.rect || interaction.rect;
  rect.left += rectDelta.left;
  rect.right += rectDelta.right;
  rect.top += rectDelta.top;
  rect.bottom += rectDelta.bottom;
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
}

function restoreCoords(_ref7) {
  var _ref7$interaction = _ref7.interaction,
      coords = _ref7$interaction.coords,
      rect = _ref7$interaction.rect,
      modifiers = _ref7$interaction.modifiers;

  if (!modifiers.result) {
    return;
  }

  var startDelta = modifiers.startDelta;
  var _modifiers$result = modifiers.result,
      curDelta = _modifiers$result.delta,
      rectDelta = _modifiers$result.rectDelta;
  var coordsAndDeltas = [[coords.start, startDelta], [coords.cur, curDelta]];

  for (var _i6 = 0; _i6 < coordsAndDeltas.length; _i6++) {
    var _coordsAndDeltas$_i = ___slicedToArray_30(coordsAndDeltas[_i6], 2),
        coordsSet = _coordsAndDeltas$_i[0],
        delta = _coordsAndDeltas$_i[1];

    coordsSet.page.x -= delta.x;
    coordsSet.page.y -= delta.y;
    coordsSet.client.x -= delta.x;
    coordsSet.client.y -= delta.y;
  }

  rect.left -= rectDelta.left;
  rect.right -= rectDelta.right;
  rect.top -= rectDelta.top;
  rect.bottom -= rectDelta.bottom;
}

function shouldDo(options, preEnd, requireEndOnly, phase) {
  return options ? options.enabled !== false && (preEnd || !options.endOnly) && (!requireEndOnly || options.endOnly || options.alwaysOnEnd) && (options.setStart || phase !== 'start') : !requireEndOnly;
}

function getRectOffset(rect, coords) {
  return rect ? {
    left: coords.x - rect.left,
    top: coords.y - rect.top,
    right: rect.right - coords.x,
    bottom: rect.bottom - coords.y
  } : {
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  };
}

function makeModifier(module, name) {
  var defaults = module.defaults;
  var methods = {
    start: module.start,
    set: module.set,
    beforeEnd: module.beforeEnd,
    stop: module.stop
  };

  var modifier = function modifier(_options) {
    var options = _options || {};
    options.enabled = options.enabled !== false; // add missing defaults to options

    for (var prop in defaults) {
      if (!(prop in options)) {
        options[prop] = defaults[prop];
      }
    }

    var m = {
      options: options,
      methods: methods,
      name: name
    };
    return m;
  };

  if (name && typeof name === 'string') {
    // for backwrads compatibility
    modifier._defaults = defaults;
    modifier._methods = methods;
  }

  return modifier;
}

var ___default_30 = {
  id: 'modifiers/base',
  install: __install_30,
  startAll: startAll,
  setAll: setAll,
  prepareStates: prepareStates,
  start: __start_30,
  beforeMove: __beforeMove_30,
  beforeEnd: beforeEnd,
  stop: stop,
  shouldDo: shouldDo,
  getModifierList: getModifierList,
  getRectOffset: getRectOffset,
  makeModifier: makeModifier
};
_$base_30["default"] = ___default_30;

var _$inertia_26 = {};
"use strict";

Object.defineProperty(_$inertia_26, "__esModule", {
  value: true
});
_$inertia_26["default"] = void 0;

/* removed: var _$InteractEvent_15 = require("@interactjs/core/InteractEvent"); */;

var ___base_26 = ___interopRequireDefault_26(_$base_30);

var __utils_26 = ___interopRequireWildcard_26(_$utils_56);

var ___raf_26 = ___interopRequireDefault_26(_$raf_62);

function ___interopRequireWildcard_26(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_26(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

_$InteractEvent_15.EventPhase.Resume = 'resume';
_$InteractEvent_15.EventPhase.InertiaStart = 'inertiastart';

function __install_26(scope) {
  var interactions = scope.interactions,
      defaults = scope.defaults;
  interactions.signals.on('new', function (_ref) {
    var interaction = _ref.interaction;
    interaction.inertia = {
      active: false,
      smoothEnd: false,
      allowResume: false,
      upCoords: {},
      timeout: null
    };
  }); // FIXME proper signal typing

  interactions.signals.on('before-action-end', function (arg) {
    return release(arg, scope);
  });
  interactions.signals.on('down', function (arg) {
    return resume(arg, scope);
  });
  interactions.signals.on('stop', function (arg) {
    return __stop_26(arg);
  });
  defaults.perAction.inertia = {
    enabled: false,
    resistance: 10,
    minSpeed: 100,
    endSpeed: 10,
    allowResume: true,
    smoothEndDuration: 300
  };
  scope.usePlugin(___base_26["default"]);
}

function resume(_ref2, scope) {
  var interaction = _ref2.interaction,
      event = _ref2.event,
      pointer = _ref2.pointer,
      eventTarget = _ref2.eventTarget;
  var state = interaction.inertia; // Check if the down event hits the current inertia target

  if (state.active) {
    var element = eventTarget; // climb up the DOM tree from the event target

    while (__utils_26.is.element(element)) {
      // if interaction element is the current inertia target element
      if (element === interaction.element) {
        // stop inertia
        ___raf_26["default"].cancel(state.timeout);

        state.active = false;
        interaction.simulation = null; // update pointers to the down event's coordinates

        interaction.updatePointer(pointer, event, eventTarget, true);
        __utils_26.pointer.setCoords(interaction.coords.cur, interaction.pointers.map(function (p) {
          return p.pointer;
        }), interaction._now()); // fire appropriate signals

        var signalArg = {
          interaction: interaction
        };
        scope.interactions.signals.fire('action-resume', signalArg); // fire a reume event

        var resumeEvent = new scope.InteractEvent(interaction, event, interaction.prepared.name, _$InteractEvent_15.EventPhase.Resume, interaction.element);

        interaction._fireEvent(resumeEvent);

        __utils_26.pointer.copyCoords(interaction.coords.prev, interaction.coords.cur);
        break;
      }

      element = __utils_26.dom.parentNode(element);
    }
  }
}

function release(_ref3, scope) {
  var interaction = _ref3.interaction,
      event = _ref3.event,
      noPreEnd = _ref3.noPreEnd;
  var state = interaction.inertia;

  if (!interaction.interacting() || interaction.simulation && interaction.simulation.active || noPreEnd) {
    return null;
  }

  var options = __getOptions_26(interaction);

  var now = interaction._now();

  var velocityClient = interaction.coords.velocity.client;
  var pointerSpeed = __utils_26.hypot(velocityClient.x, velocityClient.y);
  var smoothEnd = false;
  var modifierResult; // check if inertia should be started

  var inertiaPossible = options && options.enabled && interaction.prepared.name !== 'gesture' && event !== state.startEvent;
  var inertia = inertiaPossible && now - interaction.coords.cur.timeStamp < 50 && pointerSpeed > options.minSpeed && pointerSpeed > options.endSpeed;
  var modifierArg = {
    interaction: interaction,
    pageCoords: __utils_26.extend({}, interaction.coords.cur.page),
    states: inertiaPossible && interaction.modifiers.states.map(function (modifierStatus) {
      return __utils_26.extend({}, modifierStatus);
    }),
    preEnd: true,
    prevCoords: undefined,
    requireEndOnly: null
  }; // smoothEnd

  if (inertiaPossible && !inertia) {
    modifierArg.prevCoords = interaction.prevEvent.page;
    modifierArg.requireEndOnly = false;
    modifierResult = ___base_26["default"].setAll(modifierArg);

    if (modifierResult.changed) {
      smoothEnd = true;
    }
  }

  if (!(inertia || smoothEnd)) {
    return null;
  }

  __utils_26.pointer.copyCoords(state.upCoords, interaction.coords.cur);
  interaction.pointers[0].pointer = state.startEvent = new scope.InteractEvent(interaction, event, // FIXME add proper typing Action.name
  interaction.prepared.name, _$InteractEvent_15.EventPhase.InertiaStart, interaction.element);
  state.t0 = now;
  state.active = true;
  state.allowResume = options.allowResume;
  interaction.simulation = state;
  interaction.interactable.fire(state.startEvent);

  if (inertia) {
    state.vx0 = interaction.coords.velocity.client.x;
    state.vy0 = interaction.coords.velocity.client.y;
    state.v0 = pointerSpeed;
    calcInertia(interaction, state);
    __utils_26.extend(modifierArg.pageCoords, interaction.coords.cur.page);
    modifierArg.pageCoords.x += state.xe;
    modifierArg.pageCoords.y += state.ye;
    modifierArg.prevCoords = undefined;
    modifierArg.requireEndOnly = true;
    modifierResult = ___base_26["default"].setAll(modifierArg);
    state.modifiedXe += modifierResult.delta.x;
    state.modifiedYe += modifierResult.delta.y;
    state.timeout = ___raf_26["default"].request(function () {
      return inertiaTick(interaction);
    });
  } else {
    state.smoothEnd = true;
    state.xe = modifierResult.delta.x;
    state.ye = modifierResult.delta.y;
    state.sx = state.sy = 0;
    state.timeout = ___raf_26["default"].request(function () {
      return smothEndTick(interaction);
    });
  }

  return false;
}

function __stop_26(_ref4) {
  var interaction = _ref4.interaction;
  var state = interaction.inertia;

  if (state.active) {
    ___raf_26["default"].cancel(state.timeout);

    state.active = false;
    interaction.simulation = null;
  }
}

function calcInertia(interaction, state) {
  var options = __getOptions_26(interaction);
  var lambda = options.resistance;
  var inertiaDur = -Math.log(options.endSpeed / state.v0) / lambda;
  state.x0 = interaction.prevEvent.page.x;
  state.y0 = interaction.prevEvent.page.y;
  state.t0 = state.startEvent.timeStamp / 1000;
  state.sx = state.sy = 0;
  state.modifiedXe = state.xe = (state.vx0 - inertiaDur) / lambda;
  state.modifiedYe = state.ye = (state.vy0 - inertiaDur) / lambda;
  state.te = inertiaDur;
  state.lambda_v0 = lambda / state.v0;
  state.one_ve_v0 = 1 - options.endSpeed / state.v0;
}

function inertiaTick(interaction) {
  updateInertiaCoords(interaction);
  __utils_26.pointer.setCoordDeltas(interaction.coords.delta, interaction.coords.prev, interaction.coords.cur);
  __utils_26.pointer.setCoordVelocity(interaction.coords.velocity, interaction.coords.delta);
  var state = interaction.inertia;
  var options = __getOptions_26(interaction);
  var lambda = options.resistance;
  var t = interaction._now() / 1000 - state.t0;

  if (t < state.te) {
    var progress = 1 - (Math.exp(-lambda * t) - state.lambda_v0) / state.one_ve_v0;

    if (state.modifiedXe === state.xe && state.modifiedYe === state.ye) {
      state.sx = state.xe * progress;
      state.sy = state.ye * progress;
    } else {
      var quadPoint = __utils_26.getQuadraticCurvePoint(0, 0, state.xe, state.ye, state.modifiedXe, state.modifiedYe, progress);
      state.sx = quadPoint.x;
      state.sy = quadPoint.y;
    }

    interaction.move();
    state.timeout = ___raf_26["default"].request(function () {
      return inertiaTick(interaction);
    });
  } else {
    state.sx = state.modifiedXe;
    state.sy = state.modifiedYe;
    interaction.move();
    interaction.end(state.startEvent);
    state.active = false;
    interaction.simulation = null;
  }

  __utils_26.pointer.copyCoords(interaction.coords.prev, interaction.coords.cur);
}

function smothEndTick(interaction) {
  updateInertiaCoords(interaction);
  var state = interaction.inertia;
  var t = interaction._now() - state.t0;

  var _getOptions = __getOptions_26(interaction),
      duration = _getOptions.smoothEndDuration;

  if (t < duration) {
    state.sx = __utils_26.easeOutQuad(t, 0, state.xe, duration);
    state.sy = __utils_26.easeOutQuad(t, 0, state.ye, duration);
    interaction.move();
    state.timeout = ___raf_26["default"].request(function () {
      return smothEndTick(interaction);
    });
  } else {
    state.sx = state.xe;
    state.sy = state.ye;
    interaction.move();
    interaction.end(state.startEvent);
    state.smoothEnd = state.active = false;
    interaction.simulation = null;
  }
}

function updateInertiaCoords(interaction) {
  var state = interaction.inertia; // return if inertia isn't running

  if (!state.active) {
    return;
  }

  var pageUp = state.upCoords.page;
  var clientUp = state.upCoords.client;
  __utils_26.pointer.setCoords(interaction.coords.cur, [{
    pageX: pageUp.x + state.sx,
    pageY: pageUp.y + state.sy,
    clientX: clientUp.x + state.sx,
    clientY: clientUp.y + state.sy
  }], interaction._now());
}

function __getOptions_26(_ref5) {
  var interactable = _ref5.interactable,
      prepared = _ref5.prepared;
  return interactable && interactable.options && prepared.name && interactable.options[prepared.name].inertia;
}

var ___default_26 = {
  id: 'inertia',
  install: __install_26,
  calcInertia: calcInertia,
  inertiaTick: inertiaTick,
  smothEndTick: smothEndTick,
  updateInertiaCoords: updateInertiaCoords
};
_$inertia_26["default"] = ___default_26;

var _$pointer_33 = {};
"use strict";

Object.defineProperty(_$pointer_33, "__esModule", {
  value: true
});
_$pointer_33["default"] = void 0;

var ___extend_33 = ___interopRequireDefault_33(_$extend_53);

var __is_33 = ___interopRequireWildcard_33(_$is_57);

var ___rect_33 = ___interopRequireDefault_33(_$rect_63);

function ___interopRequireWildcard_33(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_33(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function __start_33(_ref) {
  var rect = _ref.rect,
      startOffset = _ref.startOffset,
      state = _ref.state,
      interaction = _ref.interaction,
      pageCoords = _ref.pageCoords;
  var options = state.options;
  var elementRect = options.elementRect;
  var offset = (0, ___extend_33["default"])({
    left: 0,
    top: 0,
    right: 0,
    bottom: 0
  }, options.offset || {});

  if (rect && elementRect) {
    var restriction = getRestrictionRect(options.restriction, interaction, pageCoords);

    if (restriction) {
      var widthDiff = restriction.right - restriction.left - rect.width;
      var heightDiff = restriction.bottom - restriction.top - rect.height;

      if (widthDiff < 0) {
        offset.left += widthDiff;
        offset.right += widthDiff;
      }

      if (heightDiff < 0) {
        offset.top += heightDiff;
        offset.bottom += heightDiff;
      }
    }

    offset.left += startOffset.left - rect.width * elementRect.left;
    offset.top += startOffset.top - rect.height * elementRect.top;
    offset.right += startOffset.right - rect.width * (1 - elementRect.right);
    offset.bottom += startOffset.bottom - rect.height * (1 - elementRect.bottom);
  }

  state.offset = offset;
}

function set(_ref2) {
  var coords = _ref2.coords,
      interaction = _ref2.interaction,
      state = _ref2.state;
  var options = state.options,
      offset = state.offset;
  var restriction = getRestrictionRect(options.restriction, interaction, coords);

  if (!restriction) {
    return;
  }

  var rect = ___rect_33["default"].xywhToTlbr(restriction);

  coords.x = Math.max(Math.min(rect.right - offset.right, coords.x), rect.left + offset.left);
  coords.y = Math.max(Math.min(rect.bottom - offset.bottom, coords.y), rect.top + offset.top);
}

function getRestrictionRect(value, interaction, coords) {
  if (__is_33.func(value)) {
    return ___rect_33["default"].resolveRectLike(value, interaction.interactable, interaction.element, [coords.x, coords.y, interaction]);
  } else {
    return ___rect_33["default"].resolveRectLike(value, interaction.interactable, interaction.element);
  }
}

var __defaults_33 = {
  restriction: null,
  elementRect: null,
  offset: null,
  endOnly: false,
  enabled: false
};
var restrict = {
  start: __start_33,
  set: set,
  getRestrictionRect: getRestrictionRect,
  defaults: __defaults_33
};
var ___default_33 = restrict;
_$pointer_33["default"] = ___default_33;

var _$edges_32 = {};
"use strict";

Object.defineProperty(_$edges_32, "__esModule", {
  value: true
});
_$edges_32["default"] = void 0;

var ___extend_32 = ___interopRequireDefault_32(_$extend_53);

var ___rect_32 = ___interopRequireDefault_32(_$rect_63);

var _pointer = ___interopRequireDefault_32(_$pointer_33);

function ___interopRequireDefault_32(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// This module adds the options.resize.restrictEdges setting which sets min and
// max for the top, left, bottom and right edges of the target being resized.
//
// interact(target).resize({
//   edges: { top: true, left: true },
//   restrictEdges: {
//     inner: { top: 200, left: 200, right: 400, bottom: 400 },
//     outer: { top:   0, left:   0, right: 600, bottom: 600 },
//   },
// })
var __getRestrictionRect_32 = _pointer["default"].getRestrictionRect;
var noInner = {
  top: +Infinity,
  left: +Infinity,
  bottom: -Infinity,
  right: -Infinity
};
var noOuter = {
  top: -Infinity,
  left: -Infinity,
  bottom: +Infinity,
  right: +Infinity
};

function __start_32(_ref) {
  var interaction = _ref.interaction,
      state = _ref.state;
  var options = state.options;
  var startOffset = interaction.modifiers.startOffset;
  var offset;

  if (options) {
    var offsetRect = __getRestrictionRect_32(options.offset, interaction, interaction.coords.start.page);
    offset = ___rect_32["default"].rectToXY(offsetRect);
  }

  offset = offset || {
    x: 0,
    y: 0
  };
  state.offset = {
    top: offset.y + startOffset.top,
    left: offset.x + startOffset.left,
    bottom: offset.y - startOffset.bottom,
    right: offset.x - startOffset.right
  };
}

function __set_32(_ref2) {
  var coords = _ref2.coords,
      interaction = _ref2.interaction,
      state = _ref2.state;
  var offset = state.offset,
      options = state.options;
  var edges = interaction.prepared._linkedEdges || interaction.prepared.edges;

  if (!edges) {
    return;
  }

  var page = (0, ___extend_32["default"])({}, coords);
  var inner = __getRestrictionRect_32(options.inner, interaction, page) || {};
  var outer = __getRestrictionRect_32(options.outer, interaction, page) || {};
  fixRect(inner, noInner);
  fixRect(outer, noOuter);

  if (edges.top) {
    coords.y = Math.min(Math.max(outer.top + offset.top, page.y), inner.top + offset.top);
  } else if (edges.bottom) {
    coords.y = Math.max(Math.min(outer.bottom + offset.bottom, page.y), inner.bottom + offset.bottom);
  }

  if (edges.left) {
    coords.x = Math.min(Math.max(outer.left + offset.left, page.x), inner.left + offset.left);
  } else if (edges.right) {
    coords.x = Math.max(Math.min(outer.right + offset.right, page.x), inner.right + offset.right);
  }
}

function fixRect(rect, defaults) {
  var _arr = ['top', 'left', 'bottom', 'right'];

  for (var _i = 0; _i < _arr.length; _i++) {
    var edge = _arr[_i];

    if (!(edge in rect)) {
      rect[edge] = defaults[edge];
    }
  }

  return rect;
}

var __defaults_32 = {
  inner: null,
  outer: null,
  offset: null,
  endOnly: false,
  enabled: false
};
var restrictEdges = {
  noInner: noInner,
  noOuter: noOuter,
  getRestrictionRect: __getRestrictionRect_32,
  start: __start_32,
  set: __set_32,
  defaults: __defaults_32
};
var ___default_32 = restrictEdges;
_$edges_32["default"] = ___default_32;

var _$rect_34 = {};
"use strict";

Object.defineProperty(_$rect_34, "__esModule", {
  value: true
});
_$rect_34["default"] = void 0;

var ___extend_34 = ___interopRequireDefault_34(_$extend_53);

var ___pointer_34 = ___interopRequireDefault_34(_$pointer_33);

function ___interopRequireDefault_34(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var __defaults_34 = (0, ___extend_34["default"])({
  get elementRect() {
    return {
      top: 0,
      left: 0,
      bottom: 1,
      right: 1
    };
  },

  set elementRect(_) {}

}, ___pointer_34["default"].defaults);
var restrictRect = {
  start: ___pointer_34["default"].start,
  set: ___pointer_34["default"].set,
  defaults: __defaults_34
};
var ___default_34 = restrictRect;
_$rect_34["default"] = ___default_34;

var _$size_35 = {};
"use strict";

Object.defineProperty(_$size_35, "__esModule", {
  value: true
});
_$size_35["default"] = void 0;

var ___extend_35 = ___interopRequireDefault_35(_$extend_53);

var ___rect_35 = ___interopRequireDefault_35(_$rect_63);

var _edges = ___interopRequireDefault_35(_$edges_32);

function ___interopRequireDefault_35(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var noMin = {
  width: -Infinity,
  height: -Infinity
};
var noMax = {
  width: +Infinity,
  height: +Infinity
};

function __start_35(arg) {
  return _edges["default"].start(arg);
}

function __set_35(arg) {
  var interaction = arg.interaction,
      state = arg.state;
  var options = state.options;
  var edges = interaction.prepared._linkedEdges || interaction.prepared.edges;

  if (!edges) {
    return;
  }

  var rect = ___rect_35["default"].xywhToTlbr(interaction.resizeRects.inverted);

  var minSize = ___rect_35["default"].tlbrToXywh(_edges["default"].getRestrictionRect(options.min, interaction, arg.coords)) || noMin;
  var maxSize = ___rect_35["default"].tlbrToXywh(_edges["default"].getRestrictionRect(options.max, interaction, arg.coords)) || noMax;
  state.options = {
    endOnly: options.endOnly,
    inner: (0, ___extend_35["default"])({}, _edges["default"].noInner),
    outer: (0, ___extend_35["default"])({}, _edges["default"].noOuter)
  };

  if (edges.top) {
    state.options.inner.top = rect.bottom - minSize.height;
    state.options.outer.top = rect.bottom - maxSize.height;
  } else if (edges.bottom) {
    state.options.inner.bottom = rect.top + minSize.height;
    state.options.outer.bottom = rect.top + maxSize.height;
  }

  if (edges.left) {
    state.options.inner.left = rect.right - minSize.width;
    state.options.outer.left = rect.right - maxSize.width;
  } else if (edges.right) {
    state.options.inner.right = rect.left + minSize.width;
    state.options.outer.right = rect.left + maxSize.width;
  }

  _edges["default"].set(arg);

  state.options = options;
}

var __defaults_35 = {
  min: null,
  max: null,
  endOnly: false,
  enabled: false
};
var restrictSize = {
  start: __start_35,
  set: __set_35,
  defaults: __defaults_35
};
var ___default_35 = restrictSize;
_$size_35["default"] = ___default_35;

var _$pointer_37 = {};
"use strict";

Object.defineProperty(_$pointer_37, "__esModule", {
  value: true
});
_$pointer_37["default"] = void 0;

var __utils_37 = ___interopRequireWildcard_37(_$utils_56);

function ___interopRequireWildcard_37(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function __start_37(arg) {
  var interaction = arg.interaction,
      interactable = arg.interactable,
      element = arg.element,
      rect = arg.rect,
      state = arg.state,
      startOffset = arg.startOffset;
  var options = state.options;
  var offsets = [];
  var origin = options.offsetWithOrigin ? getOrigin(arg) : {
    x: 0,
    y: 0
  };
  var snapOffset;

  if (options.offset === 'startCoords') {
    snapOffset = {
      x: interaction.coords.start.page.x,
      y: interaction.coords.start.page.y
    };
  } else {
    var offsetRect = __utils_37.rect.resolveRectLike(options.offset, interactable, element, [interaction]);
    snapOffset = __utils_37.rect.rectToXY(offsetRect) || {
      x: 0,
      y: 0
    };
    snapOffset.x += origin.x;
    snapOffset.y += origin.y;
  }

  var relativePoints = options.relativePoints || [];

  if (rect && options.relativePoints && options.relativePoints.length) {
    for (var index = 0; index < relativePoints.length; index++) {
      var relativePoint = relativePoints[index];
      offsets.push({
        index: index,
        relativePoint: relativePoint,
        x: startOffset.left - rect.width * relativePoint.x + snapOffset.x,
        y: startOffset.top - rect.height * relativePoint.y + snapOffset.y
      });
    }
  } else {
    offsets.push(__utils_37.extend({
      index: 0,
      relativePoint: null
    }, snapOffset));
  }

  state.offsets = offsets;
}

function __set_37(arg) {
  var interaction = arg.interaction,
      coords = arg.coords,
      state = arg.state;
  var options = state.options,
      offsets = state.offsets;
  var origin = __utils_37.getOriginXY(interaction.interactable, interaction.element, interaction.prepared.name);
  var page = __utils_37.extend({}, coords);
  var targets = [];
  var target;

  if (!options.offsetWithOrigin) {
    page.x -= origin.x;
    page.y -= origin.y;
  }

  state.realX = page.x;
  state.realY = page.y;

  for (var _i = 0; _i < offsets.length; _i++) {
    var _ref;

    _ref = offsets[_i];
    var offset = _ref;
    var relativeX = page.x - offset.x;
    var relativeY = page.y - offset.y;

    for (var index = 0, _len = options.targets.length; index < _len; index++) {
      var snapTarget = options.targets[index];

      if (__utils_37.is.func(snapTarget)) {
        target = snapTarget(relativeX, relativeY, interaction, offset, index);
      } else {
        target = snapTarget;
      }

      if (!target) {
        continue;
      }

      targets.push({
        x: (__utils_37.is.number(target.x) ? target.x : relativeX) + offset.x,
        y: (__utils_37.is.number(target.y) ? target.y : relativeY) + offset.y,
        range: __utils_37.is.number(target.range) ? target.range : options.range
      });
    }
  }

  var closest = {
    target: null,
    inRange: false,
    distance: 0,
    range: 0,
    dx: 0,
    dy: 0
  };

  for (var i = 0, len = targets.length; i < len; i++) {
    target = targets[i];
    var range = target.range;
    var dx = target.x - page.x;
    var dy = target.y - page.y;
    var distance = __utils_37.hypot(dx, dy);
    var inRange = distance <= range; // Infinite targets count as being out of range
    // compared to non infinite ones that are in range

    if (range === Infinity && closest.inRange && closest.range !== Infinity) {
      inRange = false;
    }

    if (!closest.target || (inRange // is the closest target in range?
    ? closest.inRange && range !== Infinity // the pointer is relatively deeper in this target
    ? distance / range < closest.distance / closest.range // this target has Infinite range and the closest doesn't
    : range === Infinity && closest.range !== Infinity || // OR this target is closer that the previous closest
    distance < closest.distance : // The other is not in range and the pointer is closer to this target
    !closest.inRange && distance < closest.distance)) {
      closest.target = target;
      closest.distance = distance;
      closest.range = range;
      closest.inRange = inRange;
      closest.dx = dx;
      closest.dy = dy;
      state.range = range;
    }
  }

  if (closest.inRange) {
    coords.x = closest.target.x;
    coords.y = closest.target.y;
  }

  state.closest = closest;
}

function getOrigin(arg) {
  var optionsOrigin = __utils_37.rect.rectToXY(__utils_37.rect.resolveRectLike(arg.state.options.origin, [arg.interaction.element]));
  var origin = optionsOrigin || __utils_37.getOriginXY(arg.interactable, arg.interaction.element, arg.interaction.prepared.name);
  return origin;
}

var __defaults_37 = {
  range: Infinity,
  targets: null,
  offset: null,
  offsetWithOrigin: true,
  origin: null,
  relativePoints: null,
  endOnly: false,
  enabled: false
};
var snap = {
  start: __start_37,
  set: __set_37,
  defaults: __defaults_37
};
var ___default_37 = snap;
_$pointer_37["default"] = ___default_37;

var _$size_38 = {};
"use strict";

Object.defineProperty(_$size_38, "__esModule", {
  value: true
});
_$size_38["default"] = void 0;

var ___extend_38 = ___interopRequireDefault_38(_$extend_53);

var __is_38 = ___interopRequireWildcard_38(_$is_57);

var ___pointer_38 = ___interopRequireDefault_38(_$pointer_37);

function ___interopRequireWildcard_38(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___interopRequireDefault_38(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___slicedToArray_38(arr, i) { return ___arrayWithHoles_38(arr) || ___iterableToArrayLimit_38(arr, i) || ___nonIterableRest_38(); }

function ___nonIterableRest_38() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function ___iterableToArrayLimit_38(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function ___arrayWithHoles_38(arr) { if (Array.isArray(arr)) return arr; }

function __start_38(arg) {
  var interaction = arg.interaction,
      state = arg.state;
  var options = state.options;
  var edges = interaction.prepared.edges;

  if (!edges) {
    return null;
  }

  arg.state = {
    options: {
      targets: null,
      relativePoints: [{
        x: edges.left ? 0 : 1,
        y: edges.top ? 0 : 1
      }],
      offset: options.offset || 'self',
      origin: {
        x: 0,
        y: 0
      },
      range: options.range
    }
  };
  state.targetFields = state.targetFields || [['width', 'height'], ['x', 'y']];

  ___pointer_38["default"].start(arg);

  state.offsets = arg.state.offsets;
  arg.state = state;
}

function __set_38(arg) {
  var interaction = arg.interaction,
      state = arg.state,
      coords = arg.coords;
  var options = state.options,
      offsets = state.offsets;
  var relative = {
    x: coords.x - offsets[0].x,
    y: coords.y - offsets[0].y
  };
  state.options = (0, ___extend_38["default"])({}, options);
  state.options.targets = [];

  for (var _i = 0; _i < (options.targets || []).length; _i++) {
    var _ref;

    _ref = (options.targets || [])[_i];
    var snapTarget = _ref;
    var target = void 0;

    if (__is_38.func(snapTarget)) {
      target = snapTarget(relative.x, relative.y, interaction);
    } else {
      target = snapTarget;
    }

    if (!target) {
      continue;
    }

    for (var _i2 = 0; _i2 < state.targetFields.length; _i2++) {
      var _ref2;

      _ref2 = state.targetFields[_i2];

      var _ref3 = _ref2,
          _ref4 = ___slicedToArray_38(_ref3, 2),
          xField = _ref4[0],
          yField = _ref4[1];

      if (xField in target || yField in target) {
        target.x = target[xField];
        target.y = target[yField];
        break;
      }
    }

    state.options.targets.push(target);
  }

  ___pointer_38["default"].set(arg);

  state.options = options;
}

var __defaults_38 = {
  range: Infinity,
  targets: null,
  offset: null,
  endOnly: false,
  enabled: false
};
var snapSize = {
  start: __start_38,
  set: __set_38,
  defaults: __defaults_38
};
var ___default_38 = snapSize;
_$size_38["default"] = ___default_38;

var _$edges_36 = {};
"use strict";

Object.defineProperty(_$edges_36, "__esModule", {
  value: true
});
_$edges_36["default"] = void 0;

var ___clone_36 = ___interopRequireDefault_36(_$clone_49);

var ___extend_36 = ___interopRequireDefault_36(_$extend_53);

var _size = ___interopRequireDefault_36(_$size_38);

function ___interopRequireDefault_36(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @module modifiers/snapEdges
 *
 * @description
 * This module allows snapping of the edges of targets during resize
 * interactions.
 *
 * @example
 * interact(target).resizable({
 *   snapEdges: {
 *     targets: [interact.snappers.grid({ x: 100, y: 50 })],
 *   },
 * })
 *
 * interact(target).resizable({
 *   snapEdges: {
 *     targets: [
 *       interact.snappers.grid({
 *        top: 50,
 *        left: 50,
 *        bottom: 100,
 *        right: 100,
 *       }),
 *     ],
 *   },
 * })
 */
function __start_36(arg) {
  var edges = arg.interaction.prepared.edges;

  if (!edges) {
    return null;
  }

  arg.state.targetFields = arg.state.targetFields || [[edges.left ? 'left' : 'right', edges.top ? 'top' : 'bottom']];
  return _size["default"].start(arg);
}

function __set_36(arg) {
  return _size["default"].set(arg);
}

var snapEdges = {
  start: __start_36,
  set: __set_36,
  defaults: (0, ___extend_36["default"])((0, ___clone_36["default"])(_size["default"].defaults), {
    offset: {
      x: 0,
      y: 0
    }
  })
};
var ___default_36 = snapEdges;
_$edges_36["default"] = ___default_36;

var _$modifiers_31 = {};
"use strict";

Object.defineProperty(_$modifiers_31, "__esModule", {
  value: true
});
_$modifiers_31.restrictSize = _$modifiers_31.restrictEdges = _$modifiers_31.restrictRect = _$modifiers_31.restrict = _$modifiers_31.snapEdges = _$modifiers_31.snapSize = _$modifiers_31.snap = void 0;

var ___base_31 = ___interopRequireDefault_31(_$base_30);

var ___edges_31 = ___interopRequireDefault_31(_$edges_32);

var ___pointer_31 = ___interopRequireDefault_31(_$pointer_33);

var ___rect_31 = ___interopRequireDefault_31(_$rect_34);

var ___size_31 = ___interopRequireDefault_31(_$size_35);

var _edges2 = ___interopRequireDefault_31(_$edges_36);

var _pointer2 = ___interopRequireDefault_31(_$pointer_37);

var _size2 = ___interopRequireDefault_31(_$size_38);

function ___interopRequireDefault_31(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var __makeModifier_31 = ___base_31["default"].makeModifier;
var __snap_31 = __makeModifier_31(_pointer2["default"], 'snap');
_$modifiers_31.snap = __snap_31;
var __snapSize_31 = __makeModifier_31(_size2["default"], 'snapSize');
_$modifiers_31.snapSize = __snapSize_31;
var __snapEdges_31 = __makeModifier_31(_edges2["default"], 'snapEdges');
_$modifiers_31.snapEdges = __snapEdges_31;
var __restrict_31 = __makeModifier_31(___pointer_31["default"], 'restrict');
_$modifiers_31.restrict = __restrict_31;
var __restrictRect_31 = __makeModifier_31(___rect_31["default"], 'restrictRect');
_$modifiers_31.restrictRect = __restrictRect_31;
var __restrictEdges_31 = __makeModifier_31(___edges_31["default"], 'restrictEdges');
_$modifiers_31.restrictEdges = __restrictEdges_31;
var __restrictSize_31 = __makeModifier_31(___size_31["default"], 'restrictSize');
_$modifiers_31.restrictSize = __restrictSize_31;

var _$PointerEvent_39 = {};
"use strict";

Object.defineProperty(_$PointerEvent_39, "__esModule", {
  value: true
});
_$PointerEvent_39["default"] = void 0;

var ___BaseEvent2_39 = ___interopRequireDefault_39(_$BaseEvent_13);

var ___pointerUtils_39 = ___interopRequireDefault_39(_$pointerUtils_61);

function ___interopRequireDefault_39(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___typeof_39(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ___typeof_39 = function _typeof(obj) { return typeof obj; }; } else { ___typeof_39 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ___typeof_39(obj); }

function ___classCallCheck_39(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ___defineProperties_39(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ___createClass_39(Constructor, protoProps, staticProps) { if (protoProps) ___defineProperties_39(Constructor.prototype, protoProps); if (staticProps) ___defineProperties_39(Constructor, staticProps); return Constructor; }

function ___possibleConstructorReturn_39(self, call) { if (call && (___typeof_39(call) === "object" || typeof call === "function")) { return call; } return ___assertThisInitialized_39(self); }

function ___getPrototypeOf_39(o) { ___getPrototypeOf_39 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ___getPrototypeOf_39(o); }

function ___assertThisInitialized_39(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function ___inherits_39(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) ___setPrototypeOf_39(subClass, superClass); }

function ___setPrototypeOf_39(o, p) { ___setPrototypeOf_39 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ___setPrototypeOf_39(o, p); }

/** */
var PointerEvent =
/*#__PURE__*/
function (_BaseEvent) {
  ___inherits_39(PointerEvent, _BaseEvent);

  /** */
  function PointerEvent(type, pointer, event, eventTarget, interaction, timeStamp) {
    var _this;

    ___classCallCheck_39(this, PointerEvent);

    _this = ___possibleConstructorReturn_39(this, ___getPrototypeOf_39(PointerEvent).call(this, interaction));

    ___pointerUtils_39["default"].pointerExtend(___assertThisInitialized_39(_this), event);

    if (event !== pointer) {
      ___pointerUtils_39["default"].pointerExtend(___assertThisInitialized_39(_this), pointer);
    }

    _this.timeStamp = timeStamp;
    _this.originalEvent = event;
    _this.type = type;
    _this.pointerId = ___pointerUtils_39["default"].getPointerId(pointer);
    _this.pointerType = ___pointerUtils_39["default"].getPointerType(pointer);
    _this.target = eventTarget;
    _this.currentTarget = null;

    if (type === 'tap') {
      var pointerIndex = interaction.getPointerIndex(pointer);
      _this.dt = _this.timeStamp - interaction.pointers[pointerIndex].downTime;
      var interval = _this.timeStamp - interaction.tapTime;
      _this["double"] = !!(interaction.prevTap && interaction.prevTap.type !== 'doubletap' && interaction.prevTap.target === _this.target && interval < 500);
    } else if (type === 'doubletap') {
      _this.dt = pointer.timeStamp - interaction.tapTime;
    }

    return _this;
  }

  ___createClass_39(PointerEvent, [{
    key: "_subtractOrigin",
    value: function _subtractOrigin(_ref) {
      var originX = _ref.x,
          originY = _ref.y;
      this.pageX -= originX;
      this.pageY -= originY;
      this.clientX -= originX;
      this.clientY -= originY;
      return this;
    }
  }, {
    key: "_addOrigin",
    value: function _addOrigin(_ref2) {
      var originX = _ref2.x,
          originY = _ref2.y;
      this.pageX += originX;
      this.pageY += originY;
      this.clientX += originX;
      this.clientY += originY;
      return this;
    }
    /**
     * Prevent the default behaviour of the original Event
     */

  }, {
    key: "preventDefault",
    value: function preventDefault() {
      this.originalEvent.preventDefault();
    }
  }]);

  return PointerEvent;
}(___BaseEvent2_39["default"]);

_$PointerEvent_39["default"] = PointerEvent;

var _$base_40 = {};
"use strict";

Object.defineProperty(_$base_40, "__esModule", {
  value: true
});
_$base_40["default"] = void 0;

var __utils_40 = ___interopRequireWildcard_40(_$utils_56);

var _PointerEvent = ___interopRequireDefault_40(_$PointerEvent_39);

function ___interopRequireDefault_40(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_40(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

var signals = new __utils_40.Signals();
var simpleSignals = ['down', 'up', 'cancel'];
var simpleEvents = ['down', 'up', 'cancel'];
var __defaults_40 = {
  holdDuration: 600,
  ignoreFrom: null,
  allowFrom: null,
  origin: {
    x: 0,
    y: 0
  }
};
var pointerEvents = {
  id: 'pointer-events/base',
  install: __install_40,
  signals: signals,
  PointerEvent: _PointerEvent["default"],
  fire: fire,
  collectEventTargets: collectEventTargets,
  createSignalListener: createSignalListener,
  defaults: __defaults_40,
  types: ['down', 'move', 'up', 'cancel', 'tap', 'doubletap', 'hold']
};

function fire(arg, scope) {
  var interaction = arg.interaction,
      pointer = arg.pointer,
      event = arg.event,
      eventTarget = arg.eventTarget,
      _arg$type = arg.type,
      type = _arg$type === void 0 ? arg.pointerEvent.type : _arg$type,
      _arg$targets = arg.targets,
      targets = _arg$targets === void 0 ? collectEventTargets(arg) : _arg$targets;
  var _arg$pointerEvent = arg.pointerEvent,
      pointerEvent = _arg$pointerEvent === void 0 ? new _PointerEvent["default"](type, pointer, event, eventTarget, interaction, scope.now()) : _arg$pointerEvent;
  var signalArg = {
    interaction: interaction,
    pointer: pointer,
    event: event,
    eventTarget: eventTarget,
    targets: targets,
    type: type,
    pointerEvent: pointerEvent
  };

  for (var i = 0; i < targets.length; i++) {
    var target = targets[i];

    for (var prop in target.props || {}) {
      pointerEvent[prop] = target.props[prop];
    }

    var origin = __utils_40.getOriginXY(target.eventable, target.node);

    pointerEvent._subtractOrigin(origin);

    pointerEvent.eventable = target.eventable;
    pointerEvent.currentTarget = target.node;
    target.eventable.fire(pointerEvent);

    pointerEvent._addOrigin(origin);

    if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && i + 1 < targets.length && targets[i + 1].node !== pointerEvent.currentTarget) {
      break;
    }
  }

  signals.fire('fired', signalArg);

  if (type === 'tap') {
    // if pointerEvent should make a double tap, create and fire a doubletap
    // PointerEvent and use that as the prevTap
    var prevTap = pointerEvent["double"] ? fire({
      interaction: interaction,
      pointer: pointer,
      event: event,
      eventTarget: eventTarget,
      type: 'doubletap'
    }, scope) : pointerEvent;
    interaction.prevTap = prevTap;
    interaction.tapTime = prevTap.timeStamp;
  }

  return pointerEvent;
}

function collectEventTargets(_ref) {
  var interaction = _ref.interaction,
      pointer = _ref.pointer,
      event = _ref.event,
      eventTarget = _ref.eventTarget,
      type = _ref.type;
  var pointerIndex = interaction.getPointerIndex(pointer);
  var pointerInfo = interaction.pointers[pointerIndex]; // do not fire a tap event if the pointer was moved before being lifted

  if (type === 'tap' && (interaction.pointerWasMoved || // or if the pointerup target is different to the pointerdown target
  !(pointerInfo && pointerInfo.downTarget === eventTarget))) {
    return [];
  }

  var path = __utils_40.dom.getPath(eventTarget);
  var signalArg = {
    interaction: interaction,
    pointer: pointer,
    event: event,
    eventTarget: eventTarget,
    type: type,
    path: path,
    targets: [],
    node: null
  };

  for (var _i = 0; _i < path.length; _i++) {
    var _ref2;

    _ref2 = path[_i];
    var node = _ref2;
    signalArg.node = node;
    signals.fire('collect-targets', signalArg);
  }

  if (type === 'hold') {
    signalArg.targets = signalArg.targets.filter(function (target) {
      return target.eventable.options.holdDuration === interaction.pointers[pointerIndex].hold.duration;
    });
  }

  return signalArg.targets;
}

function __install_40(scope) {
  var interactions = scope.interactions;
  scope.pointerEvents = pointerEvents;
  scope.defaults.actions.pointerEvents = pointerEvents.defaults;
  interactions.signals.on('new', function (_ref3) {
    var interaction = _ref3.interaction;
    interaction.prevTap = null; // the most recent tap event on this interaction

    interaction.tapTime = 0; // time of the most recent tap event
  });
  interactions.signals.on('update-pointer', function (_ref4) {
    var down = _ref4.down,
        pointerInfo = _ref4.pointerInfo;

    if (!down && pointerInfo.hold) {
      return;
    }

    pointerInfo.hold = {
      duration: Infinity,
      timeout: null
    };
  });
  interactions.signals.on('move', function (_ref5) {
    var interaction = _ref5.interaction,
        pointer = _ref5.pointer,
        event = _ref5.event,
        eventTarget = _ref5.eventTarget,
        duplicateMove = _ref5.duplicateMove;
    var pointerIndex = interaction.getPointerIndex(pointer);

    if (!duplicateMove && (!interaction.pointerIsDown || interaction.pointerWasMoved)) {
      if (interaction.pointerIsDown) {
        clearTimeout(interaction.pointers[pointerIndex].hold.timeout);
      }

      fire({
        interaction: interaction,
        pointer: pointer,
        event: event,
        eventTarget: eventTarget,
        type: 'move'
      }, scope);
    }
  });
  interactions.signals.on('down', function (_ref6) {
    var interaction = _ref6.interaction,
        pointer = _ref6.pointer,
        event = _ref6.event,
        eventTarget = _ref6.eventTarget,
        pointerIndex = _ref6.pointerIndex;
    var timer = interaction.pointers[pointerIndex].hold;
    var path = __utils_40.dom.getPath(eventTarget);
    var signalArg = {
      interaction: interaction,
      pointer: pointer,
      event: event,
      eventTarget: eventTarget,
      type: 'hold',
      targets: [],
      path: path,
      node: null
    };

    for (var _i2 = 0; _i2 < path.length; _i2++) {
      var _ref7;

      _ref7 = path[_i2];
      var node = _ref7;
      signalArg.node = node;
      signals.fire('collect-targets', signalArg);
    }

    if (!signalArg.targets.length) {
      return;
    }

    var minDuration = Infinity;

    for (var _i3 = 0; _i3 < signalArg.targets.length; _i3++) {
      var _ref8;

      _ref8 = signalArg.targets[_i3];
      var target = _ref8;
      var holdDuration = target.eventable.options.holdDuration;

      if (holdDuration < minDuration) {
        minDuration = holdDuration;
      }
    }

    timer.duration = minDuration;
    timer.timeout = setTimeout(function () {
      fire({
        interaction: interaction,
        eventTarget: eventTarget,
        pointer: pointer,
        event: event,
        type: 'hold'
      }, scope);
    }, minDuration);
  });
  var _arr = ['up', 'cancel'];

  for (var _i4 = 0; _i4 < _arr.length; _i4++) {
    var signalName = _arr[_i4];
    interactions.signals.on(signalName, function (_ref10) {
      var interaction = _ref10.interaction,
          pointerIndex = _ref10.pointerIndex;

      if (interaction.pointers[pointerIndex].hold) {
        clearTimeout(interaction.pointers[pointerIndex].hold.timeout);
      }
    });
  }

  for (var i = 0; i < simpleSignals.length; i++) {
    interactions.signals.on(simpleSignals[i], createSignalListener(simpleEvents[i], scope));
  }

  interactions.signals.on('up', function (_ref9) {
    var interaction = _ref9.interaction,
        pointer = _ref9.pointer,
        event = _ref9.event,
        eventTarget = _ref9.eventTarget;

    if (!interaction.pointerWasMoved) {
      fire({
        interaction: interaction,
        eventTarget: eventTarget,
        pointer: pointer,
        event: event,
        type: 'tap'
      }, scope);
    }
  });
}

function createSignalListener(type, scope) {
  return function (_ref11) {
    var interaction = _ref11.interaction,
        pointer = _ref11.pointer,
        event = _ref11.event,
        eventTarget = _ref11.eventTarget;
    fire({
      interaction: interaction,
      eventTarget: eventTarget,
      pointer: pointer,
      event: event,
      type: type
    }, scope);
  };
}

var ___default_40 = pointerEvents;
_$base_40["default"] = ___default_40;

var _$holdRepeat_41 = {};
"use strict";

Object.defineProperty(_$holdRepeat_41, "__esModule", {
  value: true
});
_$holdRepeat_41["default"] = void 0;

var ___base_41 = ___interopRequireDefault_41(_$base_40);

function ___interopRequireDefault_41(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function __install_41(scope) {
  var pointerEvents = scope.pointerEvents,
      interactions = scope.interactions;
  scope.usePlugin(___base_41["default"]);
  pointerEvents.signals.on('new', onNew);
  pointerEvents.signals.on('fired', function (arg) {
    return onFired(arg, scope);
  });
  var _arr = ['move', 'up', 'cancel', 'endall'];

  for (var _i = 0; _i < _arr.length; _i++) {
    var signal = _arr[_i];
    interactions.signals.on(signal, endHoldRepeat);
  } // don't repeat by default


  pointerEvents.defaults.holdRepeatInterval = 0;
  pointerEvents.types.push('holdrepeat');
}

function onNew(_ref) {
  var pointerEvent = _ref.pointerEvent;

  if (pointerEvent.type !== 'hold') {
    return;
  }

  pointerEvent.count = (pointerEvent.count || 0) + 1;
}

function onFired(_ref2, scope) {
  var interaction = _ref2.interaction,
      pointerEvent = _ref2.pointerEvent,
      eventTarget = _ref2.eventTarget,
      targets = _ref2.targets;

  if (pointerEvent.type !== 'hold' || !targets.length) {
    return;
  } // get the repeat interval from the first eventable


  var interval = targets[0].eventable.options.holdRepeatInterval; // don't repeat if the interval is 0 or less

  if (interval <= 0) {
    return;
  } // set a timeout to fire the holdrepeat event


  interaction.holdIntervalHandle = setTimeout(function () {
    scope.pointerEvents.fire({
      interaction: interaction,
      eventTarget: eventTarget,
      type: 'hold',
      pointer: pointerEvent,
      event: pointerEvent
    }, scope);
  }, interval);
}

function endHoldRepeat(_ref3) {
  var interaction = _ref3.interaction;

  // set the interaction's holdStopTime property
  // to stop further holdRepeat events
  if (interaction.holdIntervalHandle) {
    clearInterval(interaction.holdIntervalHandle);
    interaction.holdIntervalHandle = null;
  }
}

var ___default_41 = {
  id: 'pointer-events/holdRepeat',
  install: __install_41
};
_$holdRepeat_41["default"] = ___default_41;

var _$interactableTargets_43 = {};
"use strict";

Object.defineProperty(_$interactableTargets_43, "__esModule", {
  value: true
});
_$interactableTargets_43["default"] = void 0;

/* removed: var _$arr_47 = require("@interactjs/utils/arr"); */;

var ___extend_43 = ___interopRequireDefault_43(_$extend_53);

function ___interopRequireDefault_43(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function __install_43(scope) {
  var pointerEvents = scope.pointerEvents,
      actions = scope.actions,
      Interactable = scope.Interactable,
      interactables = scope.interactables;
  pointerEvents.signals.on('collect-targets', function (_ref) {
    var targets = _ref.targets,
        node = _ref.node,
        type = _ref.type,
        eventTarget = _ref.eventTarget;
    scope.interactables.forEachMatch(node, function (interactable) {
      var eventable = interactable.events;
      var options = eventable.options;

      if (eventable.types[type] && eventable.types[type].length && interactable.testIgnoreAllow(options, node, eventTarget)) {
        targets.push({
          node: node,
          eventable: eventable,
          props: {
            interactable: interactable
          }
        });
      }
    });
  });
  interactables.signals.on('new', function (_ref2) {
    var interactable = _ref2.interactable;

    interactable.events.getRect = function (element) {
      return interactable.getRect(element);
    };
  });
  interactables.signals.on('set', function (_ref3) {
    var interactable = _ref3.interactable,
        options = _ref3.options;
    (0, ___extend_43["default"])(interactable.events.options, pointerEvents.defaults);
    (0, ___extend_43["default"])(interactable.events.options, options.pointerEvents || {});
  });
  (0, _$arr_47.merge)(actions.eventTypes, pointerEvents.types);
  Interactable.prototype.pointerEvents = pointerEventsMethod;
  var __backCompatOption = Interactable.prototype._backCompatOption;

  Interactable.prototype._backCompatOption = function (optionName, newValue) {
    var ret = __backCompatOption.call(this, optionName, newValue);

    if (ret === this) {
      this.events.options[optionName] = newValue;
    }

    return ret;
  };
}

function pointerEventsMethod(options) {
  (0, ___extend_43["default"])(this.events.options, options);
  return this;
}

var ___default_43 = {
  id: 'pointer-events/interactableTargets',
  install: __install_43
};
_$interactableTargets_43["default"] = ___default_43;

var _$pointerEvents_42 = {};
"use strict";

Object.defineProperty(_$pointerEvents_42, "__esModule", {
  value: true
});
_$pointerEvents_42.install = __install_42;
Object.defineProperty(_$pointerEvents_42, "pointerEvents", {
  enumerable: true,
  get: function get() {
    return ___base_42["default"];
  }
});
Object.defineProperty(_$pointerEvents_42, "holdRepeat", {
  enumerable: true,
  get: function get() {
    return _holdRepeat["default"];
  }
});
Object.defineProperty(_$pointerEvents_42, "interactableTargets", {
  enumerable: true,
  get: function get() {
    return _interactableTargets["default"];
  }
});
_$pointerEvents_42.id = void 0;

var ___base_42 = ___interopRequireDefault_42(_$base_40);

var _holdRepeat = ___interopRequireDefault_42(_$holdRepeat_41);

var _interactableTargets = ___interopRequireDefault_42(_$interactableTargets_43);

function ___interopRequireDefault_42(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function __install_42(scope) {
  scope.usePlugin(___base_42["default"]);
  scope.usePlugin(_holdRepeat["default"]);
  scope.usePlugin(_interactableTargets["default"]);
}

var __id_42 = 'pointer-events';
_$pointerEvents_42.id = __id_42;

var _$reflow_44 = {};
"use strict";

Object.defineProperty(_$reflow_44, "__esModule", {
  value: true
});
_$reflow_44.install = __install_44;
_$reflow_44["default"] = void 0;

/* removed: var _$InteractEvent_15 = require("@interactjs/core/InteractEvent"); */;

/* removed: var _$utils_56 = require("@interactjs/utils"); */;

_$InteractEvent_15.EventPhase.Reflow = 'reflow';

function __install_44(scope) {
  var actions = scope.actions,
      interactions = scope.interactions,
      Interactable = scope.Interactable; // add action reflow event types

  for (var _i = 0; _i < actions.names.length; _i++) {
    var _ref;

    _ref = actions.names[_i];
    var actionName = _ref;
    actions.eventTypes.push("".concat(actionName, "reflow"));
  } // remove completed reflow interactions


  interactions.signals.on('stop', function (_ref2) {
    var interaction = _ref2.interaction;

    if (interaction.pointerType === _$InteractEvent_15.EventPhase.Reflow) {
      if (interaction._reflowResolve) {
        interaction._reflowResolve();
      }

      _$utils_56.arr.remove(scope.interactions.list, interaction);
    }
  });
  /**
   * ```js
   * const interactable = interact(target)
   * const drag = { name: drag, axis: 'x' }
   * const resize = { name: resize, edges: { left: true, bottom: true }
   *
   * interactable.reflow(drag)
   * interactable.reflow(resize)
   * ```
   *
   * Start an action sequence to re-apply modifiers, check drops, etc.
   *
   * @param { Object } action The action to begin
   * @param { string } action.name The name of the action
   * @returns { Promise<Interactable> }
   */

  Interactable.prototype.reflow = function (action) {
    return reflow(this, action, scope);
  };
}

function reflow(interactable, action, scope) {
  var elements = _$utils_56.is.string(interactable.target) ? _$utils_56.arr.from(interactable._context.querySelectorAll(interactable.target)) : [interactable.target]; // tslint:disable-next-line variable-name

  var Promise = _$utils_56.win.window.Promise;
  var promises = Promise ? [] : null;

  var _loop = function _loop() {
    _ref3 = elements[_i2];
    var element = _ref3;
    var rect = interactable.getRect(element);

    if (!rect) {
      return "break";
    }

    var runningInteraction = _$utils_56.arr.find(scope.interactions.list, function (interaction) {
      return interaction.interacting() && interaction.interactable === interactable && interaction.element === element && interaction.prepared.name === action.name;
    });

    var reflowPromise = void 0;

    if (runningInteraction) {
      runningInteraction.move();

      if (promises) {
        reflowPromise = runningInteraction._reflowPromise || new Promise(function (resolve) {
          runningInteraction._reflowResolve = resolve;
        });
      }
    } else {
      var xywh = _$utils_56.rect.tlbrToXywh(rect);

      var coords = {
        page: {
          x: xywh.x,
          y: xywh.y
        },
        client: {
          x: xywh.x,
          y: xywh.y
        },
        timeStamp: scope.now()
      };

      var event = _$utils_56.pointer.coordsToEvent(coords);

      reflowPromise = startReflow(scope, interactable, element, action, event);
    }

    if (promises) {
      promises.push(reflowPromise);
    }
  };

  for (var _i2 = 0; _i2 < elements.length; _i2++) {
    var _ref3;

    var _ret = _loop();

    if (_ret === "break") break;
  }

  return promises && Promise.all(promises).then(function () {
    return interactable;
  });
}

function startReflow(scope, interactable, element, action, event) {
  var interaction = scope.interactions["new"]({
    pointerType: 'reflow'
  });
  var signalArg = {
    interaction: interaction,
    event: event,
    pointer: event,
    eventTarget: element,
    phase: _$InteractEvent_15.EventPhase.Reflow
  };
  interaction.interactable = interactable;
  interaction.element = element;
  interaction.prepared = (0, _$utils_56.extend)({}, action);
  interaction.prevEvent = event;
  interaction.updatePointer(event, event, element, true);

  interaction._doPhase(signalArg);

  var reflowPromise = _$utils_56.win.window.Promise ? new _$utils_56.win.window.Promise(function (resolve) {
    interaction._reflowResolve = resolve;
  }) : null;
  interaction._reflowPromise = reflowPromise;
  interaction.start(action, interactable, element);

  if (interaction._interacting) {
    interaction.move(signalArg);
    interaction.end(event);
  } else {
    interaction.stop();
  }

  interaction.removePointer(event, event);
  interaction.pointerIsDown = false;
  return reflowPromise;
}

var ___default_44 = {
  id: 'reflow',
  install: __install_44
};
_$reflow_44["default"] = ___default_44;

var _$interact_28 = {};
"use strict";

Object.defineProperty(_$interact_28, "__esModule", {
  value: true
});
_$interact_28["default"] = _$interact_28.scope = _$interact_28.interact = void 0;

var ___scope_28 = _$scope_24({});

var __utils_28 = ___interopRequireWildcard_28(_$utils_56);

var ___browser_28 = ___interopRequireDefault_28(_$browser_48);

var ___events_28 = ___interopRequireDefault_28(_$events_52);

function ___interopRequireDefault_28(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_28(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

/** @module interact */
var globalEvents = {};
var scope = new ___scope_28.Scope();
/**
 * ```js
 * interact('#draggable').draggable(true)
 *
 * var rectables = interact('rect')
 * rectables
 *   .gesturable(true)
 *   .on('gesturemove', function (event) {
 *       // ...
 *   })
 * ```
 *
 * The methods of this variable can be used to set elements as interactables
 * and also to change various default settings.
 *
 * Calling it as a function and passing an element or a valid CSS selector
 * string returns an Interactable object which has various methods to configure
 * it.
 *
 * @global
 *
 * @param {Element | string} target The HTML or SVG Element to interact with
 * or CSS selector
 * @return {Interactable}
 */

_$interact_28.scope = scope;

var interact = function interact(target, options) {
  var interactable = scope.interactables.get(target, options);

  if (!interactable) {
    interactable = scope.interactables["new"](target, options);
    interactable.events.global = globalEvents;
  }

  return interactable;
};
/**
 * Use a plugin
 *
 * @alias module:interact.use
 *
 * @param {Object} plugin
 * @param {function} plugin.install
 * @return {interact}
 */


_$interact_28.interact = interact;
interact.use = use;

function use(plugin, options) {
  scope.usePlugin(plugin, options);
  return interact;
}
/**
 * Check if an element or selector has been set with the {@link interact}
 * function
 *
 * @alias module:interact.isSet
 *
 * @param {Element} element The Element being searched for
 * @return {boolean} Indicates if the element or CSS selector was previously
 * passed to interact
 */


interact.isSet = isSet;

function isSet(target, options) {
  return !!scope.interactables.get(target, options && options.context);
}
/**
 * Add a global listener for an InteractEvent or adds a DOM event to `document`
 *
 * @alias module:interact.on
 *
 * @param {string | array | object} type The types of events to listen for
 * @param {function} listener The function event (s)
 * @param {object | boolean} [options] object or useCapture flag for
 * addEventListener
 * @return {object} interact
 */


interact.on = on;

function on(type, listener, options) {
  if (__utils_28.is.string(type) && type.search(' ') !== -1) {
    type = type.trim().split(/ +/);
  }

  if (__utils_28.is.array(type)) {
    for (var _i = 0; _i < type.length; _i++) {
      var _ref;

      _ref = type[_i];
      var eventType = _ref;
      interact.on(eventType, listener, options);
    }

    return interact;
  }

  if (__utils_28.is.object(type)) {
    for (var prop in type) {
      interact.on(prop, type[prop], listener);
    }

    return interact;
  } // if it is an InteractEvent type, add listener to globalEvents


  if (__utils_28.arr.contains(scope.actions.eventTypes, type)) {
    // if this type of event was never bound
    if (!globalEvents[type]) {
      globalEvents[type] = [listener];
    } else {
      globalEvents[type].push(listener);
    }
  } // If non InteractEvent type, addEventListener to document
  else {
      ___events_28["default"].add(scope.document, type, listener, {
        options: options
      });
    }

  return interact;
}
/**
 * Removes a global InteractEvent listener or DOM event from `document`
 *
 * @alias module:interact.off
 *
 * @param {string | array | object} type The types of events that were listened
 * for
 * @param {function} listener The listener function to be removed
 * @param {object | boolean} options [options] object or useCapture flag for
 * removeEventListener
 * @return {object} interact
 */


interact.off = off;

function off(type, listener, options) {
  if (__utils_28.is.string(type) && type.search(' ') !== -1) {
    type = type.trim().split(/ +/);
  }

  if (__utils_28.is.array(type)) {
    for (var _i2 = 0; _i2 < type.length; _i2++) {
      var _ref2;

      _ref2 = type[_i2];
      var eventType = _ref2;
      interact.off(eventType, listener, options);
    }

    return interact;
  }

  if (__utils_28.is.object(type)) {
    for (var prop in type) {
      interact.off(prop, type[prop], listener);
    }

    return interact;
  }

  if (!__utils_28.arr.contains(scope.actions.eventTypes, type)) {
    ___events_28["default"].remove(scope.document, type, listener, options);
  } else {
    var index;

    if (type in globalEvents && (index = globalEvents[type].indexOf(listener)) !== -1) {
      globalEvents[type].splice(index, 1);
    }
  }

  return interact;
}
/**
 * Returns an object which exposes internal data
 * @alias module:interact.debug
 *
 * @return {object} An object with properties that outline the current state
 * and expose internal functions and variables
 */


interact.debug = debug;

function debug() {
  return scope;
} // expose the functions used to calculate multi-touch properties


interact.getPointerAverage = __utils_28.pointer.pointerAverage;
interact.getTouchBBox = __utils_28.pointer.touchBBox;
interact.getTouchDistance = __utils_28.pointer.touchDistance;
interact.getTouchAngle = __utils_28.pointer.touchAngle;
interact.getElementRect = __utils_28.dom.getElementRect;
interact.getElementClientRect = __utils_28.dom.getElementClientRect;
interact.matchesSelector = __utils_28.dom.matchesSelector;
interact.closest = __utils_28.dom.closest;
/**
 * @alias module:interact.supportsTouch
 *
 * @return {boolean} Whether or not the browser supports touch input
 */

interact.supportsTouch = supportsTouch;

function supportsTouch() {
  return ___browser_28["default"].supportsTouch;
}
/**
 * @alias module:interact.supportsPointerEvent
 *
 * @return {boolean} Whether or not the browser supports PointerEvents
 */


interact.supportsPointerEvent = supportsPointerEvent;

function supportsPointerEvent() {
  return ___browser_28["default"].supportsPointerEvent;
}
/**
 * Cancels all interactions (end events are not fired)
 *
 * @alias module:interact.stop
 *
 * @return {object} interact
 */


interact.stop = __stop_28;

function __stop_28() {
  for (var _i3 = 0; _i3 < scope.interactions.list.length; _i3++) {
    var _ref3;

    _ref3 = scope.interactions.list[_i3];
    var interaction = _ref3;
    interaction.stop();
  }

  return interact;
}
/**
 * Returns or sets the distance the pointer must be moved before an action
 * sequence occurs. This also affects tolerance for tap events.
 *
 * @alias module:interact.pointerMoveTolerance
 *
 * @param {number} [newValue] The movement from the start position must be greater than this value
 * @return {interact | number}
 */


interact.pointerMoveTolerance = pointerMoveTolerance;

function pointerMoveTolerance(newValue) {
  if (__utils_28.is.number(newValue)) {
    scope.interactions.pointerMoveTolerance = newValue;
    return interact;
  }

  return scope.interactions.pointerMoveTolerance;
}

scope.interactables.signals.on('unset', function (_ref4) {
  var interactable = _ref4.interactable;
  scope.interactables.list.splice(scope.interactables.list.indexOf(interactable), 1); // Stop related interactions when an Interactable is unset

  for (var _i4 = 0; _i4 < scope.interactions.list.length; _i4++) {
    var _ref5;

    _ref5 = scope.interactions.list[_i4];
    var interaction = _ref5;

    if (interaction.interactable === interactable && interaction.interacting() && !interaction._ending) {
      interaction.stop();
    }
  }
});

interact.addDocument = function (doc, options) {
  return scope.addDocument(doc, options);
};

interact.removeDocument = function (doc) {
  return scope.removeDocument(doc);
};

scope.interact = interact;
var ___default_28 = interact;
_$interact_28["default"] = ___default_28;

var _$interact_27 = {};
"use strict";

Object.defineProperty(_$interact_27, "__esModule", {
  value: true
});
_$interact_27.init = __init_27;
Object.defineProperty(_$interact_27, "autoScroll", {
  enumerable: true,
  get: function get() {
    return _autoScroll["default"];
  }
});
Object.defineProperty(_$interact_27, "interactablePreventDefault", {
  enumerable: true,
  get: function get() {
    return _interactablePreventDefault["default"];
  }
});
Object.defineProperty(_$interact_27, "inertia", {
  enumerable: true,
  get: function get() {
    return _inertia["default"];
  }
});
Object.defineProperty(_$interact_27, "modifiers", {
  enumerable: true,
  get: function get() {
    return ___base_27["default"];
  }
});
Object.defineProperty(_$interact_27, "reflow", {
  enumerable: true,
  get: function get() {
    return _reflow["default"];
  }
});
Object.defineProperty(_$interact_27, "interact", {
  enumerable: true,
  get: function get() {
    return _interact["default"];
  }
});
_$interact_27.pointerEvents = _$interact_27.actions = _$interact_27["default"] = void 0;

var actions = ___interopRequireWildcard_27(_$actions_5);

_$interact_27.actions = actions;

var _autoScroll = ___interopRequireDefault_27(_$autoScroll_7);

var autoStart = ___interopRequireWildcard_27(_$autoStart_12);

var _interactablePreventDefault = ___interopRequireDefault_27(_$interactablePreventDefault_21);

var _devTools = ___interopRequireDefault_27(_$devTools_25);

var _inertia = ___interopRequireDefault_27(_$inertia_26);

var modifiers = ___interopRequireWildcard_27(_$modifiers_31);

var ___base_27 = ___interopRequireDefault_27(_$base_30);

var __pointerEvents_27 = ___interopRequireWildcard_27(_$pointerEvents_42);

_$interact_27.pointerEvents = __pointerEvents_27;

var _reflow = ___interopRequireDefault_27(_$reflow_44);

var _interact = ___interopRequireWildcard_27(_$interact_28);

function ___interopRequireDefault_27(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_27(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function __init_27(window) {
  _interact.scope.init(window);

  _interact["default"].use(_interactablePreventDefault["default"]); // pointerEvents


  _interact["default"].use(__pointerEvents_27); // inertia


  _interact["default"].use(_inertia["default"]); // autoStart, hold


  _interact["default"].use(autoStart); // drag and drop, resize, gesture


  _interact["default"].use(actions); // snap, resize, etc.


  _interact["default"].use(___base_27["default"]); // for backwrads compatibility


  for (var type in modifiers) {
    var _modifiers$type = modifiers[type],
        _defaults = _modifiers$type._defaults,
        _methods = _modifiers$type._methods;
    _defaults._methods = _methods;
    _interact.scope.defaults.perAction[type] = _defaults;
  } // autoScroll


  _interact["default"].use(_autoScroll["default"]); // reflow


  _interact["default"].use(_reflow["default"]); // eslint-disable-next-line no-undef


  if (false) {}

  return _interact["default"];
} // eslint-disable-next-line no-undef


_interact["default"].version = "1.5.4";
var ___default_27 = _interact["default"];
_$interact_27["default"] = ___default_27;

var _$types_45 = {};
/// <reference path="./types.d.ts" />
"use strict";

var _$grid_64 = {};
"use strict";

Object.defineProperty(_$grid_64, "__esModule", {
  value: true
});
_$grid_64["default"] = void 0;

function ___slicedToArray_64(arr, i) { return ___arrayWithHoles_64(arr) || ___iterableToArrayLimit_64(arr, i) || ___nonIterableRest_64(); }

function ___nonIterableRest_64() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function ___iterableToArrayLimit_64(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function ___arrayWithHoles_64(arr) { if (Array.isArray(arr)) return arr; }

function createGrid(grid) {
  var coordFields = [['x', 'y'], ['left', 'top'], ['right', 'bottom'], ['width', 'height']].filter(function (_ref) {
    var _ref2 = ___slicedToArray_64(_ref, 2),
        xField = _ref2[0],
        yField = _ref2[1];

    return xField in grid || yField in grid;
  });
  return function (x, y) {
    var range = grid.range,
        _grid$limits = grid.limits,
        limits = _grid$limits === void 0 ? {
      left: -Infinity,
      right: Infinity,
      top: -Infinity,
      bottom: Infinity
    } : _grid$limits,
        _grid$offset = grid.offset,
        offset = _grid$offset === void 0 ? {
      x: 0,
      y: 0
    } : _grid$offset;
    var result = {
      range: range
    };

    for (var _i2 = 0; _i2 < coordFields.length; _i2++) {
      var _ref3;

      _ref3 = coordFields[_i2];

      var _ref4 = _ref3,
          _ref5 = ___slicedToArray_64(_ref4, 2),
          xField = _ref5[0],
          yField = _ref5[1];

      var gridx = Math.round((x - offset.x) / grid[xField]);
      var gridy = Math.round((y - offset.y) / grid[yField]);
      result[xField] = Math.max(limits.left, Math.min(limits.right, gridx * grid[xField] + offset.x));
      result[yField] = Math.max(limits.top, Math.min(limits.bottom, gridy * grid[yField] + offset.y));
    }

    return result;
  };
}

var ___default_64 = createGrid;
_$grid_64["default"] = ___default_64;

var _$snappers_65 = {};
"use strict";

Object.defineProperty(_$snappers_65, "__esModule", {
  value: true
});
Object.defineProperty(_$snappers_65, "grid", {
  enumerable: true,
  get: function get() {
    return _grid["default"];
  }
});

var _grid = ___interopRequireDefault_65(_$grid_64);

function ___interopRequireDefault_65(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _$index_29 = { exports: {} };
"use strict";

Object.defineProperty(_$index_29.exports, "__esModule", {
  value: true
});
_$index_29.exports.init = __init_29;
_$index_29.exports["default"] = void 0;

var ___interact_29 = ___interopRequireWildcard_29(_$interact_27);

var __modifiers_29 = ___interopRequireWildcard_29(_$modifiers_31);

_$types_45;

var ___extend_29 = ___interopRequireDefault_29(_$extend_53);

var snappers = ___interopRequireWildcard_29(_$snappers_65);

function ___interopRequireDefault_29(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ___interopRequireWildcard_29(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj["default"] = obj; return newObj; } }

function ___typeof_29(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ___typeof_29 = function _typeof(obj) { return typeof obj; }; } else { ___typeof_29 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ___typeof_29(obj); }

if ((typeof window === "undefined" ? "undefined" : ___typeof_29(window)) === 'object' && !!window) {
  __init_29(window);
}

function __init_29(win) {
  (0, ___interact_29.init)(win);
  return ___interact_29["default"].use({
    id: 'interactjs',
    install: function install() {
      ___interact_29["default"].modifiers = (0, ___extend_29["default"])({}, __modifiers_29);
      ___interact_29["default"].snappers = snappers;
      ___interact_29["default"].createSnapGrid = ___interact_29["default"].snappers.grid;
    }
  });
}

var ___default_29 = ___interact_29["default"];
_$index_29.exports["default"] = ___default_29;
___interact_29["default"]['default'] = ___interact_29["default"]; // tslint:disable-line no-string-literal

___interact_29["default"]['init'] = __init_29; // tslint:disable-line no-string-literal

if (( false ? undefined : ___typeof_29(_$index_29)) === 'object' && !!_$index_29) {
  _$index_29.exports = ___interact_29["default"];
}

_$index_29 = _$index_29.exports
return _$index_29;

});


//# sourceMappingURL=interact.js.map


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/sweetalert/dist/sweetalert.min.js":
/*!********************************************************!*\
  !*** ./node_modules/sweetalert/dist/sweetalert.min.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {!function(t,e){ true?module.exports=e():undefined}(this,function(){return function(t){function e(o){if(n[o])return n[o].exports;var r=n[o]={i:o,l:!1,exports:{}};return t[o].call(r.exports,r,r.exports,e),r.l=!0,r.exports}var n={};return e.m=t,e.c=n,e.d=function(t,n,o){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:o})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=8)}([function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o="swal-button";e.CLASS_NAMES={MODAL:"swal-modal",OVERLAY:"swal-overlay",SHOW_MODAL:"swal-overlay--show-modal",MODAL_TITLE:"swal-title",MODAL_TEXT:"swal-text",ICON:"swal-icon",ICON_CUSTOM:"swal-icon--custom",CONTENT:"swal-content",FOOTER:"swal-footer",BUTTON_CONTAINER:"swal-button-container",BUTTON:o,CONFIRM_BUTTON:o+"--confirm",CANCEL_BUTTON:o+"--cancel",DANGER_BUTTON:o+"--danger",BUTTON_LOADING:o+"--loading",BUTTON_LOADER:o+"__loader"},e.default=e.CLASS_NAMES},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.getNode=function(t){var e="."+t;return document.querySelector(e)},e.stringToNode=function(t){var e=document.createElement("div");return e.innerHTML=t.trim(),e.firstChild},e.insertAfter=function(t,e){var n=e.nextSibling;e.parentNode.insertBefore(t,n)},e.removeNode=function(t){t.parentElement.removeChild(t)},e.throwErr=function(t){throw t=t.replace(/ +(?= )/g,""),"SweetAlert: "+(t=t.trim())},e.isPlainObject=function(t){if("[object Object]"!==Object.prototype.toString.call(t))return!1;var e=Object.getPrototypeOf(t);return null===e||e===Object.prototype},e.ordinalSuffixOf=function(t){var e=t%10,n=t%100;return 1===e&&11!==n?t+"st":2===e&&12!==n?t+"nd":3===e&&13!==n?t+"rd":t+"th"}},function(t,e,n){"use strict";function o(t){for(var n in t)e.hasOwnProperty(n)||(e[n]=t[n])}Object.defineProperty(e,"__esModule",{value:!0}),o(n(25));var r=n(26);e.overlayMarkup=r.default,o(n(27)),o(n(28)),o(n(29));var i=n(0),a=i.default.MODAL_TITLE,s=i.default.MODAL_TEXT,c=i.default.ICON,l=i.default.FOOTER;e.iconMarkup='\n  <div class="'+c+'"></div>',e.titleMarkup='\n  <div class="'+a+'"></div>\n',e.textMarkup='\n  <div class="'+s+'"></div>',e.footerMarkup='\n  <div class="'+l+'"></div>\n'},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(1);e.CONFIRM_KEY="confirm",e.CANCEL_KEY="cancel";var r={visible:!0,text:null,value:null,className:"",closeModal:!0},i=Object.assign({},r,{visible:!1,text:"Cancel",value:null}),a=Object.assign({},r,{text:"OK",value:!0});e.defaultButtonList={cancel:i,confirm:a};var s=function(t){switch(t){case e.CONFIRM_KEY:return a;case e.CANCEL_KEY:return i;default:var n=t.charAt(0).toUpperCase()+t.slice(1);return Object.assign({},r,{text:n,value:t})}},c=function(t,e){var n=s(t);return!0===e?Object.assign({},n,{visible:!0}):"string"==typeof e?Object.assign({},n,{visible:!0,text:e}):o.isPlainObject(e)?Object.assign({visible:!0},n,e):Object.assign({},n,{visible:!1})},l=function(t){for(var e={},n=0,o=Object.keys(t);n<o.length;n++){var r=o[n],a=t[r],s=c(r,a);e[r]=s}return e.cancel||(e.cancel=i),e},u=function(t){var n={};switch(t.length){case 1:n[e.CANCEL_KEY]=Object.assign({},i,{visible:!1});break;case 2:n[e.CANCEL_KEY]=c(e.CANCEL_KEY,t[0]),n[e.CONFIRM_KEY]=c(e.CONFIRM_KEY,t[1]);break;default:o.throwErr("Invalid number of 'buttons' in array ("+t.length+").\n      If you want more than 2 buttons, you need to use an object!")}return n};e.getButtonListOpts=function(t){var n=e.defaultButtonList;return"string"==typeof t?n[e.CONFIRM_KEY]=c(e.CONFIRM_KEY,t):Array.isArray(t)?n=u(t):o.isPlainObject(t)?n=l(t):!0===t?n=u([!0,!0]):!1===t?n=u([!1,!1]):void 0===t&&(n=e.defaultButtonList),n}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(2),i=n(0),a=i.default.MODAL,s=i.default.OVERLAY,c=n(30),l=n(31),u=n(32),f=n(33);e.injectElIntoModal=function(t){var e=o.getNode(a),n=o.stringToNode(t);return e.appendChild(n),n};var d=function(t){t.className=a,t.textContent=""},p=function(t,e){d(t);var n=e.className;n&&t.classList.add(n)};e.initModalContent=function(t){var e=o.getNode(a);p(e,t),c.default(t.icon),l.initTitle(t.title),l.initText(t.text),f.default(t.content),u.default(t.buttons,t.dangerMode)};var m=function(){var t=o.getNode(s),e=o.stringToNode(r.modalMarkup);t.appendChild(e)};e.default=m},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(3),r={isOpen:!1,promise:null,actions:{},timer:null},i=Object.assign({},r);e.resetState=function(){i=Object.assign({},r)},e.setActionValue=function(t){if("string"==typeof t)return a(o.CONFIRM_KEY,t);for(var e in t)a(e,t[e])};var a=function(t,e){i.actions[t]||(i.actions[t]={}),Object.assign(i.actions[t],{value:e})};e.setActionOptionsFor=function(t,e){var n=(void 0===e?{}:e).closeModal,o=void 0===n||n;Object.assign(i.actions[t],{closeModal:o})},e.default=i},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(3),i=n(0),a=i.default.OVERLAY,s=i.default.SHOW_MODAL,c=i.default.BUTTON,l=i.default.BUTTON_LOADING,u=n(5);e.openModal=function(){o.getNode(a).classList.add(s),u.default.isOpen=!0};var f=function(){o.getNode(a).classList.remove(s),u.default.isOpen=!1};e.onAction=function(t){void 0===t&&(t=r.CANCEL_KEY);var e=u.default.actions[t],n=e.value;if(!1===e.closeModal){var i=c+"--"+t;o.getNode(i).classList.add(l)}else f();u.default.promise.resolve(n)},e.getState=function(){var t=Object.assign({},u.default);return delete t.promise,delete t.timer,t},e.stopLoading=function(){for(var t=document.querySelectorAll("."+c),e=0;e<t.length;e++){t[e].classList.remove(l)}}},function(t,e){var n;n=function(){return this}();try{n=n||Function("return this")()||(0,eval)("this")}catch(t){"object"==typeof window&&(n=window)}t.exports=n},function(t,e,n){(function(e){t.exports=e.sweetAlert=n(9)}).call(e,n(7))},function(t,e,n){(function(e){t.exports=e.swal=n(10)}).call(e,n(7))},function(t,e,n){"undefined"!=typeof window&&n(11),n(16);var o=n(23).default;t.exports=o},function(t,e,n){var o=n(12);"string"==typeof o&&(o=[[t.i,o,""]]);var r={insertAt:"top"};r.transform=void 0;n(14)(o,r);o.locals&&(t.exports=o.locals)},function(t,e,n){e=t.exports=n(13)(void 0),e.push([t.i,'.swal-icon--error{border-color:#f27474;-webkit-animation:animateErrorIcon .5s;animation:animateErrorIcon .5s}.swal-icon--error__x-mark{position:relative;display:block;-webkit-animation:animateXMark .5s;animation:animateXMark .5s}.swal-icon--error__line{position:absolute;height:5px;width:47px;background-color:#f27474;display:block;top:37px;border-radius:2px}.swal-icon--error__line--left{-webkit-transform:rotate(45deg);transform:rotate(45deg);left:17px}.swal-icon--error__line--right{-webkit-transform:rotate(-45deg);transform:rotate(-45deg);right:16px}@-webkit-keyframes animateErrorIcon{0%{-webkit-transform:rotateX(100deg);transform:rotateX(100deg);opacity:0}to{-webkit-transform:rotateX(0deg);transform:rotateX(0deg);opacity:1}}@keyframes animateErrorIcon{0%{-webkit-transform:rotateX(100deg);transform:rotateX(100deg);opacity:0}to{-webkit-transform:rotateX(0deg);transform:rotateX(0deg);opacity:1}}@-webkit-keyframes animateXMark{0%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}50%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}80%{-webkit-transform:scale(1.15);transform:scale(1.15);margin-top:-6px}to{-webkit-transform:scale(1);transform:scale(1);margin-top:0;opacity:1}}@keyframes animateXMark{0%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}50%{-webkit-transform:scale(.4);transform:scale(.4);margin-top:26px;opacity:0}80%{-webkit-transform:scale(1.15);transform:scale(1.15);margin-top:-6px}to{-webkit-transform:scale(1);transform:scale(1);margin-top:0;opacity:1}}.swal-icon--warning{border-color:#f8bb86;-webkit-animation:pulseWarning .75s infinite alternate;animation:pulseWarning .75s infinite alternate}.swal-icon--warning__body{width:5px;height:47px;top:10px;border-radius:2px;margin-left:-2px}.swal-icon--warning__body,.swal-icon--warning__dot{position:absolute;left:50%;background-color:#f8bb86}.swal-icon--warning__dot{width:7px;height:7px;border-radius:50%;margin-left:-4px;bottom:-11px}@-webkit-keyframes pulseWarning{0%{border-color:#f8d486}to{border-color:#f8bb86}}@keyframes pulseWarning{0%{border-color:#f8d486}to{border-color:#f8bb86}}.swal-icon--success{border-color:#a5dc86}.swal-icon--success:after,.swal-icon--success:before{content:"";border-radius:50%;position:absolute;width:60px;height:120px;background:#fff;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.swal-icon--success:before{border-radius:120px 0 0 120px;top:-7px;left:-33px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:60px 60px;transform-origin:60px 60px}.swal-icon--success:after{border-radius:0 120px 120px 0;top:-11px;left:30px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-transform-origin:0 60px;transform-origin:0 60px;-webkit-animation:rotatePlaceholder 4.25s ease-in;animation:rotatePlaceholder 4.25s ease-in}.swal-icon--success__ring{width:80px;height:80px;border:4px solid hsla(98,55%,69%,.2);border-radius:50%;box-sizing:content-box;position:absolute;left:-4px;top:-4px;z-index:2}.swal-icon--success__hide-corners{width:5px;height:90px;background-color:#fff;padding:1px;position:absolute;left:28px;top:8px;z-index:1;-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}.swal-icon--success__line{height:5px;background-color:#a5dc86;display:block;border-radius:2px;position:absolute;z-index:2}.swal-icon--success__line--tip{width:25px;left:14px;top:46px;-webkit-transform:rotate(45deg);transform:rotate(45deg);-webkit-animation:animateSuccessTip .75s;animation:animateSuccessTip .75s}.swal-icon--success__line--long{width:47px;right:8px;top:38px;-webkit-transform:rotate(-45deg);transform:rotate(-45deg);-webkit-animation:animateSuccessLong .75s;animation:animateSuccessLong .75s}@-webkit-keyframes rotatePlaceholder{0%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}5%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}12%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}to{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}}@keyframes rotatePlaceholder{0%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}5%{-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}12%{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}to{-webkit-transform:rotate(-405deg);transform:rotate(-405deg)}}@-webkit-keyframes animateSuccessTip{0%{width:0;left:1px;top:19px}54%{width:0;left:1px;top:19px}70%{width:50px;left:-8px;top:37px}84%{width:17px;left:21px;top:48px}to{width:25px;left:14px;top:45px}}@keyframes animateSuccessTip{0%{width:0;left:1px;top:19px}54%{width:0;left:1px;top:19px}70%{width:50px;left:-8px;top:37px}84%{width:17px;left:21px;top:48px}to{width:25px;left:14px;top:45px}}@-webkit-keyframes animateSuccessLong{0%{width:0;right:46px;top:54px}65%{width:0;right:46px;top:54px}84%{width:55px;right:0;top:35px}to{width:47px;right:8px;top:38px}}@keyframes animateSuccessLong{0%{width:0;right:46px;top:54px}65%{width:0;right:46px;top:54px}84%{width:55px;right:0;top:35px}to{width:47px;right:8px;top:38px}}.swal-icon--info{border-color:#c9dae1}.swal-icon--info:before{width:5px;height:29px;bottom:17px;border-radius:2px;margin-left:-2px}.swal-icon--info:after,.swal-icon--info:before{content:"";position:absolute;left:50%;background-color:#c9dae1}.swal-icon--info:after{width:7px;height:7px;border-radius:50%;margin-left:-3px;top:19px}.swal-icon{width:80px;height:80px;border-width:4px;border-style:solid;border-radius:50%;padding:0;position:relative;box-sizing:content-box;margin:20px auto}.swal-icon:first-child{margin-top:32px}.swal-icon--custom{width:auto;height:auto;max-width:100%;border:none;border-radius:0}.swal-icon img{max-width:100%;max-height:100%}.swal-title{color:rgba(0,0,0,.65);font-weight:600;text-transform:none;position:relative;display:block;padding:13px 16px;font-size:27px;line-height:normal;text-align:center;margin-bottom:0}.swal-title:first-child{margin-top:26px}.swal-title:not(:first-child){padding-bottom:0}.swal-title:not(:last-child){margin-bottom:13px}.swal-text{font-size:16px;position:relative;float:none;line-height:normal;vertical-align:top;text-align:left;display:inline-block;margin:0;padding:0 10px;font-weight:400;color:rgba(0,0,0,.64);max-width:calc(100% - 20px);overflow-wrap:break-word;box-sizing:border-box}.swal-text:first-child{margin-top:45px}.swal-text:last-child{margin-bottom:45px}.swal-footer{text-align:right;padding-top:13px;margin-top:13px;padding:13px 16px;border-radius:inherit;border-top-left-radius:0;border-top-right-radius:0}.swal-button-container{margin:5px;display:inline-block;position:relative}.swal-button{background-color:#7cd1f9;color:#fff;border:none;box-shadow:none;border-radius:5px;font-weight:600;font-size:14px;padding:10px 24px;margin:0;cursor:pointer}.swal-button:not([disabled]):hover{background-color:#78cbf2}.swal-button:active{background-color:#70bce0}.swal-button:focus{outline:none;box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(43,114,165,.29)}.swal-button[disabled]{opacity:.5;cursor:default}.swal-button::-moz-focus-inner{border:0}.swal-button--cancel{color:#555;background-color:#efefef}.swal-button--cancel:not([disabled]):hover{background-color:#e8e8e8}.swal-button--cancel:active{background-color:#d7d7d7}.swal-button--cancel:focus{box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(116,136,150,.29)}.swal-button--danger{background-color:#e64942}.swal-button--danger:not([disabled]):hover{background-color:#df4740}.swal-button--danger:active{background-color:#cf423b}.swal-button--danger:focus{box-shadow:0 0 0 1px #fff,0 0 0 3px rgba(165,43,43,.29)}.swal-content{padding:0 20px;margin-top:20px;font-size:medium}.swal-content:last-child{margin-bottom:20px}.swal-content__input,.swal-content__textarea{-webkit-appearance:none;background-color:#fff;border:none;font-size:14px;display:block;box-sizing:border-box;width:100%;border:1px solid rgba(0,0,0,.14);padding:10px 13px;border-radius:2px;transition:border-color .2s}.swal-content__input:focus,.swal-content__textarea:focus{outline:none;border-color:#6db8ff}.swal-content__textarea{resize:vertical}.swal-button--loading{color:transparent}.swal-button--loading~.swal-button__loader{opacity:1}.swal-button__loader{position:absolute;height:auto;width:43px;z-index:2;left:50%;top:50%;-webkit-transform:translateX(-50%) translateY(-50%);transform:translateX(-50%) translateY(-50%);text-align:center;pointer-events:none;opacity:0}.swal-button__loader div{display:inline-block;float:none;vertical-align:baseline;width:9px;height:9px;padding:0;border:none;margin:2px;opacity:.4;border-radius:7px;background-color:hsla(0,0%,100%,.9);transition:background .2s;-webkit-animation:swal-loading-anim 1s infinite;animation:swal-loading-anim 1s infinite}.swal-button__loader div:nth-child(3n+2){-webkit-animation-delay:.15s;animation-delay:.15s}.swal-button__loader div:nth-child(3n+3){-webkit-animation-delay:.3s;animation-delay:.3s}@-webkit-keyframes swal-loading-anim{0%{opacity:.4}20%{opacity:.4}50%{opacity:1}to{opacity:.4}}@keyframes swal-loading-anim{0%{opacity:.4}20%{opacity:.4}50%{opacity:1}to{opacity:.4}}.swal-overlay{position:fixed;top:0;bottom:0;left:0;right:0;text-align:center;font-size:0;overflow-y:auto;background-color:rgba(0,0,0,.4);z-index:10000;pointer-events:none;opacity:0;transition:opacity .3s}.swal-overlay:before{content:" ";display:inline-block;vertical-align:middle;height:100%}.swal-overlay--show-modal{opacity:1;pointer-events:auto}.swal-overlay--show-modal .swal-modal{opacity:1;pointer-events:auto;box-sizing:border-box;-webkit-animation:showSweetAlert .3s;animation:showSweetAlert .3s;will-change:transform}.swal-modal{width:478px;opacity:0;pointer-events:none;background-color:#fff;text-align:center;border-radius:5px;position:static;margin:20px auto;display:inline-block;vertical-align:middle;-webkit-transform:scale(1);transform:scale(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;z-index:10001;transition:opacity .2s,-webkit-transform .3s;transition:transform .3s,opacity .2s;transition:transform .3s,opacity .2s,-webkit-transform .3s}@media (max-width:500px){.swal-modal{width:calc(100% - 20px)}}@-webkit-keyframes showSweetAlert{0%{-webkit-transform:scale(1);transform:scale(1)}1%{-webkit-transform:scale(.5);transform:scale(.5)}45%{-webkit-transform:scale(1.05);transform:scale(1.05)}80%{-webkit-transform:scale(.95);transform:scale(.95)}to{-webkit-transform:scale(1);transform:scale(1)}}@keyframes showSweetAlert{0%{-webkit-transform:scale(1);transform:scale(1)}1%{-webkit-transform:scale(.5);transform:scale(.5)}45%{-webkit-transform:scale(1.05);transform:scale(1.05)}80%{-webkit-transform:scale(.95);transform:scale(.95)}to{-webkit-transform:scale(1);transform:scale(1)}}',""])},function(t,e){function n(t,e){var n=t[1]||"",r=t[3];if(!r)return n;if(e&&"function"==typeof btoa){var i=o(r);return[n].concat(r.sources.map(function(t){return"/*# sourceURL="+r.sourceRoot+t+" */"})).concat([i]).join("\n")}return[n].join("\n")}function o(t){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(t))))+" */"}t.exports=function(t){var e=[];return e.toString=function(){return this.map(function(e){var o=n(e,t);return e[2]?"@media "+e[2]+"{"+o+"}":o}).join("")},e.i=function(t,n){"string"==typeof t&&(t=[[null,t,""]]);for(var o={},r=0;r<this.length;r++){var i=this[r][0];"number"==typeof i&&(o[i]=!0)}for(r=0;r<t.length;r++){var a=t[r];"number"==typeof a[0]&&o[a[0]]||(n&&!a[2]?a[2]=n:n&&(a[2]="("+a[2]+") and ("+n+")"),e.push(a))}},e}},function(t,e,n){function o(t,e){for(var n=0;n<t.length;n++){var o=t[n],r=m[o.id];if(r){r.refs++;for(var i=0;i<r.parts.length;i++)r.parts[i](o.parts[i]);for(;i<o.parts.length;i++)r.parts.push(u(o.parts[i],e))}else{for(var a=[],i=0;i<o.parts.length;i++)a.push(u(o.parts[i],e));m[o.id]={id:o.id,refs:1,parts:a}}}}function r(t,e){for(var n=[],o={},r=0;r<t.length;r++){var i=t[r],a=e.base?i[0]+e.base:i[0],s=i[1],c=i[2],l=i[3],u={css:s,media:c,sourceMap:l};o[a]?o[a].parts.push(u):n.push(o[a]={id:a,parts:[u]})}return n}function i(t,e){var n=v(t.insertInto);if(!n)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var o=w[w.length-1];if("top"===t.insertAt)o?o.nextSibling?n.insertBefore(e,o.nextSibling):n.appendChild(e):n.insertBefore(e,n.firstChild),w.push(e);else{if("bottom"!==t.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");n.appendChild(e)}}function a(t){if(null===t.parentNode)return!1;t.parentNode.removeChild(t);var e=w.indexOf(t);e>=0&&w.splice(e,1)}function s(t){var e=document.createElement("style");return t.attrs.type="text/css",l(e,t.attrs),i(t,e),e}function c(t){var e=document.createElement("link");return t.attrs.type="text/css",t.attrs.rel="stylesheet",l(e,t.attrs),i(t,e),e}function l(t,e){Object.keys(e).forEach(function(n){t.setAttribute(n,e[n])})}function u(t,e){var n,o,r,i;if(e.transform&&t.css){if(!(i=e.transform(t.css)))return function(){};t.css=i}if(e.singleton){var l=h++;n=g||(g=s(e)),o=f.bind(null,n,l,!1),r=f.bind(null,n,l,!0)}else t.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(n=c(e),o=p.bind(null,n,e),r=function(){a(n),n.href&&URL.revokeObjectURL(n.href)}):(n=s(e),o=d.bind(null,n),r=function(){a(n)});return o(t),function(e){if(e){if(e.css===t.css&&e.media===t.media&&e.sourceMap===t.sourceMap)return;o(t=e)}else r()}}function f(t,e,n,o){var r=n?"":o.css;if(t.styleSheet)t.styleSheet.cssText=x(e,r);else{var i=document.createTextNode(r),a=t.childNodes;a[e]&&t.removeChild(a[e]),a.length?t.insertBefore(i,a[e]):t.appendChild(i)}}function d(t,e){var n=e.css,o=e.media;if(o&&t.setAttribute("media",o),t.styleSheet)t.styleSheet.cssText=n;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(n))}}function p(t,e,n){var o=n.css,r=n.sourceMap,i=void 0===e.convertToAbsoluteUrls&&r;(e.convertToAbsoluteUrls||i)&&(o=y(o)),r&&(o+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */");var a=new Blob([o],{type:"text/css"}),s=t.href;t.href=URL.createObjectURL(a),s&&URL.revokeObjectURL(s)}var m={},b=function(t){var e;return function(){return void 0===e&&(e=t.apply(this,arguments)),e}}(function(){return window&&document&&document.all&&!window.atob}),v=function(t){var e={};return function(n){return void 0===e[n]&&(e[n]=t.call(this,n)),e[n]}}(function(t){return document.querySelector(t)}),g=null,h=0,w=[],y=n(15);t.exports=function(t,e){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");e=e||{},e.attrs="object"==typeof e.attrs?e.attrs:{},e.singleton||(e.singleton=b()),e.insertInto||(e.insertInto="head"),e.insertAt||(e.insertAt="bottom");var n=r(t,e);return o(n,e),function(t){for(var i=[],a=0;a<n.length;a++){var s=n[a],c=m[s.id];c.refs--,i.push(c)}if(t){o(r(t,e),e)}for(var a=0;a<i.length;a++){var c=i[a];if(0===c.refs){for(var l=0;l<c.parts.length;l++)c.parts[l]();delete m[c.id]}}}};var x=function(){var t=[];return function(e,n){return t[e]=n,t.filter(Boolean).join("\n")}}()},function(t,e){t.exports=function(t){var e="undefined"!=typeof window&&window.location;if(!e)throw new Error("fixUrls requires window.location");if(!t||"string"!=typeof t)return t;var n=e.protocol+"//"+e.host,o=n+e.pathname.replace(/\/[^\/]*$/,"/");return t.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(t,e){var r=e.trim().replace(/^"(.*)"$/,function(t,e){return e}).replace(/^'(.*)'$/,function(t,e){return e});if(/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(r))return t;var i;return i=0===r.indexOf("//")?r:0===r.indexOf("/")?n+r:o+r.replace(/^\.\//,""),"url("+JSON.stringify(i)+")"})}},function(t,e,n){var o=n(17);"undefined"==typeof window||window.Promise||(window.Promise=o),n(21),String.prototype.includes||(String.prototype.includes=function(t,e){"use strict";return"number"!=typeof e&&(e=0),!(e+t.length>this.length)&&-1!==this.indexOf(t,e)}),Array.prototype.includes||Object.defineProperty(Array.prototype,"includes",{value:function(t,e){if(null==this)throw new TypeError('"this" is null or not defined');var n=Object(this),o=n.length>>>0;if(0===o)return!1;for(var r=0|e,i=Math.max(r>=0?r:o-Math.abs(r),0);i<o;){if(function(t,e){return t===e||"number"==typeof t&&"number"==typeof e&&isNaN(t)&&isNaN(e)}(n[i],t))return!0;i++}return!1}}),"undefined"!=typeof window&&function(t){t.forEach(function(t){t.hasOwnProperty("remove")||Object.defineProperty(t,"remove",{configurable:!0,enumerable:!0,writable:!0,value:function(){this.parentNode.removeChild(this)}})})}([Element.prototype,CharacterData.prototype,DocumentType.prototype])},function(t,e,n){(function(e){!function(n){function o(){}function r(t,e){return function(){t.apply(e,arguments)}}function i(t){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof t)throw new TypeError("not a function");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],f(t,this)}function a(t,e){for(;3===t._state;)t=t._value;if(0===t._state)return void t._deferreds.push(e);t._handled=!0,i._immediateFn(function(){var n=1===t._state?e.onFulfilled:e.onRejected;if(null===n)return void(1===t._state?s:c)(e.promise,t._value);var o;try{o=n(t._value)}catch(t){return void c(e.promise,t)}s(e.promise,o)})}function s(t,e){try{if(e===t)throw new TypeError("A promise cannot be resolved with itself.");if(e&&("object"==typeof e||"function"==typeof e)){var n=e.then;if(e instanceof i)return t._state=3,t._value=e,void l(t);if("function"==typeof n)return void f(r(n,e),t)}t._state=1,t._value=e,l(t)}catch(e){c(t,e)}}function c(t,e){t._state=2,t._value=e,l(t)}function l(t){2===t._state&&0===t._deferreds.length&&i._immediateFn(function(){t._handled||i._unhandledRejectionFn(t._value)});for(var e=0,n=t._deferreds.length;e<n;e++)a(t,t._deferreds[e]);t._deferreds=null}function u(t,e,n){this.onFulfilled="function"==typeof t?t:null,this.onRejected="function"==typeof e?e:null,this.promise=n}function f(t,e){var n=!1;try{t(function(t){n||(n=!0,s(e,t))},function(t){n||(n=!0,c(e,t))})}catch(t){if(n)return;n=!0,c(e,t)}}var d=setTimeout;i.prototype.catch=function(t){return this.then(null,t)},i.prototype.then=function(t,e){var n=new this.constructor(o);return a(this,new u(t,e,n)),n},i.all=function(t){var e=Array.prototype.slice.call(t);return new i(function(t,n){function o(i,a){try{if(a&&("object"==typeof a||"function"==typeof a)){var s=a.then;if("function"==typeof s)return void s.call(a,function(t){o(i,t)},n)}e[i]=a,0==--r&&t(e)}catch(t){n(t)}}if(0===e.length)return t([]);for(var r=e.length,i=0;i<e.length;i++)o(i,e[i])})},i.resolve=function(t){return t&&"object"==typeof t&&t.constructor===i?t:new i(function(e){e(t)})},i.reject=function(t){return new i(function(e,n){n(t)})},i.race=function(t){return new i(function(e,n){for(var o=0,r=t.length;o<r;o++)t[o].then(e,n)})},i._immediateFn="function"==typeof e&&function(t){e(t)}||function(t){d(t,0)},i._unhandledRejectionFn=function(t){"undefined"!=typeof console&&console&&console.warn("Possible Unhandled Promise Rejection:",t)},i._setImmediateFn=function(t){i._immediateFn=t},i._setUnhandledRejectionFn=function(t){i._unhandledRejectionFn=t},void 0!==t&&t.exports?t.exports=i:n.Promise||(n.Promise=i)}(this)}).call(e,n(18).setImmediate)},function(t,e,n){function o(t,e){this._id=t,this._clearFn=e}var r=Function.prototype.apply;e.setTimeout=function(){return new o(r.call(setTimeout,window,arguments),clearTimeout)},e.setInterval=function(){return new o(r.call(setInterval,window,arguments),clearInterval)},e.clearTimeout=e.clearInterval=function(t){t&&t.close()},o.prototype.unref=o.prototype.ref=function(){},o.prototype.close=function(){this._clearFn.call(window,this._id)},e.enroll=function(t,e){clearTimeout(t._idleTimeoutId),t._idleTimeout=e},e.unenroll=function(t){clearTimeout(t._idleTimeoutId),t._idleTimeout=-1},e._unrefActive=e.active=function(t){clearTimeout(t._idleTimeoutId);var e=t._idleTimeout;e>=0&&(t._idleTimeoutId=setTimeout(function(){t._onTimeout&&t._onTimeout()},e))},n(19),e.setImmediate=setImmediate,e.clearImmediate=clearImmediate},function(t,e,n){(function(t,e){!function(t,n){"use strict";function o(t){"function"!=typeof t&&(t=new Function(""+t));for(var e=new Array(arguments.length-1),n=0;n<e.length;n++)e[n]=arguments[n+1];var o={callback:t,args:e};return l[c]=o,s(c),c++}function r(t){delete l[t]}function i(t){var e=t.callback,o=t.args;switch(o.length){case 0:e();break;case 1:e(o[0]);break;case 2:e(o[0],o[1]);break;case 3:e(o[0],o[1],o[2]);break;default:e.apply(n,o)}}function a(t){if(u)setTimeout(a,0,t);else{var e=l[t];if(e){u=!0;try{i(e)}finally{r(t),u=!1}}}}if(!t.setImmediate){var s,c=1,l={},u=!1,f=t.document,d=Object.getPrototypeOf&&Object.getPrototypeOf(t);d=d&&d.setTimeout?d:t,"[object process]"==={}.toString.call(t.process)?function(){s=function(t){e.nextTick(function(){a(t)})}}():function(){if(t.postMessage&&!t.importScripts){var e=!0,n=t.onmessage;return t.onmessage=function(){e=!1},t.postMessage("","*"),t.onmessage=n,e}}()?function(){var e="setImmediate$"+Math.random()+"$",n=function(n){n.source===t&&"string"==typeof n.data&&0===n.data.indexOf(e)&&a(+n.data.slice(e.length))};t.addEventListener?t.addEventListener("message",n,!1):t.attachEvent("onmessage",n),s=function(n){t.postMessage(e+n,"*")}}():t.MessageChannel?function(){var t=new MessageChannel;t.port1.onmessage=function(t){a(t.data)},s=function(e){t.port2.postMessage(e)}}():f&&"onreadystatechange"in f.createElement("script")?function(){var t=f.documentElement;s=function(e){var n=f.createElement("script");n.onreadystatechange=function(){a(e),n.onreadystatechange=null,t.removeChild(n),n=null},t.appendChild(n)}}():function(){s=function(t){setTimeout(a,0,t)}}(),d.setImmediate=o,d.clearImmediate=r}}("undefined"==typeof self?void 0===t?this:t:self)}).call(e,n(7),n(20))},function(t,e){function n(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function r(t){if(u===setTimeout)return setTimeout(t,0);if((u===n||!u)&&setTimeout)return u=setTimeout,setTimeout(t,0);try{return u(t,0)}catch(e){try{return u.call(null,t,0)}catch(e){return u.call(this,t,0)}}}function i(t){if(f===clearTimeout)return clearTimeout(t);if((f===o||!f)&&clearTimeout)return f=clearTimeout,clearTimeout(t);try{return f(t)}catch(e){try{return f.call(null,t)}catch(e){return f.call(this,t)}}}function a(){b&&p&&(b=!1,p.length?m=p.concat(m):v=-1,m.length&&s())}function s(){if(!b){var t=r(a);b=!0;for(var e=m.length;e;){for(p=m,m=[];++v<e;)p&&p[v].run();v=-1,e=m.length}p=null,b=!1,i(t)}}function c(t,e){this.fun=t,this.array=e}function l(){}var u,f,d=t.exports={};!function(){try{u="function"==typeof setTimeout?setTimeout:n}catch(t){u=n}try{f="function"==typeof clearTimeout?clearTimeout:o}catch(t){f=o}}();var p,m=[],b=!1,v=-1;d.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];m.push(new c(t,e)),1!==m.length||b||r(s)},c.prototype.run=function(){this.fun.apply(null,this.array)},d.title="browser",d.browser=!0,d.env={},d.argv=[],d.version="",d.versions={},d.on=l,d.addListener=l,d.once=l,d.off=l,d.removeListener=l,d.removeAllListeners=l,d.emit=l,d.prependListener=l,d.prependOnceListener=l,d.listeners=function(t){return[]},d.binding=function(t){throw new Error("process.binding is not supported")},d.cwd=function(){return"/"},d.chdir=function(t){throw new Error("process.chdir is not supported")},d.umask=function(){return 0}},function(t,e,n){"use strict";n(22).polyfill()},function(t,e,n){"use strict";function o(t,e){if(void 0===t||null===t)throw new TypeError("Cannot convert first argument to object");for(var n=Object(t),o=1;o<arguments.length;o++){var r=arguments[o];if(void 0!==r&&null!==r)for(var i=Object.keys(Object(r)),a=0,s=i.length;a<s;a++){var c=i[a],l=Object.getOwnPropertyDescriptor(r,c);void 0!==l&&l.enumerable&&(n[c]=r[c])}}return n}function r(){Object.assign||Object.defineProperty(Object,"assign",{enumerable:!1,configurable:!0,writable:!0,value:o})}t.exports={assign:o,polyfill:r}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(24),r=n(6),i=n(5),a=n(36),s=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];if("undefined"!=typeof window){var n=a.getOpts.apply(void 0,t);return new Promise(function(t,e){i.default.promise={resolve:t,reject:e},o.default(n),setTimeout(function(){r.openModal()})})}};s.close=r.onAction,s.getState=r.getState,s.setActionValue=i.setActionValue,s.stopLoading=r.stopLoading,s.setDefaults=a.setDefaults,e.default=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(0),i=r.default.MODAL,a=n(4),s=n(34),c=n(35),l=n(1);e.init=function(t){o.getNode(i)||(document.body||l.throwErr("You can only use SweetAlert AFTER the DOM has loaded!"),s.default(),a.default()),a.initModalContent(t),c.default(t)},e.default=e.init},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),r=o.default.MODAL;e.modalMarkup='\n  <div class="'+r+'" role="dialog" aria-modal="true"></div>',e.default=e.modalMarkup},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),r=o.default.OVERLAY,i='<div \n    class="'+r+'"\n    tabIndex="-1">\n  </div>';e.default=i},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),r=o.default.ICON;e.errorIconMarkup=function(){var t=r+"--error",e=t+"__line";return'\n    <div class="'+t+'__x-mark">\n      <span class="'+e+" "+e+'--left"></span>\n      <span class="'+e+" "+e+'--right"></span>\n    </div>\n  '},e.warningIconMarkup=function(){var t=r+"--warning";return'\n    <span class="'+t+'__body">\n      <span class="'+t+'__dot"></span>\n    </span>\n  '},e.successIconMarkup=function(){var t=r+"--success";return'\n    <span class="'+t+"__line "+t+'__line--long"></span>\n    <span class="'+t+"__line "+t+'__line--tip"></span>\n\n    <div class="'+t+'__ring"></div>\n    <div class="'+t+'__hide-corners"></div>\n  '}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),r=o.default.CONTENT;e.contentMarkup='\n  <div class="'+r+'">\n\n  </div>\n'},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),r=o.default.BUTTON_CONTAINER,i=o.default.BUTTON,a=o.default.BUTTON_LOADER;e.buttonMarkup='\n  <div class="'+r+'">\n\n    <button\n      class="'+i+'"\n    ></button>\n\n    <div class="'+a+'">\n      <div></div>\n      <div></div>\n      <div></div>\n    </div>\n\n  </div>\n'},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(4),r=n(2),i=n(0),a=i.default.ICON,s=i.default.ICON_CUSTOM,c=["error","warning","success","info"],l={error:r.errorIconMarkup(),warning:r.warningIconMarkup(),success:r.successIconMarkup()},u=function(t,e){var n=a+"--"+t;e.classList.add(n);var o=l[t];o&&(e.innerHTML=o)},f=function(t,e){e.classList.add(s);var n=document.createElement("img");n.src=t,e.appendChild(n)},d=function(t){if(t){var e=o.injectElIntoModal(r.iconMarkup);c.includes(t)?u(t,e):f(t,e)}};e.default=d},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(2),r=n(4),i=function(t){navigator.userAgent.includes("AppleWebKit")&&(t.style.display="none",t.offsetHeight,t.style.display="")};e.initTitle=function(t){if(t){var e=r.injectElIntoModal(o.titleMarkup);e.textContent=t,i(e)}},e.initText=function(t){if(t){var e=document.createDocumentFragment();t.split("\n").forEach(function(t,n,o){e.appendChild(document.createTextNode(t)),n<o.length-1&&e.appendChild(document.createElement("br"))});var n=r.injectElIntoModal(o.textMarkup);n.appendChild(e),i(n)}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(4),i=n(0),a=i.default.BUTTON,s=i.default.DANGER_BUTTON,c=n(3),l=n(2),u=n(6),f=n(5),d=function(t,e,n){var r=e.text,i=e.value,d=e.className,p=e.closeModal,m=o.stringToNode(l.buttonMarkup),b=m.querySelector("."+a),v=a+"--"+t;if(b.classList.add(v),d){(Array.isArray(d)?d:d.split(" ")).filter(function(t){return t.length>0}).forEach(function(t){b.classList.add(t)})}n&&t===c.CONFIRM_KEY&&b.classList.add(s),b.textContent=r;var g={};return g[t]=i,f.setActionValue(g),f.setActionOptionsFor(t,{closeModal:p}),b.addEventListener("click",function(){return u.onAction(t)}),m},p=function(t,e){var n=r.injectElIntoModal(l.footerMarkup);for(var o in t){var i=t[o],a=d(o,i,e);i.visible&&n.appendChild(a)}0===n.children.length&&n.remove()};e.default=p},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(3),r=n(4),i=n(2),a=n(5),s=n(6),c=n(0),l=c.default.CONTENT,u=function(t){t.addEventListener("input",function(t){var e=t.target,n=e.value;a.setActionValue(n)}),t.addEventListener("keyup",function(t){if("Enter"===t.key)return s.onAction(o.CONFIRM_KEY)}),setTimeout(function(){t.focus(),a.setActionValue("")},0)},f=function(t,e,n){var o=document.createElement(e),r=l+"__"+e;o.classList.add(r);for(var i in n){var a=n[i];o[i]=a}"input"===e&&u(o),t.appendChild(o)},d=function(t){if(t){var e=r.injectElIntoModal(i.contentMarkup),n=t.element,o=t.attributes;"string"==typeof n?f(e,n,o):e.appendChild(n)}};e.default=d},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(2),i=function(){var t=o.stringToNode(r.overlayMarkup);document.body.appendChild(t)};e.default=i},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(5),r=n(6),i=n(1),a=n(3),s=n(0),c=s.default.MODAL,l=s.default.BUTTON,u=s.default.OVERLAY,f=function(t){t.preventDefault(),v()},d=function(t){t.preventDefault(),g()},p=function(t){if(o.default.isOpen)switch(t.key){case"Escape":return r.onAction(a.CANCEL_KEY)}},m=function(t){if(o.default.isOpen)switch(t.key){case"Tab":return f(t)}},b=function(t){if(o.default.isOpen)return"Tab"===t.key&&t.shiftKey?d(t):void 0},v=function(){var t=i.getNode(l);t&&(t.tabIndex=0,t.focus())},g=function(){var t=i.getNode(c),e=t.querySelectorAll("."+l),n=e.length-1,o=e[n];o&&o.focus()},h=function(t){t[t.length-1].addEventListener("keydown",m)},w=function(t){t[0].addEventListener("keydown",b)},y=function(){var t=i.getNode(c),e=t.querySelectorAll("."+l);e.length&&(h(e),w(e))},x=function(t){if(i.getNode(u)===t.target)return r.onAction(a.CANCEL_KEY)},_=function(t){var e=i.getNode(u);e.removeEventListener("click",x),t&&e.addEventListener("click",x)},k=function(t){o.default.timer&&clearTimeout(o.default.timer),t&&(o.default.timer=window.setTimeout(function(){return r.onAction(a.CANCEL_KEY)},t))},O=function(t){t.closeOnEsc?document.addEventListener("keyup",p):document.removeEventListener("keyup",p),t.dangerMode?v():g(),y(),_(t.closeOnClickOutside),k(t.timer)};e.default=O},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r=n(3),i=n(37),a=n(38),s={title:null,text:null,icon:null,buttons:r.defaultButtonList,content:null,className:null,closeOnClickOutside:!0,closeOnEsc:!0,dangerMode:!1,timer:null},c=Object.assign({},s);e.setDefaults=function(t){c=Object.assign({},s,t)};var l=function(t){var e=t&&t.button,n=t&&t.buttons;return void 0!==e&&void 0!==n&&o.throwErr("Cannot set both 'button' and 'buttons' options!"),void 0!==e?{confirm:e}:n},u=function(t){return o.ordinalSuffixOf(t+1)},f=function(t,e){o.throwErr(u(e)+" argument ('"+t+"') is invalid")},d=function(t,e){var n=t+1,r=e[n];o.isPlainObject(r)||void 0===r||o.throwErr("Expected "+u(n)+" argument ('"+r+"') to be a plain object")},p=function(t,e){var n=t+1,r=e[n];void 0!==r&&o.throwErr("Unexpected "+u(n)+" argument ("+r+")")},m=function(t,e,n,r){var i=typeof e,a="string"===i,s=e instanceof Element;if(a){if(0===n)return{text:e};if(1===n)return{text:e,title:r[0]};if(2===n)return d(n,r),{icon:e};f(e,n)}else{if(s&&0===n)return d(n,r),{content:e};if(o.isPlainObject(e))return p(n,r),e;f(e,n)}};e.getOpts=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];var n={};t.forEach(function(e,o){var r=m(0,e,o,t);Object.assign(n,r)});var o=l(n);n.buttons=r.getButtonListOpts(o),delete n.button,n.content=i.getContentOpts(n.content);var u=Object.assign({},s,c,n);return Object.keys(u).forEach(function(t){a.DEPRECATED_OPTS[t]&&a.logDeprecation(t)}),u}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=n(1),r={element:"input",attributes:{placeholder:""}};e.getContentOpts=function(t){var e={};return o.isPlainObject(t)?Object.assign(e,t):t instanceof Element?{element:t}:"input"===t?r:null}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.logDeprecation=function(t){var n=e.DEPRECATED_OPTS[t],o=n.onlyRename,r=n.replacement,i=n.subOption,a=n.link,s=o?"renamed":"deprecated",c='SweetAlert warning: "'+t+'" option has been '+s+".";if(r){c+=" Please use"+(i?' "'+i+'" in ':" ")+'"'+r+'" instead.'}var l="https://sweetalert.js.org";c+=a?" More details: "+l+a:" More details: "+l+"/guides/#upgrading-from-1x",console.warn(c)},e.DEPRECATED_OPTS={type:{replacement:"icon",link:"/docs/#icon"},imageUrl:{replacement:"icon",link:"/docs/#icon"},customClass:{replacement:"className",onlyRename:!0,link:"/docs/#classname"},imageSize:{},showCancelButton:{replacement:"buttons",link:"/docs/#buttons"},showConfirmButton:{replacement:"button",link:"/docs/#button"},confirmButtonText:{replacement:"button",link:"/docs/#button"},confirmButtonColor:{},cancelButtonText:{replacement:"buttons",link:"/docs/#buttons"},closeOnConfirm:{replacement:"button",subOption:"closeModal",link:"/docs/#button"},closeOnCancel:{replacement:"buttons",subOption:"closeModal",link:"/docs/#buttons"},showLoaderOnConfirm:{replacement:"buttons"},animation:{},inputType:{replacement:"content",link:"/docs/#content"},inputValue:{replacement:"content",link:"/docs/#content"},inputPlaceholder:{replacement:"content",link:"/docs/#content"},html:{replacement:"content",link:"/docs/#content"},allowEscapeKey:{replacement:"closeOnEsc",onlyRename:!0,link:"/docs/#closeonesc"},allowClickOutside:{replacement:"closeOnClickOutside",onlyRename:!0,link:"/docs/#closeonclickoutside"}}}])});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").clearImmediate))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vue/dist/vue.common.dev.js":
/*!*************************************************!*\
  !*** ./node_modules/vue/dist/vue.common.dev.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.6.10
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */


/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise (val) {
  return (
    isDef(val) &&
    typeof val.then === 'function' &&
    typeof val.catch === 'function'
  )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function (_) { return _; };

/**
 * Generate a string containing static keys from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
];

/*  */



var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/(function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

{
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if (!config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) { return a.id - b.id; });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget (target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget () {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (customSetter) {
        customSetter();
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) { return }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (isUndef(target) || isPrimitive(target)
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (isUndef(target) || isPrimitive(target)
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
{
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  var res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal;
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */



function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
    " Expected " + (expectedTypes.map(capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType);
  // check if we need to specify expected value
  if (expectedTypes.length === 1 &&
      isExplicable(expectedType) &&
      !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }
  return message
}

function styleValue (value, type) {
  if (type === 'String') {
    return ("\"" + value + "\"")
  } else if (type === 'Number') {
    return ("" + (Number(value)))
  } else {
    return ("" + value)
  }
}

function isExplicable (value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while ((cur = cur.$parent)) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) { return }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling (
  handler,
  context,
  args,
  vm,
  info
) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */

var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

var mark;
var measure;

{
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      // perf.clearMeasures(name)
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

{
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var warnReservedPrefix = function (target, key) {
    warn(
      "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
      'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
      'prevent conflicts with Vue internals' +
      'See: https://vuejs.org/v2/api/#data',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) ||
        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
      if (!has && !isAllowed) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns, vm) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  createOnceHandler,
  vm
) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      }
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') { continue }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function normalizeScopedSlots (
  slots,
  normalSlots,
  prevSlots
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res)
      ? [res] // single vnode
      : normalizeChildren(res);
    return res && (
      res.length === 0 ||
      (res.length === 1 && res[0].isComment) // #9658
    ) ? undefined
      : res
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized
}

function proxyNormalSlot(slots, key) {
  return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  (ret)._isVList = true;
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if (!isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (key !== '' && key !== null) {
      // null is a speical value for explicitly removing a binding
      warn(
        ("Invalid value for dynamic directive argument (expected string or null): " + key),
        this
      );
    }
  }
  return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
  return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(
        data.scopedSlots,
        this$1.$slots = resolveSlots(children, parent)
      );
    }
    return this$1.$slots
  };

  Object.defineProperty(this, 'scopedSlots', ({
    enumerable: true,
    get: function get () {
      return normalizeScopedSlots(data.scopedSlots, this.slots())
    }
  }));

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1 (f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input'
  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (
      Array.isArray(existing)
        ? existing.indexOf(callback) === -1
        : existing !== callback
    ) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  }
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack becaues all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null

    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        (owners[i]).$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
      warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(
                "timeout (" + (res.timeout) + "ms)"
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn) {
  target.$on(event, fn);
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function createOnceHandler (event, fn) {
  var _target = target;
  return function onceHandler () {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  }
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  }
}

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
  );

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  {
    circular = {};
  }
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (
    performance &&
    typeof performance.now === 'function' &&
    getNow() > document.createEvent('Event').timeStamp
  ) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () { return performance.now(); };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if (!config.async) {
        flushSchedulerQueue();
        return
      }
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = expOrFn.toString();
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
      warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if (sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    {
      if (typeof methods[key] !== 'function') {
        warn(
          "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
      }
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    {
      initProxy(vm);
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = latest[key];
    }
  }
  return modified
}

function Vue (options) {
  if (!(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */



function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.10';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false'
    ? 'false'
    // allow arbitrary string value for contenteditable
    : key === 'contenteditable' && isValidContentEditableValue(value)
      ? value
      : 'true'
};

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    if (oldVnode === vnode) {
      return
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        {
          checkDuplicateKeys(ch);
        }
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && value !== '' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args))
  }
}

/*  */



/* eslint-disable no-unused-vars */
function baseWarn (msg, range) {
  console.error(("[Vue compiler]: " + msg));
}
/* eslint-enable no-unused-vars */

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value, range, dynamic) {
  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

function addAttr (el, name, value, range, dynamic) {
  var attrs = dynamic
    ? (el.dynamicAttrs || (el.dynamicAttrs = []))
    : (el.attrs || (el.attrs = []));
  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
  el.plain = false;
}

// add a raw attr (use this in preTransforms)
function addRawAttr (el, name, value, range) {
  el.attrsMap[name] = value;
  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  isDynamicArg,
  modifiers,
  range
) {
  (el.directives || (el.directives = [])).push(rangeSetItem({
    name: name,
    rawName: rawName,
    value: value,
    arg: arg,
    isDynamicArg: isDynamicArg,
    modifiers: modifiers
  }, range));
  el.plain = false;
}

function prependModifierMarker (symbol, name, dynamic) {
  return dynamic
    ? ("_p(" + name + ",\"" + symbol + "\")")
    : symbol + name // mark the event as captured
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn,
  range,
  dynamic
) {
  modifiers = modifiers || emptyObject;
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
    warn &&
    modifiers.prevent && modifiers.passive
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.',
      range
    );
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  if (modifiers.right) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
    } else if (name === 'click') {
      name = 'contextmenu';
      delete modifiers.right;
    }
  } else if (modifiers.middle) {
    if (dynamic) {
      name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
    } else if (name === 'click') {
      name = 'mouseup';
    }
  }

  // check capture modifier
  if (modifiers.capture) {
    delete modifiers.capture;
    name = prependModifierMarker('!', name, dynamic);
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = prependModifierMarker('~', name, dynamic);
  }
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive;
    name = prependModifierMarker('&', name, dynamic);
  }

  var events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getRawBindingAttr (
  el,
  name
) {
  return el.rawAttrsMap[':' + name] ||
    el.rawAttrsMap['v-bind:' + name] ||
    el.rawAttrsMap[name]
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val
}

function getAndRemoveAttrByRegex (
  el,
  name
) {
  var list = el.attrsList;
  for (var i = 0, l = list.length; i < l; i++) {
    var attr = list[i];
    if (name.test(attr.name)) {
      list.splice(i, 1);
      return attr
    }
  }
}

function rangeSetItem (
  item,
  range
) {
  if (range) {
    if (range.start != null) {
      item.start = range.start;
    }
    if (range.end != null) {
      item.end = range.end;
    }
  }
  return item
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
      "? " + baseValueExpression + ".trim()" +
      ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: JSON.stringify(value),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var res = parseModel(value);
  if (res.key === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len, str, chr, index$1, expressionPos, expressionEndPos;



function parseModel (val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead.",
        el.rawAttrsMap['v-model']
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.',
      el.rawAttrsMap['v-model']
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
    "?_i(" + value + "," + valueBinding + ")>-1" + (
      trueValueBinding === 'true'
        ? (":(" + value + ")")
        : (":_q(" + value + "," + trueValueBinding + ")")
    )
  );
  addHandler(el, 'change',
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + (genAssignmentCode(value, '$$a.concat([$$v])')) + ")}" +
      "else{$$i>-1&&(" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + ")}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type
  {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(
        binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " +
        'because the latter already expands to a value binding internally',
        el.rawAttrsMap[binding]
      );
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1 (event, handler, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1 (
  name,
  handler,
  capture,
  passive
) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;
    handler = original._wrapper = function (e) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget ||
        // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp ||
        // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        e.timeStamp <= 0 ||
        // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document
      ) {
        return original.apply(this, arguments)
      }
    };
  }
  target$1.addEventListener(
    name,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  name,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    name,
    handler._wrapper || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

var svgContainer;

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (
      // skip the update if old and new VDOM state is the same.
      // `value` is handled separately because the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This  #4521 by skipping the unnecesarry `checked` update.
      cur !== oldProps[key]
    ) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

var whitespaceRE = /\s+/;

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  // JSDOM may return undefined for transition properties
  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs (s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

var isVShowDirective = function (d) { return d.name === 'show'; };

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(isNotTextNode);
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if (mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  beforeMount: function beforeMount () {
    var this$1 = this;

    var update = this._update;
    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1);
      // force removing pass
      this$1.__patch__(
        this$1._vnode,
        this$1.kept,
        false, // hydrating
        true // removeOnly (!important, avoids unnecessary moves)
      );
      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (e && e.target !== el) {
            return
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else {
        console[console.info ? 'info' : 'log'](
          'Download the Vue Devtools extension for a better development experience:\n' +
          'https://github.com/vuejs/vue-devtools'
        );
      }
    }
    if (config.productionTip !== false &&
      typeof console !== 'undefined'
    ) {
      console[console.info ? 'info' : 'log'](
        "You are running Vue in development mode.\n" +
        "Make sure to turn on production mode when deploying for production.\n" +
        "See more tips at https://vuejs.org/guide/deployment.html"
      );
    }
  }, 0);
}

/*  */

var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});



function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    rawTokens.push({ '@binding': exp });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  }
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if (staticClass) {
    var res = parseText(staticClass, options.delimiters);
    if (res) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.',
        el.rawAttrsMap['class']
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    {
      var res = parseText(staticStyle, options.delimiters);
      if (res) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.',
          el.rawAttrsMap['style']
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
};

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/**
 * Not type-checking this file because it's mostly vendor code.
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + (unicodeRegExp.source) + "]*";
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp(("^<" + qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
// #7298: escape - to avoid being pased as HTML comment when inlined in page
var comment = /^<!\--/;
var conditionalComment = /^<!\[/;

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t',
  '&#39;': "'"
};
var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
      }

      if (textEnd < 0) {
        text = html;
      }

      if (text) {
        advance(text.length);
      }

      if (options.chars && text) {
        options.chars(text, index - text.length, index);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if (!stack.length && options.warn) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""), { start: index + html.length });
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
        attr.start = index;
        advance(attr[0].length);
        attr.end = index;
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
      if (options.outputSourceRange) {
        attrs[i].start = args.start + args[0].match(/^\s*/).length;
        attrs[i].end = args.end;
      }
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    // Find the closest opened tag of the same type
    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if (i > pos || !tagName &&
          options.warn
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag."),
            { start: stack[i].start, end: stack[i].end }
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;
var dynamicArgRE = /^\[.*\]$/;

var argRE = /:(.*)$/;
var bindRE = /^:|^\.|^v-bind:/;
var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;

var slotRE = /^v-slot(:|$)|^#/;

var lineBreakRE = /[\r\n]/;
var whitespaceRE$1 = /\s+/g;

var invalidAttributeRE = /[\s"'<>\/=]/;

var decodeHTMLCached = cached(he.decode);

var emptySlotScopeToken = "_empty_";

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;
var maybeComponent;

function createASTElement (
  tag,
  attrs,
  parent
) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent: parent,
    children: []
  }
}

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;
  var isReservedTag = options.isReservedTag || no;
  maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var whitespaceOption = options.whitespace;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg, range) {
    if (!warned) {
      warned = true;
      warn$2(msg, range);
    }
  }

  function closeElement (element) {
    trimEndingWhitespace(element);
    if (!inVPre && !element.processed) {
      element = processElement(element, options);
    }
    // tree management
    if (!stack.length && element !== root) {
      // allow root elements with v-if, v-else-if and v-else
      if (root.if && (element.elseif || element.else)) {
        {
          checkRootConstraints(element);
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        });
      } else {
        warnOnce(
          "Component template should contain exactly one root element. " +
          "If you are using v-if on multiple elements, " +
          "use v-else-if to chain them instead.",
          { start: element.start }
        );
      }
    }
    if (currentParent && !element.forbidden) {
      if (element.elseif || element.else) {
        processIfConditions(element, currentParent);
      } else {
        if (element.slotScope) {
          // scoped slot
          // keep it in the children list so that v-else(-if) conditions can
          // find it as the prev node.
          var name = element.slotTarget || '"default"'
          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        }
        currentParent.children.push(element);
        element.parent = currentParent;
      }
    }

    // final children cleanup
    // filter out scoped slots
    element.children = element.children.filter(function (c) { return !(c).slotScope; });
    // remove trailing whitespace node again
    trimEndingWhitespace(element);

    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
    // apply post-transforms
    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  function trimEndingWhitespace (el) {
    // remove trailing whitespace node
    if (!inPre) {
      var lastNode;
      while (
        (lastNode = el.children[el.children.length - 1]) &&
        lastNode.type === 3 &&
        lastNode.text === ' '
      ) {
        el.children.pop();
      }
    }
  }

  function checkRootConstraints (el) {
    if (el.tag === 'slot' || el.tag === 'template') {
      warnOnce(
        "Cannot use <" + (el.tag) + "> as component root element because it may " +
        'contain multiple nodes.',
        { start: el.start }
      );
    }
    if (el.attrsMap.hasOwnProperty('v-for')) {
      warnOnce(
        'Cannot use v-for on stateful component root element because ' +
        'it renders multiple elements.',
        el.rawAttrsMap['v-for']
      );
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start: function start (tag, attrs, unary, start$1, end) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      {
        if (options.outputSourceRange) {
          element.start = start$1;
          element.end = end;
          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
            cumulated[attr.name] = attr;
            return cumulated
          }, {});
        }
        attrs.forEach(function (attr) {
          if (invalidAttributeRE.test(attr.name)) {
            warn$2(
              "Invalid dynamic argument expression: attribute names cannot contain " +
              "spaces, quotes, <, >, / or =.",
              {
                start: attr.start + attr.name.indexOf("["),
                end: attr.start + attr.name.length
              }
            );
          }
        });
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.',
          { start: element.start }
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
      }

      if (!root) {
        root = element;
        {
          checkRootConstraints(root);
        }
      }

      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },

    end: function end (tag, start, end$1) {
      var element = stack[stack.length - 1];
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      if (options.outputSourceRange) {
        element.end = end$1;
      }
      closeElement(element);
    },

    chars: function chars (text, start, end) {
      if (!currentParent) {
        {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.',
              { start: start }
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored."),
              { start: start }
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      if (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
      } else if (!children.length) {
        // remove the whitespace-only node right after an opening tag
        text = '';
      } else if (whitespaceOption) {
        if (whitespaceOption === 'condense') {
          // in condense mode, remove the whitespace node if it contains
          // line break, otherwise condense to a single space
          text = lineBreakRE.test(text) ? '' : ' ';
        } else {
          text = ' ';
        }
      } else {
        text = preserveWhitespace ? ' ' : '';
      }
      if (text) {
        if (!inPre && whitespaceOption === 'condense') {
          // condense consecutive whitespaces into single space
          text = text.replace(whitespaceRE$1, ' ');
        }
        var res;
        var child;
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          child = {
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          };
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          child = {
            type: 3,
            text: text
          };
        }
        if (child) {
          if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }
          children.push(child);
        }
      }
    },
    comment: function comment (text, start, end) {
      // adding anyting as a sibling to the root node is forbidden
      // comments should still be allowed, but ignored
      if (currentParent) {
        var child = {
          type: 3,
          text: text,
          isComment: true
        };
        if (options.outputSourceRange) {
          child.start = start;
          child.end = end;
        }
        currentParent.children.push(child);
      }
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var list = el.attrsList;
  var len = list.length;
  if (len) {
    var attrs = el.attrs = new Array(len);
    for (var i = 0; i < len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: JSON.stringify(list[i].value)
      };
      if (list[i].start != null) {
        attrs[i].start = list[i].start;
        attrs[i].end = list[i].end;
      }
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement (
  element,
  options
) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = (
    !element.key &&
    !element.scopedSlots &&
    !element.attrsList.length
  );

  processRef(element);
  processSlotContent(element);
  processSlotOutlet(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
  return element
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    {
      if (el.tag === 'template') {
        warn$2(
          "<template> cannot be keyed. Place the key on real elements instead.",
          getRawBindingAttr(el, 'key')
        );
      }
      if (el.for) {
        var iterator = el.iterator2 || el.iterator1;
        var parent = el.parent;
        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
          warn$2(
            "Do not use v-for index as key on <transition-group> children, " +
            "this is the same as not using keys.",
            getRawBindingAttr(el, 'key'),
            true /* tip */
          );
        }
      }
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var res = parseFor(exp);
    if (res) {
      extend(el, res);
    } else {
      warn$2(
        ("Invalid v-for expression: " + exp),
        el.rawAttrsMap['v-for']
      );
    }
  }
}



function parseFor (exp) {
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) { return }
  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '').trim();
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  return res
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if.",
      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if (children[i].text !== ' ') {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored.",
          children[i]
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

// handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">
function processSlotContent (el) {
  var slotScope;
  if (el.tag === 'template') {
    slotScope = getAndRemoveAttr(el, 'scope');
    /* istanbul ignore if */
    if (slotScope) {
      warn$2(
        "the \"scope\" attribute for scoped slots have been deprecated and " +
        "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
        "can also be used on plain elements in addition to <template> to " +
        "denote scoped slots.",
        el.rawAttrsMap['scope'],
        true
      );
    }
    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
    /* istanbul ignore if */
    if (el.attrsMap['v-for']) {
      warn$2(
        "Ambiguous combined usage of slot-scope and v-for on <" + (el.tag) + "> " +
        "(v-for takes higher priority). Use a wrapper <template> for the " +
        "scoped slot to make it clearer.",
        el.rawAttrsMap['slot-scope'],
        true
      );
    }
    el.slotScope = slotScope;
  }

  // slot="xxx"
  var slotTarget = getBindingAttr(el, 'slot');
  if (slotTarget) {
    el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
    // preserve slot as an attribute for native shadow DOM compat
    // only for non-scoped slots.
    if (el.tag !== 'template' && !el.slotScope) {
      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
    }
  }

  // 2.6 v-slot syntax
  {
    if (el.tag === 'template') {
      // v-slot on <template>
      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding) {
        {
          if (el.slotTarget || el.slotScope) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.parent && !maybeComponent(el.parent)) {
            warn$2(
              "<template v-slot> can only appear at the root level inside " +
              "the receiving the component",
              el
            );
          }
        }
        var ref = getSlotName(slotBinding);
        var name = ref.name;
        var dynamic = ref.dynamic;
        el.slotTarget = name;
        el.slotTargetDynamic = dynamic;
        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
      }
    } else {
      // v-slot on component, denotes default slot
      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
      if (slotBinding$1) {
        {
          if (!maybeComponent(el)) {
            warn$2(
              "v-slot can only be used on components or <template>.",
              slotBinding$1
            );
          }
          if (el.slotScope || el.slotTarget) {
            warn$2(
              "Unexpected mixed usage of different slot syntaxes.",
              el
            );
          }
          if (el.scopedSlots) {
            warn$2(
              "To avoid scope ambiguity, the default slot should also use " +
              "<template> syntax when there are other named slots.",
              slotBinding$1
            );
          }
        }
        // add the component's children to its default slot
        var slots = el.scopedSlots || (el.scopedSlots = {});
        var ref$1 = getSlotName(slotBinding$1);
        var name$1 = ref$1.name;
        var dynamic$1 = ref$1.dynamic;
        var slotContainer = slots[name$1] = createASTElement('template', [], el);
        slotContainer.slotTarget = name$1;
        slotContainer.slotTargetDynamic = dynamic$1;
        slotContainer.children = el.children.filter(function (c) {
          if (!c.slotScope) {
            c.parent = slotContainer;
            return true
          }
        });
        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
        // remove children as they are returned from scopedSlots now
        el.children = [];
        // mark el non-plain so data gets generated
        el.plain = false;
      }
    }
  }
}

function getSlotName (binding) {
  var name = binding.name.replace(slotRE, '');
  if (!name) {
    if (binding.name[0] !== '#') {
      name = 'default';
    } else {
      warn$2(
        "v-slot shorthand syntax requires a slot name.",
        binding
      );
    }
  }
  return dynamicArgRE.test(name)
    // dynamic [name]
    ? { name: name.slice(1, -1), dynamic: true }
    // static name
    : { name: ("\"" + name + "\""), dynamic: false }
}

// handle <slot/> outlets
function processSlotOutlet (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if (el.key) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead.",
        getRawBindingAttr(el, 'key')
      );
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name.replace(dirRE, ''));
      // support .foo shorthand syntax for the .prop modifier
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        if (
          value.trim().length === 0
        ) {
          warn$2(
            ("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"")
          );
        }
        if (modifiers) {
          if (modifiers.prop && !isDynamic) {
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel && !isDynamic) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            syncGen = genAssignmentCode(value, "$event");
            if (!isDynamic) {
              addHandler(
                el,
                ("update:" + (camelize(name))),
                syncGen,
                null,
                false,
                warn$2,
                list[i]
              );
              if (hyphenate(name) !== camelize(name)) {
                addHandler(
                  el,
                  ("update:" + (hyphenate(name))),
                  syncGen,
                  null,
                  false,
                  warn$2,
                  list[i]
                );
              }
            } else {
              // handler w/ dynamic event name
              addHandler(
                el,
                ("\"update:\"+(" + name + ")"),
                syncGen,
                null,
                false,
                warn$2,
                list[i],
                true // dynamic
              );
            }
          }
        }
        if ((modifiers && modifiers.prop) || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value, list[i], isDynamic);
        } else {
          addAttr(el, name, value, list[i], isDynamic);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        isDynamic = dynamicArgRE.test(name);
        if (isDynamic) {
          name = name.slice(1, -1);
        }
        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        isDynamic = false;
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
          if (dynamicArgRE.test(arg)) {
            arg = arg.slice(1, -1);
            isDynamic = true;
          }
        }
        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
        if (name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      {
        var res = parseText(value, delimiters);
        if (res) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.',
            list[i]
          );
        }
      }
      addAttr(el, name, JSON.stringify(value), list[i]);
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component &&
          name === 'muted' &&
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true', list[i]);
      }
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
      map[attrs[i].name] && !isIE && !isEdge
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead.",
        el.rawAttrsMap['v-model']
      );
    }
    _el = _el.parent;
  }
}

/*  */

function preTransformNode (el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (!map['v-model']) {
      return
    }

    var typeBinding;
    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }
    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + (map['v-bind']) + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0
    }
  }
}

function cloneASTElement (el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

var model$1 = {
  preTransformNode: preTransformNode
};

var modules$1 = [
  klass$1,
  style$1,
  model$1
];

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"), dir);
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"), dir);
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*(?:[\w$]+)?\s*\(/;
var fnInvokeRE = /\([^)]*?\);*$/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

// KeyboardEvent.keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// KeyboardEvent.key aliases
var keyNames = {
  // #7880: IE11 and Edge use `Esc` for Escape key name.
  esc: ['Esc', 'Escape'],
  tab: 'Tab',
  enter: 'Enter',
  // #9112: IE11 uses `Spacebar` for Space key name.
  space: [' ', 'Spacebar'],
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  // #9112: IE11 uses `Del` for Delete key name.
  'delete': ['Backspace', 'Delete', 'Del']
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative
) {
  var prefix = isNative ? 'nativeOn:' : 'on:';
  var staticHandlers = "";
  var dynamicHandlers = "";
  for (var name in events) {
    var handlerCode = genHandler(events[name]);
    if (events[name] && events[name].dynamic) {
      dynamicHandlers += name + "," + handlerCode + ",";
    } else {
      staticHandlers += "\"" + name + "\":" + handlerCode + ",";
    }
  }
  staticHandlers = "{" + (staticHandlers.slice(0, -1)) + "}";
  if (dynamicHandlers) {
    return prefix + "_d(" + staticHandlers + ",[" + (dynamicHandlers.slice(0, -1)) + "])"
  } else {
    return prefix + staticHandlers
  }
}

function genHandler (handler) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);
  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value
    }
    return ("function($event){" + (isFunctionInvocation ? ("return " + (handler.value)) : handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = (handler.modifiers);
        genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier]; })
            .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
            .join('||')
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? ("return " + (handler.value) + "($event)")
      : isFunctionExpression
        ? ("return (" + (handler.value) + ")($event)")
        : isFunctionInvocation
          ? ("return " + (handler.value))
          : handler.value;
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return (
    // make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    "if(!$event.type.indexOf('key')&&" +
    (keys.map(genFilterCode).join('&&')) + ")return null;"
  )
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return (
    "_k($event.keyCode," +
    (JSON.stringify(key)) + "," +
    (JSON.stringify(keyCode)) + "," +
    "$event.key," +
    "" + (JSON.stringify(keyName)) +
    ")"
  )
}

/*  */

function on (el, dir) {
  if (dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */





var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
  this.pre = false;
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.parent) {
    el.pre = el.pre || el.parent.pre;
  }

  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data;
      if (!el.plain || (el.pre && state.maybeComponent(el))) {
        data = genData$2(el, state);
      }

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  // Some elements (templates) need to behave differently inside of a v-pre
  // node.  All pre nodes are static roots, so we can use this as a location to
  // wrap a state change and reset it upon exiting the pre node.
  var originalPreState = state.pre;
  if (el.pre) {
    state.pre = el.pre;
  }
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  state.pre = originalPreState;
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
      state.warn(
        "v-once can only be used inside v-for that is keyed. ",
        el.rawAttrsMap['v-once']
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if (state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      el.rawAttrsMap['v-for'],
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:" + (genProps(el.attrs)) + ",";
  }
  // DOM props
  if (el.props) {
    data += "domProps:" + (genProps(el.props)) + ",";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true)) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el, el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind dynamic argument wrap
  // v-bind with dynamic arguments must be applied using the same v-bind object
  // merge helper so that class/style/mustUseProp attrs are handled correctly.
  if (el.dynamicAttrs) {
    data = "_b(" + data + ",\"" + (el.tag) + "\"," + (genProps(el.dynamicAttrs)) + ")";
  }
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:" + (dir.isDynamicArg ? dir.arg : ("\"" + (dir.arg) + "\""))) : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if (el.children.length !== 1 || ast.type !== 1) {
    state.warn(
      'Inline-template components must have exactly one child element.',
      { start: el.start }
    );
  }
  if (ast && ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  el,
  slots,
  state
) {
  // by default scoped slots are considered "stable", this allows child
  // components with only scoped slots to skip forced updates from parent.
  // but in some cases we have to bail-out of this optimization
  // for example if the slot contains dynamic names, has v-if or v-for on them...
  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
    var slot = slots[key];
    return (
      slot.slotTargetDynamic ||
      slot.if ||
      slot.for ||
      containsSlotChild(slot) // is passing down slot from parent which may be dynamic
    )
  });

  // #9534: if a component with scoped slots is inside a conditional branch,
  // it's possible for the same component to be reused but with different
  // compiled slot content. To avoid that, we generate a unique key based on
  // the generated code of all the slot contents.
  var needsKey = !!el.if;

  // OR when it is inside another scoped slot or v-for (the reactivity may be
  // disconnected due to the intermediate scope variable)
  // #9438, #9506
  // TODO: this can be further optimized by properly analyzing in-scope bindings
  // and skip force updating ones that do not actually use scope variables.
  if (!needsForceUpdate) {
    var parent = el.parent;
    while (parent) {
      if (
        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||
        parent.for
      ) {
        needsForceUpdate = true;
        break
      }
      if (parent.if) {
        needsKey = true;
      }
      parent = parent.parent;
    }
  }

  var generatedSlots = Object.keys(slots)
    .map(function (key) { return genScopedSlot(slots[key], state); })
    .join(',');

  return ("scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? (",null,false," + (hash(generatedSlots))) : "") + ")")
}

function hash(str) {
  var hash = 5381;
  var i = str.length;
  while(i) {
    hash = (hash * 33) ^ str.charCodeAt(--i);
  }
  return hash >>> 0
}

function containsSlotChild (el) {
  if (el.type === 1) {
    if (el.tag === 'slot') {
      return true
    }
    return el.children.some(containsSlotChild)
  }
  return false
}

function genScopedSlot (
  el,
  state
) {
  var isLegacySyntax = el.attrsMap['slot-scope'];
  if (el.if && !el.ifProcessed && !isLegacySyntax) {
    return genIf(el, state, genScopedSlot, "null")
  }
  if (el.for && !el.forProcessed) {
    return genFor(el, state, genScopedSlot)
  }
  var slotScope = el.slotScope === emptySlotScopeToken
    ? ""
    : String(el.slotScope);
  var fn = "function(" + slotScope + "){" +
    "return " + (el.tag === 'template'
      ? el.if && isLegacySyntax
        ? ("(" + (el.if) + ")?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  // reverse proxy v-slot without scope on this.$slots
  var reverseProxy = slotScope ? "" : ",proxy:true";
  return ("{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}")
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      var normalizationType = checkSkip
        ? state.maybeComponent(el$1) ? ",1" : ",0"
        : "";
      return ("" + ((altGenElement || genElement)(el$1, state)) + normalizationType)
    }
    var normalizationType$1 = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType$1 ? ("," + normalizationType$1) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } else if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? ("," + children) : '');
  var attrs = el.attrs || el.dynamicAttrs
    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
        // slot props are camelized
        name: camelize(attr.name),
        value: attr.value,
        dynamic: attr.dynamic
      }); }))
    : null;
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var staticProps = "";
  var dynamicProps = "";
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    var value = transformSpecialNewlines(prop.value);
    if (prop.dynamic) {
      dynamicProps += (prop.name) + "," + value + ",";
    } else {
      staticProps += "\"" + (prop.name) + "\":" + value + ",";
    }
  }
  staticProps = "{" + (staticProps.slice(0, -1)) + "}";
  if (dynamicProps) {
    return ("_d(" + staticProps + ",[" + (dynamicProps.slice(0, -1)) + "])")
  } else {
    return staticProps
  }
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */



// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast, warn) {
  if (ast) {
    checkNode(ast, warn);
  }
}

function checkNode (node, warn) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          var range = node.rawAttrsMap[name];
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), warn, range);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), warn, range);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), warn, range);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], warn);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, warn, node);
  }
}

function checkEvent (exp, text, warn, range) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);
  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    warn(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim()),
      range
    );
  }
  checkExpression(exp, text, warn, range);
}

function checkFor (node, text, warn, range) {
  checkExpression(node.for || '', text, warn, range);
  checkIdentifier(node.alias, 'v-for alias', text, warn, range);
  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}

function checkIdentifier (
  ident,
  type,
  text,
  warn,
  range
) {
  if (typeof ident === 'string') {
    try {
      new Function(("var " + ident + "=_"));
    } catch (e) {
      warn(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())), range);
    }
  }
}

function checkExpression (exp, text, warn, range) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      warn(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim()),
        range
      );
    } else {
      warn(
        "invalid expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n",
        range
      );
    }
  }
}

/*  */

var range = 2;

function generateCodeFrame (
  source,
  start,
  end
) {
  if ( start === void 0 ) start = 0;
  if ( end === void 0 ) end = source.length;

  var lines = source.split(/\r?\n/);
  var count = 0;
  var res = [];
  for (var i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;
    if (count >= start) {
      for (var j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) { continue }
        res.push(("" + (j + 1) + (repeat$1(" ", 3 - String(j + 1).length)) + "|  " + (lines[j])));
        var lineLength = lines[j].length;
        if (j === i) {
          // push underline
          var pad = start - (count - lineLength) + 1;
          var length = end > count ? lineLength - pad : end - start;
          res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
        } else if (j > i) {
          if (end > count) {
            var length$1 = Math.min(end - count, lineLength);
            res.push("   |  " + repeat$1("^", length$1));
          }
          count += lineLength + 1;
        }
      }
      break
    }
  }
  return res.join('\n')
}

function repeat$1 (str, n) {
  var result = '';
  if (n > 0) {
    while (true) { // eslint-disable-line
      if (n & 1) { result += str; }
      n >>>= 1;
      if (n <= 0) { break }
      str += str;
    }
  }
  return result
}

/*  */



function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    {
      if (compiled.errors && compiled.errors.length) {
        if (options.outputSourceRange) {
          compiled.errors.forEach(function (e) {
            warn$$1(
              "Error compiling template:\n\n" + (e.msg) + "\n\n" +
              generateCodeFrame(template, e.start, e.end),
              vm
            );
          });
        } else {
          warn$$1(
            "Error compiling template:\n\n" + template + "\n\n" +
            compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
            vm
          );
        }
      }
      if (compiled.tips && compiled.tips.length) {
        if (options.outputSourceRange) {
          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });
        } else {
          compiled.tips.forEach(function (msg) { return tip(msg, vm); });
        }
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];

      var warn = function (msg, range, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        if (options.outputSourceRange) {
          // $flow-disable-line
          var leadingSpaceLength = template.match(/^\s*/)[0].length;

          warn = function (msg, range, tip) {
            var data = { msg: msg };
            if (range) {
              if (range.start != null) {
                data.start = range.start + leadingSpaceLength;
              }
              if (range.end != null) {
                data.end = range.end + leadingSpaceLength;
              }
            }
            (tip ? tips : errors).push(data);
          };
        }
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      finalOptions.warn = warn;

      var compiled = baseCompile(template.trim(), finalOptions);
      {
        detectErrors(compiled.ast, warn);
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compile = ref$1.compile;
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode (href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if (!template) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if (config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if (config.performance && mark) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue.compile = compileToFunctions;

module.exports = Vue;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/vue/dist/vue.common.js":
/*!*********************************************!*\
  !*** ./node_modules/vue/dist/vue.common.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

if (false) {} else {
  module.exports = __webpack_require__(/*! ./vue.common.dev.js */ "./node_modules/vue/dist/vue.common.dev.js")
}


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./resources/js/bootstrap.js":
/*!***********************************!*\
  !*** ./resources/js/bootstrap.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * We'll load the axios HTTP library which allows us to easily issue requests
 * to our Laravel back-end. This library automatically handles sending the
 * CSRF token as a header based on the value of the "XSRF" token cookie.
 */
window.axios = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
window.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
/**
 * Next we will register the CSRF Token as a common header with Axios so that
 * all outgoing HTTP requests automatically have it attached. This is just
 * a simple convenience so we don't have to attach every token manually.
 */

var token = document.head.querySelector('meta[name="csrf-token"]');

if (token) {
  window.axios.defaults.headers.common['X-CSRF-TOKEN'] = token.content;
} else {
  console.error('CSRF token not found: https://laravel.com/docs/csrf#csrf-x-csrf-token');
}
/**
 * Echo exposes an expressive API for subscribing to channels and listening
 * for events that are broadcast by Laravel. Echo and event broadcasting
 * allows your team to easily build robust real-time web applications.
 */
// import Echo from 'laravel-echo'
// window.Pusher = require('pusher-js');
// window.Echo = new Echo({
//     broadcaster: 'pusher',
//     key: process.env.MIX_PUSHER_APP_KEY,
//     cluster: process.env.MIX_PUSHER_APP_CLUSTER,
//     encrypted: true
// });

/***/ }),

/***/ "./resources/js/imageBase64.js":
/*!*************************************!*\
  !*** ./resources/js/imageBase64.js ***!
  \*************************************/
/*! exports provided: imageUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "imageUrl", function() { return imageUrl; });
var imageUrl='data:image/jpeg;base64,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73W1gVRLW8MrWZbc8d1PJ9CKnxw3JKybaMcNwepeiOcJs72Lz6yucxo67JnC1Fzs4W3SWwtlaSORTrbae9nFezLUQ4eJwKHSEhRSV7iNFNfR4kZR3On3yMFwHLPAhNzpqHSF01wIL9PX2m5UVndW266REuhf1fuoAxmXuJDsnLcDdz2Lz0BdJbHVQzxv3erdkkqOdudyp7xtrudybJcKx77QHTUroPrUEfg1QAIiCS8vJG9wGCG888OE8plE5z21IHkld75Bq+IVs1I91nW379nBRVa74+y2SgmuFVPW1txiNXT00kxZHHCXECRzScknBwwjkAe0LwsNw1vatT013uF4a1gc6OspjBvwtbIetgje0AlpdA+LHDhnJwvLU9bFV6oZM0gRvtlE6naRgiEQtZuAeR7ZAeWDlY6B1jTats11tNyaDdrbVyxNn9yJ2wHHV/lPZTtjGeAwAOzK5VA4w84GjQL1zX0NPXNoZqgZzPs62tuC6moL97K01ZIK2W2VdufGatrHOdEad8jWmpZjiAwuG80DhxUh02mNO2uaO26cqKmrhaGuklmMm89zhxILwBg+dRxpSahj15USXB0bqWCy1bKtzmlwc17C1owAckvc3A7ThStPLb47fUWyodPRVIpur6zcy8Zjduvbyz5BwV15P32reedxY/vsVyXl3HRKUYc0Dm45GAZekR32Ub6tbZets1bo253G2V13uc9uls8znEtqIQ3fkjxlobuvY4jPbla9bq29T0s9l0ncJamSAOimudW9xEm6cSPYOccYOcHg7hyW1ooUVJCx1U2pq2zyV9FbKyeEjNWIoi4uIzuOIIx3458FHR1XXaN0yNT2swia3U7Tu1Dd9hLTh7JAOYyCCPOqLM5zqjnCLkk/NdewilhdhU1K+xbDGC0nsHyUs2DVuptEWa76fuFyN9p4LjNHTxSsdFMY2SZMsUoGRkDAwcEHK1rZT2vWOp6aC56zuR0/WWyW60zOteJpJInsDont7N3fG9n8nvXrqys09emUWptMwmCmvNOax9PK479O9w3nxvOOG7xAHkxlLssko/aDUwPpjPWzyV1XRbjMudSiamEuD5cjh2hpxyTogJ6gB+ViO++STFWQYdszFU05F5WkO+NypEght7KeN0cgEW40sJPEjHBect5tNLnflbwUd1El7rJn+DCSOEuPVt5brewY8yyZ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';

/***/ }),

/***/ "./resources/js/welcome.js":
/*!*********************************!*\
  !*** ./resources/js/welcome.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var sweetalert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sweetalert */ "./node_modules/sweetalert/dist/sweetalert.min.js");
/* harmony import */ var sweetalert__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(sweetalert__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var interactjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! interactjs */ "./node_modules/interactjs/dist/interact.js");
/* harmony import */ var interactjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(interactjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! html2canvas */ "./node_modules/html2canvas/dist/html2canvas.js");
/* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(html2canvas__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _imageBase64_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./imageBase64.js */ "./resources/js/imageBase64.js");


function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }





console.log("imageUrl :", _imageBase64_js__WEBPACK_IMPORTED_MODULE_4__["imageUrl"]);

__webpack_require__(/*! ./bootstrap */ "./resources/js/bootstrap.js");

window.Vue = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.common.js");

var cloneOf = function cloneOf(obj) {
  return JSON.parse(JSON.stringify(obj));
};

var b64toBlob =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(
  /*#__PURE__*/
  _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(b64Data) {
    var url, response, blob;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = b64Data;
            console.log("b64Data :", b64Data);
            _context.next = 4;
            return fetch(url);

          case 4:
            response = _context.sent;
            _context.next = 7;
            return response.blob();

          case 7:
            blob = _context.sent;
            console.log("blob :", blob);
            return _context.abrupt("return", blob);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function b64toBlob(_x) {
    return _ref.apply(this, arguments);
  };
}();

var defaultForm = {
  name: '',
  department: ''
};
var defaultFormError = {
  name: false,
  department: false
};
var initData = {
  form: cloneOf(defaultForm),
  formError: cloneOf(defaultFormError),
  getNumber_ing: false,
  submitting: false,
  number: '',
  step: 1,
  imageUrl: '',
  resultImage: '',
  showResult: false,
  showPreview: false,
  text_fontSize: '80px',
  huodongItem: null,
  textNoBorder: false
};
var app = new Vue({
  el: '#app',
  data: cloneOf(initData),
  mounted: function mounted() {// this.makePreview();
  },
  computed: {
    scaleElement: function scaleElement() {
      return this.$refs['scaleElement'];
    },
    uploadInputElement: function uploadInputElement() {
      return this.$refs['uploadInput'];
    },
    containerElement: function containerElement() {
      return this.$refs['container'];
    }
  },
  methods: {
    readUrl: function readUrl(input) {
      var _this = this;

      if (input.files && input.files[0]) {
        var reader = new FileReader();

        reader.onload = function (e) {
          _this.imageUrl = e.target.result;
          _this.step = 3;
        };

        reader.readAsDataURL(input.files[0]);
      }
    },
    handleUploadBtn: function handleUploadBtn(evt) {
      this.uploadInputElement.click();
    },
    handleFileInputChange: function handleFileInputChange(evt) {
      this.readUrl(evt.target);
      console.log("evt :", evt);
    },
    resetField: function resetField() {
      this.form = cloneOf(defaultForm);
    },
    resetError: function resetError() {
      this.formError = cloneOf(defaultFormError);
    },
    validationForm: function validationForm() {
      console.log("this.form :", this.form);
      if (!this.form.name) this.formError.name = true;
      if (!this.form.department) this.formError.department = true;
      return this.formError.name || this.formError.department;
    },
    dragMoveListener: function dragMoveListener(event) {
      var target = event.target; // keep the dragged position in the data-x/data-y attributes

      var x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx;
      var y = (parseFloat(target.getAttribute('data-y')) || 0) + event.dy; // translate the element

      target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px, ' + y + 'px)'; // update the position attributes

      target.setAttribute('data-x', x);
      target.setAttribute('data-y', y);
    },
    convert2canvas: function convert2canvas(element) {
      return new Promise(function (resolve, reject) {
        var shareContent = element;
        var width = shareContent.offsetWidth;
        var height = shareContent.offsetHeight;
        var canvas = document.createElement("canvas");
        var scale = 2;
        canvas.width = width * scale;
        canvas.height = height * scale;
        canvas.getContext("2d").scale(scale, scale);
        var opts = {
          scale: scale,
          canvas: canvas,
          logging: true,
          width: width,
          height: height,
          useCORS: true
        };
        html2canvas__WEBPACK_IMPORTED_MODULE_3___default()(shareContent).then(function (canvas) {
          // var ctx                         = canvas.getContext('2d');
          // ctx.webkitImageSmoothingEnabled = true;
          // ctx.mozImageSmoothingEnabled    = true;
          // ctx.imageSmoothingEnabled       = true;
          // var img                         = canvas.toDataURL('image/png');
          var context = canvas.getContext('2d'); // 

          context.mozImageSmoothingEnabled = false;
          context.webkitImageSmoothingEnabled = false;
          context.msImageSmoothingEnabled = false;
          context.imageSmoothingEnabled = false; // png,

          var img = Canvas2Image.convertToJPEG(canvas, canvas.width, canvas.height);
          resolve(img.src);
        });
      });
    },
    makePhoto: function makePhoto() {
      var _this2 = this;

      this.textNoBorder = true;
      this.containerElement.scrollTop = 0;
      this.$nextTick(
      /*#__PURE__*/
      _asyncToGenerator(
      /*#__PURE__*/
      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2() {
        var img;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                console.log("this.$refs['preview'] :", _this2.$refs['previewImage']);
                _context2.next = 3;
                return _this2.convert2canvas(_this2.$refs['preview']);

              case 3:
                img = _context2.sent;

                _this2.initResult(img);

                _this2.textNoBorder = false;
                _this2.showPreview = false;

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })));
    },
    reset: function reset() {
      this.resetField();
      this.resetError();
      this.step = 1;
      this.showPreview = false;
      this.showResult = false;
      this.imageUrl = '';
      this.number = '';
    },
    submitImage: function () {
      var _submitImage = _asyncToGenerator(
      /*#__PURE__*/
      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3() {
        var image,
            id,
            blob,
            data,
            res,
            _args3 = arguments;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                image = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : this.resultImage;
                id = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : this.huodongItem.id;
                _context3.next = 4;
                return b64toBlob(image);

              case 4:
                blob = _context3.sent;
                data = new FormData();
                data.append('image', blob);
                _context3.next = 9;
                return axios.post("/api/huodong/image/".concat(id), data);

              case 9:
                res = _context3.sent;
                console.log("rse :", res);
                console.log("this.blob :", blob);

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function submitImage() {
        return _submitImage.apply(this, arguments);
      }

      return submitImage;
    }(),
    initResult: function initResult(img) {
      if (!img) {
        sweetalert__WEBPACK_IMPORTED_MODULE_1___default()({
          title: 'Error!',
          content: 'Empty Image. Call Administrator!',
          icon: 'error'
        });
        return;
      }

      this.resultImage = img;
      this.showResult = true;
      this.submitImage();
    },
    setFontSize: function setFontSize(width) {
      this.text_fontSize = Math.floor(width / 2.6) + 'px';
    },
    initTnteract: function initTnteract() {
      var _this3 = this;

      interactjs__WEBPACK_IMPORTED_MODULE_2___default()('.preview-text').draggable({
        // enable inertial throwing
        inertia: true,
        // keep the element within the area of it's parent
        modifiers: [interactjs__WEBPACK_IMPORTED_MODULE_2___default.a.modifiers.restrictRect({
          restriction: 'parent',
          endOnly: true
        })],
        // enable autoScroll
        autoScroll: true,
        // call this function on every dragmove event
        onmove: this.dragMoveListener
      }).resizable({
        // resize from all edges and corners
        edges: {
          left: true,
          right: true
        },
        modifiers: [// keep the edges inside the parent
        interactjs__WEBPACK_IMPORTED_MODULE_2___default.a.modifiers.restrictEdges({
          outer: 'parent',
          endOnly: true
        }), // minimum size
        interactjs__WEBPACK_IMPORTED_MODULE_2___default.a.modifiers.restrictSize({
          min: {
            width: 50,
            height: 50
          }
        })],
        inertia: true
      }).on('resizemove', function (event) {
        var target = event.target;
        var x = parseFloat(target.getAttribute('data-x')) || 0;
        var y = parseFloat(target.getAttribute('data-y')) || 0; // update the element's style

        _this3.setFontSize(event.rect.width);

        target.style.width = event.rect.width + 'px';
        target.style.height = event.rect.height + 'px'; // translate when resizing from top or left edges

        x += event.deltaRect.left;
        y += event.deltaRect.top;
        target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px,' + y + 'px)';
        target.setAttribute('data-x', x);
        target.setAttribute('data-y', y);
      });
    },
    makePreview: function makePreview() {
      this.showPreview = true;
      this.initTnteract();
    },
    handleMakeRow: function () {
      var _handleMakeRow = _asyncToGenerator(
      /*#__PURE__*/
      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee4(data) {
        var res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return axios.post('/api/huodong', data);

              case 2:
                res = _context4.sent;
                this.huodongItem = res.data;

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function handleMakeRow(_x2) {
        return _handleMakeRow.apply(this, arguments);
      }

      return handleMakeRow;
    }(),
    handleSubmit: function handleSubmit(evt) {
      evt.preventDefault();
      if (this.submitting) return;

      if (this.validationForm()) {
        sweetalert__WEBPACK_IMPORTED_MODULE_1___default()({
          title: "Error!",
          text: "Please input success data!",
          icon: "error"
        });
        return;
      }

      this.submitting = true;
      var data = cloneOf(this.form);
      data.number = this.number;
      this.handleMakeRow(data);
      this.makePreview();
    },
    getNumber: function () {
      var _getNumber = _asyncToGenerator(
      /*#__PURE__*/
      _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee5() {
        var res;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.getNumber_ing) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt("return");

              case 2:
                this.getNumber_ing = true;
                _context5.next = 5;
                return axios.get('/api/huodong/number');

              case 5:
                res = _context5.sent;
                this.number = res.data;
                this.getNumber_ing = false;
                this.step = 2;

              case 9:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getNumber() {
        return _getNumber.apply(this, arguments);
      }

      return getNumber;
    }()
  }
});

/***/ }),

/***/ 1:
/*!***************************************!*\
  !*** multi ./resources/js/welcome.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /Users/liuyun/Work/code/huodong_1/resources/js/welcome.js */"./resources/js/welcome.js");


/***/ })

/******/ });